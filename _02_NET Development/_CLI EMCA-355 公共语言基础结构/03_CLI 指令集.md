# CLI：指令集

---
## 引言

本部分详细描述了 Common Intermediate Language (CIL) 指令集，这是 CLI 规范的一部分。第一部分描述了 CLI 的架构，并提供了关于 CIL 指令集的大量问题的概述。这个概述对于理解这里描述的指令集是必要的。

在本部分中，每个指令都在其子小节中描述。相关的 CLI 机器指令一起描述。每个指令描述包括以下部分：

 * 一个描述二进制格式、汇编语言表示法和每个指令变体的描述的表格。参见 §[[↗]](#ins-var-table)。
 - 一个堆栈转换图，描述了指令执行前后的求值堆栈状态。参见 §[[↗]](#stack-img)。
 * 可能由指令抛出的异常列表。有三个异常可以由任何指令抛出，并且不在指令中列出：
   * `System.ExecutionEngineException`：表示执行引擎的内部状态已损坏，无法继续执行。在只执行可验证代码的系统中，不会抛出此异常。
   * `System.StackOverflowException`：表示已超过硬件堆栈大小。此异常的精确时间和发生的条件是特定实现的。此异常与 §[_MaxStack_](#maxstack) 中描述的最大堆栈大小无关。该大小与第一部分中描述的方法状态中一部分的求值堆栈的深度有关，而此异常与在物理硬件上实现该方法状态有关。
   * `System.OutOfMemoryException`：表示可用的内存空间已耗尽，要么是因为指令本质上分配内存 (`newobj`，`newarr`)，要么是出于实现特定的原因 (例如，基于 JIT 编译到本地代码的实现可以在执行给定方法的第一个 `call` 或 `callvirt` 时耗尽存储转换方法的空间)。

 + 描述与指令相关的可验证性条件的部分。参见 §[[↗]](#Verifiability)。

此外，具有数值操作数的操作还指定一个操作数类型表，描述它们如何基于操作数的类型进行操作。参见 §[[↗]](#Operand-type-table)。

请注意，并非所有指令都包含在所有 CLI 配置文件中。参见 [Partition IV](【】) 以获取详细信息。

>---
### 数据类型

虽然 CTS 定义了一个丰富的类型系统，CLS 指定了一个可以用于语言互操作性的子集，但 CLI 本身处理的是一组更简单的类型。这些类型包括用户定义的值类型和内置类型的一个子集。这个子集被统称为 "基本 CLI 类型"，包含以下类型：
 * 完整数值类型的一个子集 (`int32`，`int64`，`native int` 和 `F`)。
 * 对象引用 (`O`)，不区分引用的对象类型。
 * 指针类型 (`native unsigned int` 和 `&`)，不区分指向的类型。

注意，对象引用和指针类型可以被赋值为 `null`。在 CLI 中，这被定义为零 (所有位都为零的位模式)。

就 VES 在求值堆栈上的操作而言，只有一种浮点类型，VES 并不关心其大小。VES 只在将这些值存储到堆、静态变量、局部变量或方法参数，或从中读取时，才对数值的大小进行区分。

#### 数值数据类型
<a id="numeric-data-types"></a>

CLI 只操作数值类型 `int32` (4 字节有符号整数)，`int64` (8 字节有符号整数)，`native int` (本地大小整数)和 `F` (本地大小浮点数)。然而，CIL 指令集允许实现额外的数据类型。

**短整数**：求值栈只保存 4 字节或 8 字节整数，但其他位置 (参数，局部变量，静态变量，数组元素，字段) 可以保存 1 字节或 2 字节整数。对于栈操作，`bool` 和 `char` 类型分别被视为为 1 字节和 2 字节的无符号整数。从这些位置加载到栈上时，会将它们转换为 4 字节值：
   * 对于类型 `unsigned int8`，`unsigned int16`，`bool` 和 `char` 进行零扩展；
   * 对于类型 `int8` 和 `int16` 进行符号扩展；
   * 对于无符号间接和元素加载 (`ldind.u*`，`ldelem.u*` 等) 进行零扩展；和
   * 对于有符号的间接和元素加载 (`ldind.i*`，`ldelem.i*` 等) 进行符号扩展。

存储为整数、布尔值和字符时 (`stloc`，`stfld`，`stind.i1`，`stelem.i2` 等) 会发生截断。使用 `conv.ovf.*` 指令检测当前截断的值是否能正确表示为原始值。

短整数 (即 1 字节和 2 字节) 在所有架构上都作为 4 字节数字加载，这些 4 字节数字始终被跟踪为与 8 字节数字不同。这有助于代码的可移植性，并确保默认的算术行为 (即，当没有执行 `conv` 或 `conv.ovf` 指令时) 在所有实现上都会得到相同的结果。

产生短整数值的转换指令实际上在栈上留下一个 `int32` 值，但保证只有低位有意义 (即，对于无符号转换，更高位都是零；对于有符号转换，是符号扩展)。为了正确模拟短整数操作的完整集合，需要在使用 `div`、`rem`、`shr`、比较和条件分支指令之前对短整数进行转换。

除了显式转换指令外，CLI 在四种情况下以特殊方式处理短整数：
  1. 分配给局部变量 (`stloc`) 或参数 (`starg`) 的值，其类型被声明为短整数类型，会自动截断到为局部变量或参数指定的大小。
  2. 从局部变量 (`ldloc`) 或参数 (`ldarg`) 加载时，若其类型被声明为短有符号整数类型，则会自动符号扩展。
  3. 调用带有短整数类型参数的过程相当于对参数赋值，因此值会被截断。
  4. 从返回类型为短整数的方法返回值，被建模为在被调用过程中存储到短整数中 (CLI 会自动截断)，然后在调用过程中从短整数加载 (CLI 自动零或符号扩展)。

在最后两种情况下，取决于本地调用约定来确定值是否截断或扩展，以及这是在被调用过程还是调用过程中完成的。CIL 指令序列不受影响，就好像 CIL 序列包含了适当的 `conv` 指令。

**4 字节整数**：实际存储在栈上的最短值是 4 字节整数。这些可以使用 `conv.*` 指令转换为 8 字节整数或本地大小整数。本地大小整数可以转换为 4 字节整数，但这会导致程序在架构之间不可移植。如果可以忽略多余的有效位，则可以使用 `conv.i4` 和 `conv.u4` 进行此转换；`conv.ovf.i4` 和 `conv.ovf.u4` 指令可以用来检测信息丢失。算术运算允许 4 字节整数与本地大小整数相结合，结果是本地大小整数。4 字节整数不能直接与 8 字节整数相结合 (它们应首先转换为 8 字节整数)。

**本地大小整数**：本地大小整数可以使用任何正常的算术指令与 4 字节整数相结合，结果将是本地大小整数。本地大小整数在与 8 字节整数相结合之前，应显式转换为 8 字节整数。

**8 字节整数**：在 32 位硬件上支持 8 字节整数可能会很昂贵，而在 64 位硬件上，32 位算术是可用且高效的。因此，数字指令允许 `int32` 和 `I` 数据类型混合 (产生最大的输入类型)，但这些类型不能与 `int64` 结合。相反，`native int` 或 `int32` 应显式转换为 `int64`，然后才能与 `int64` 结合。

**无符号整数**：使用特殊指令将堆栈上的整数解释为无符号，而不是将堆栈位置标记为无符号。

**浮点数**：浮点数的存储位置 (静态、数组元素和类的字段) 是固定大小的。支持的存储大小是 `float32` 和 `float64`。在其他地方 (在求值堆栈上，作为参数，作为返回类型，和作为局部变量)，浮点数使用内部浮点类型表示。在每个这样的实例中，变量或表达式的名义类型是 `float32` 或 `float64`，但其值可能以额外的范围和 / 或精度在内部表示。内部浮点表示的大小取决于实现，可能会变化，并且应至少具有与被表示的变量或表达式一样的精度。当这些类型从存储中加载时，将执行这些类型到内部表示的隐式扩展转换。内部表示通常是硬件的自然大小，或者是为了有效实现操作所需的大小。内部表示应具有以下特性：
  * 内部表示应具有大于或等于名义类型的精度和范围。
  * 到 / 从内部表示的转换应保留值。这意味着从 `float32` (或 `float64`) 到内部表示的隐式扩展转换，后又从内部表示到 `float32` (或 `float64`) 的显式转换，将得到与原始 `float32` (或 `float64`) 值相同的值。

上述规范允许符合规范的实现在中间计算中避免向目标类型的精度进行舍入，从而允许使用更宽精度的硬件寄存器，以及应用优化转换 (如收缩)，这将产生相同或更大的精度。当需要精确可重现的行为精度时，可以使用显式转换。然而，可重现的精度并不保证可重现的行为。具有额外精度的实现可能会舍入两次：一次是浮点运算，一次是显式转换。没有额外精度的实现实际上只舍入一次。在罕见的情况下，舍入两次与舍入一次可能会产生相差一个最小精度单位的结果。

当一个浮点值的内部表示比其名义类型具有更大的范围和 / 或精度，并且被放入存储位置时，它会自动强制转换为存储位置的类型。这可能涉及到精度的损失或创建一个超出范围的值 (**NaN**，**+infinity**，或 **-infinity**)。然而，如果它从存储位置重新加载而没有被修改，那么它的值可能会在内部表示中保留以供将来使用。编译器有责任确保在后续加载时内存位置仍然有效，考虑到别名和其他执行线程的影响。然而，在执行显式转换 (`conv.r4` 或 `conv.r8`) 之后，这种携带额外精度的自由是不允许的，此时内部表示必须能在关联类型中精确表示。

要检测不能转换为特定存储类型的值，可以使用转换指令 (`conv.r4` 或 `conv.r8`)，然后使用 `ckfinite` 检查超出范围的值。在转换为特定存储类型时检测下溢，需要在转换前后与零进行比较。

本标准并未规定对非规格化浮点数的算术运算的行为，也没有规定何时或是否应该创建这样的表示。这与 IEC 60559:1989 保持一致。此外，本标准并未规定如何访问创建的 **NaN** 的确切位模式，以及在 32 位和 64 位表示之间转换 **NaN** 时的行为。所有这些行为都被有意地留给特定实现。

#### 布尔数据类型

CLI 的布尔类型在内存中占用 1 字节。全零的位模式表示假值。任何一个或多个位设置的位模式 (类似于非零整数) 表示真值。为了堆栈操作的目的，布尔值被视为无符号的 1 字节整数。

#### 字符数据类型

CLI 的 `char` 类型在内存中占用 2 字节，并使用 UTF-16 编码表示一个 Unicode 代码单元。为了堆栈操作的目的，`char` 值被视为无符号的 2 字节整数。

#### 对象引用

对象引用 (类型 `O`) 是完全不透明的。没有允许对象引用作为操作数的算术指令，唯一允许的比较操作是两个对象引用之间的等式和不等式。对象引用上没有定义转换操作。对象引用由某些 CIL 对象指令 (特别是 `newobj` 和 `newarr`) 创建。对象引用可以作为参数传递，存储为局部变量，作为值返回，或存储在数组和对象的字段中。

#### 运行时指针类型

有两种指针：非托管指针和托管指针。对于指向同一数组或对象的指针，定义了以下算术运算：
 * 将整数加到指针上，其中整数被解释为字节数，结果是相同类型的指针。
 * 从指针中减去一个整数 (字节数) 得到的是相同类型的指针。注意，不允许从整数中减去一个指针。
 * 两个指针，无论类型如何，可以相互减去，并产生一个有符号整数，表示它们引用的地址之间的字节数。

这些操作在可验证的代码中都是不允许的。

理解在不同类型的指针上使用算术运算对垃圾收集器的影响是很重要的。由于非托管指针永远不会引用由垃圾收集器控制的内存，因此在它们上执行算术运算可能会危及系统的内存安全性 (因此它不是可验证的)，但由于它们没有报告给垃圾收集器，所以对其操作没有影响。

然而，托管指针被报告给垃圾收集器。作为垃圾收集的一部分，它们指向的位置的内容和指针本身都可以被修改。如果托管指针指向不受其控制的内存 (求值栈，调用栈，静态内存，或受其他分配器控制的内存)，垃圾收集器将忽略托管指针。然而，如果一个托管指针引用了由垃圾收集器控制的内存，它必须指向对象的一个字段，数组的一个元素，或者刚好在数组末尾元素的地址。如果使用地址算术创建一个引用任何其他位置 (对象头或分配的内存中的间隙) 的托管指针，垃圾收集器的行为是未指定的。

##### 非托管指针

非托管指针是像 C 和 C++ 这样的语言中使用的传统指针。它们的使用没有限制，尽管在大多数情况下，它们会产生无法验证的代码。虽然将包含非托管指针的位置标记为无符号整数 (实际上，这就是 CLI 处理它们的方式) 是完全有效的，但通常更好的做法是将它们标记为指向特定数据类型的非托管指针。这是通过在返回值、局部变量或参数的签名中使用 *`ELEMENT_TYPE_PTR`*，或者在字段或数组元素中使用指针类型来完成的。

非托管指针不会被报告给垃圾收集器，并且可以以任何整数可以使用的方式使用。

 * 非托管指针应被视为无符号 (即，应使用 `conv.ovf.u` 而不是 `conv.ovf.i` 等)。
 * 可验证的代码不能使用非托管指针来引用内存。
 * 未验证的代码可以将非托管指针传递给期望托管指针的方法。只有在以下情况之一为真时，这才是安全的：
     1. 非托管指针引用的内存不在垃圾收集器管理的内存中。
     2. 非托管指针引用对象内的字段。
     3. 非托管指针引用数组内的元素。
     4. 非托管指针引用的位置是数组中最后一个元素后面的元素所在的位置。

##### 托管指针 (&)

在 CLI 中，托管指针 (`&`) 可以指向局部变量、方法参数、对象字段、值类型字段、数组元素、静态字段，或者存储数组末尾元素之后的元素的地址 (用于指向托管数组的指针索引)。指针不能为 `null`。 (即使它们不指向托管内存，也应该报告给垃圾收集器 )

通过在返回值、局部变量或参数的签名中使用 *`ELEMENT_TYPE_BYREF`*，或者通过对字段或数组元素使用 **byref** 类型来指定托管指针。
 * 托管指针可以作为参数传递并存储在局部变量中。
 * 如果通过引用传递一个参数时，相应的参数就是一个托管指针。
 * 托管指针不能存储在静态变量、数组元素或对象或值类型的字段中。(C# 除 *ref-struct* 类型以外的值类型。) 
 * 托管指针不可以与对象引用互换。
 * 托管指针不能指向另一个托管指针，但它可以指向对象引用或值类型。
 * 不指向托管内存的托管指针可以被转换 (使用 `conv.u` 或 `conv.ovf.u`) 为非托管指针，但这不是可验证的。
 * 错误地将托管指针转换为非托管指针的未验证代码可能严重损害 CLI 的完整性。如果已知以下任何一项为真，则此转换是安全的：
     1. 托管指针不指向垃圾收集器的内存区域。
     2. 在非托管指针使用的整个时间内，所引用的内存已被固定。
     3. 在非托管指针使用期间，不能进行垃圾收集。
     4. 已知给定 CLI 实现的垃圾收集器不会移动所引用的内存。

>---
### 指令变体表
<a id= "ins-var-table"></a>

在 §[III.3](【】) 中，为每个指令提供了一个指令变体表。它描述了指令的每个变体。表格的格式列列出了指令变体的操作码，以及跟随在指令流中的任何操作数。例如：

 | 格式                       | 汇编格式            | 描述                               |
 | -------------------------- | ------------------- | ---------------------------------- |
 | FE 0A _\<unsigned int16\>_ | `ldarga` _argNum_   | 获取参数 _argNum_ 的地址。         |
 | 0F _\<unsigned int8\>_     | `ldarga.s` _argNum_ | 获取参数 _argNum_ 的地址，短格式。 |
 
格式中的第一个或两个十六进制数字显示了这个指令是如何编码的 (它的 "操作码")。例如，`ldarga` 指令被编码为一个包含 FE 的字节，后面跟着一个包含 0A 的字节。由 `< >` 分隔的类型名表示应该在指令流中跟随的数字；例如，一个应该被视为无符号整数的 2 字节量直接跟随在 FE 0A 操作码后面。例如：`ldc.<type>` 指令的一种形式是 `ldc.r8 num`，它的格式为 `23 <float64>`。对于指令 `ldc.r8 3.1415926535897931`，结果代码为 `23 182D4454FB210940`，其中 `182D4454FB210940` 是 `3.1415926535897931` 的 8 字节十六进制表示。

类似地，`ldc. <type>` 指令的另一种形式是 `ldc.i4.s num`，其格式为 `1F <int8>`。对于指令 `ldc.i4.s -3`，结果代码为 `1F FD`，其中 `FD` 是 `-3` 的 1 字节十六进制表示。`.s` 后缀表示指令是短格式指令。在这种情况下，它需要 2 字节，而不是需要 5 字节的长格式 `ldc.i4`。

任何固定大小的内置类型 (`int8`，`unsigned int8`，`int16`，`unsigned int16`，`int32`，`unsigned int32`，`int64`，`unsigned in64`，`float32` 和 `float64`) 都可以出现在格式描述中。这些类型定义了操作数的字节数以及如何解释它 (有符号，无符号或浮点)。此外，元数据 _token_ 可以出现，表示为 `<T>`。_token_ 被编码为 4 字节整数。所有操作数数字都按最小地址的最低有效字节编码 (这种模式通常被称为 "小端")。指令操作码和操作数的字节尽可能紧密地打包 (不进行对齐填充)。

汇编格式列为每个指令变体定义了一个汇编代码助记符。对于具有指令流操作数的指令，此列还为指令的每个操作数分配了名称。对于每个指令操作数，汇编格式中都有一个名称。这些名称稍后在指令描述中使用。

#### Opcode 编码

CIL 操作码长度为一个或多个字节；它们可以后跟零个或多个操作数字节。所有第一个字节位于 0x00 ~ 0xEF，以及 0xFC ~ 0xFF 范围内的操作码都保留用于标准化。第一个字节位于 0xF0 ~ 0xFB（包含）范围内的操作码可用于实验目的。在任何方法中使用实验操作码会使该方法无效，因此无法验证。

> Opcode 编码
<a id="OpTable1"></a>

| Opcode    | Instruction      |
| --------- | ---------------- |
| 0x00      | `nop`            |
| 0x01      | `break`          |
| 0x02      | `ldarg.0`        |
| 0x03      | `ldarg.1`        |
| 0x04      | `ldarg.2`        |
| 0x05      | `ldarg.3`        |
| 0x06      | `ldloc.0`        |
| 0x07      | `ldloc.1`        |
| 0x08      | `ldloc.2`        |
| 0x09      | `ldloc.3`        |
| 0x0A      | `stloc.0`        |
| 0x0B      | `stloc.1`        |
| 0x0C      | `stloc.2`        |
| 0x0D      | `stloc.3`        |
| 0x0E      | `ldarg.s`        |
| 0x0F      | `ldarga.s`       |
| 0x10      | `starg.s`        |
| 0x11      | `ldloc.s`        |
| 0x12      | `ldloca.s`       |
| 0x13      | `stloc.s`        |
| 0x14      | `ldnull`         |
| 0x15      | `ldc.i4.m1`      |
| 0x16      | `ldc.i4.0`       |
| 0x17      | `ldc.i4.1`       |
| 0x18      | `ldc.i4.2`       |
| 0x19      | `ldc.i4.3`       |
| 0x1A      | `ldc.i4.4`       |
| 0x1B      | `ldc.i4.5`       |
| 0x1C      | `ldc.i4.6`       |
| 0x1D      | `ldc.i4.7`       |
| 0x1E      | `ldc.i4.8`       |
| 0x1F      | `ldc.i4.s`       |
| 0x20      | `ldc.i4`         |
| 0x21      | `ldc.i8`         |
| 0x22      | `ldc.r4`         |
| 0x23      | `ldc.r8`         |
| 0x25      | `dup`            |
| 0x26      | `pop`            |
| 0x27      | `jmp`            |
| 0x28      | `call`           |
| 0x29      | `calli`          |
| 0x2A      | `ret`            |
| 0x2B      | `br.s`           |
| 0x2C      | `brfalse.s`      |
| 0x2D      | `brtrue.s`       |
| 0x2E      | `beq.s`          |
| 0x2F      | `bge.s`          |
| 0x30      | `bgt.s`          |
| 0x31      | `ble.s`          |
| 0x32      | `blt.s`          |
| 0x33      | `bne.un.s`       |
| 0x34      | `bge.un.s`       |
| 0x35      | `bgt.un.s`       |
| 0x36      | `ble.un.s`       |
| 0x37      | `blt.un.s`       |
| 0x38      | `br`             |
| 0x39      | `brfalse`        |
| 0x3A      | `brtrue`         |
| 0x3B      | `beq`            |
| 0x3C      | `bge`            |
| 0x3D      | `bgt`            |
| 0x3E      | `ble`            |
| 0x3F      | `blt`            |
| 0x40      | `bne.un`         |
| 0x41      | `bge.un`         |
| 0x42      | `bgt.un`         |
| 0x43      | `ble.un`         |
| 0x44      | `blt.un`         |
| 0x45      | `switch`         |
| 0x46      | `ldind.i1`       |
| 0x47      | `ldind.u1`       |
| 0x48      | `ldind.i2`       |
| 0x49      | `ldind.u2`       |
| 0x4A      | `ldind.i4`       |
| 0x4B      | `ldind.u4`       |
| 0x4C      | `ldind.i8`       |
| 0x4D      | `ldind.i`        |
| 0x4E      | `ldind.r4`       |
| 0x4F      | `ldind.r8`       |
| 0x50      | `ldind.ref`      |
| 0x51      | `stind.ref`      |
| 0x52      | `stind.i1`       |
| 0x53      | `stind.i2`       |
| 0x54      | `stind.i4`       |
| 0x55      | `stind.i8`       |
| 0x56      | `stind.r4`       |
| 0x57      | `stind.r8`       |
| 0x58      | `add`            |
| 0x59      | `sub`            |
| 0x5A      | `mul`            |
| 0x5B      | `div`            |
| 0x5C      | `div.un`         |
| 0x5D      | `rem`            |
| 0x5E      | `rem.un`         |
| 0x5F      | `and`            |
| 0x60      | `or`             |
| 0x61      | `xor`            |
| 0x62      | `shl`            |
| 0x63      | `shr`            |
| 0x64      | `shr.un`         |
| 0x65      | `neg`            |
| 0x66      | `not`            |
| 0x67      | `conv.i1`        |
| 0x68      | `conv.i2`        |
| 0x69      | `conv.i4`        |
| 0x6A      | `conv.i8`        |
| 0x6B      | `conv.r4`        |
| 0x6C      | `conv.r8`        |
| 0x6D      | `conv.u4`        |
| 0x6E      | `conv.u8`        |
| 0x6F      | `callvirt`       |
| 0x70      | `cpobj`          |
| 0x71      | `ldobj`          |
| 0x72      | `ldstr`          |
| 0x73      | `newobj`         |
| 0x74      | `castclass`      |
| 0x75      | `isinst`         |
| 0x76      | `conv.r.un`      |
| 0x79      | `unbox`          |
| 0x7A      | `throw`          |
| 0x7B      | `ldfld`          |
| 0x7C      | `ldflda`         |
| 0x7D      | `stfld`          |
| 0x7E      | `ldsfld`         |
| 0x7F      | `ldsflda`        |
| 0x80      | `stsfld`         |
| 0x81      | `stobj`          |
| 0x82      | `conv.ovf.i1.un` |
| 0x83      | `conv.ovf.i2.un` |
| 0x84      | `conv.ovf.i4.un` |
| 0x85      | `conv.ovf.i8.un` |
| 0x86      | `conv.ovf.u1.un` |
| 0x87      | `conv.ovf.u2.un` |
| 0x88      | `conv.ovf.u4.un` |
| 0x89      | `conv.ovf.u8.un` |
| 0x8A      | `conv.ovf.i.un`  |
| 0x8B      | `conv.ovf.u.un`  |
| 0x8C      | `box`            |
| 0x8D      | `newarr`         |
| 0x8E      | `ldlen`          |
| 0x8F      | `ldelema`        |
| 0x90      | `ldelem.i1`      |
| 0x91      | `ldelem.u1`      |
| 0x92      | `ldelem.i2`      |
| 0x93      | `ldelem.u2`      |
| 0x94      | `ldelem.i4`      |
| 0x95      | `ldelem.u4`      |
| 0x96      | `ldelem.i8`      |
| 0x97      | `ldelem.i`       |
| 0x98      | `ldelem.r4`      |
| 0x99      | `ldelem.r8`      |
| 0x9A      | `ldelem.ref`     |
| 0x9B      | `stelem.i`       |
| 0x9C      | `stelem.i1`      |
| 0x9D      | `stelem.i2`      |
| 0x9E      | `stelem.i4`      |
| 0x9F      | `stelem.i8`      |
| 0xA0      | `stelem.r4`      |
| 0xA1      | `stelem.r8`      |
| 0xA2      | `stelem.ref`     |
| 0xA3      | `ldelem`         |
| 0xA4      | `stelem`         |
| 0xA5      | `unbox.any`      |
| 0xB3      | `conv.ovf.i1`    |
| 0xB4      | `conv.ovf.u1`    |
| 0xB5      | `conv.ovf.i2`    |
| 0xB6      | `conv.ovf.u2`    |
| 0xB7      | `conv.ovf.i4`    |
| 0xB8      | `conv.ovf.u4`    |
| 0xB9      | `conv.ovf.i8`    |
| 0xBA      | `conv.ovf.u8`    |
| 0xC2      | `refanyval`      |
| 0xC3      | `ckfinite`       |
| 0xC6      | `mkrefany`       |
| 0xD0      | `ldtoken`        |
| 0xD1      | `conv.u2`        |
| 0xD2      | `conv.u1`        |
| 0xD3      | `conv.i`         |
| 0xD4      | `conv.ovf.i`     |
| 0xD5      | `conv.ovf.u`     |
| 0xD6      | `add.ovf`        |
| 0xD7      | `add.ovf.un`     |
| 0xD8      | `mul.ovf`        |
| 0xD9      | `mul.ovf.un`     |
| 0xDA      | `sub.ovf`        |
| 0xDB      | `sub.ovf.un`     |
| 0xDC      | `endfinally`     |
| 0xDD      | `leave`          |
| 0xDE      | `leave.s`        |
| 0xDF      | `stind.i`        |
| 0xE0      | `conv.u`         |
| 0xFE 0x00 | `arglist`        |
| 0xFE 0x01 | `ceq`            |
| 0xFE 0x02 | `cgt`            |
| 0xFE 0x03 | `cgt.un`         |
| 0xFE 0x04 | `clt`            |
| 0xFE 0x05 | `clt.un`         |
| 0xFE 0x06 | `ldftn`          |
| 0xFE 0x07 | `ldvirtftn`      |
| 0xFE 0x09 | `ldarg`          |
| 0xFE 0x0A | `ldarga`         |
| 0xFE 0x0B | `starg`          |
| 0xFE 0x0C | `ldloc`          |
| 0xFE 0x0D | `ldloca`         |
| 0xFE 0x0E | `stloc`          |
| 0xFE 0x0F | `localloc`       |
| 0xFE 0x11 | `endfilter`      |
| 0xFE 0x12 | `unaligned.`     |
| 0xFE 0x13 | `volatile.`      |
| 0xFE 0x14 | `tail.`          |
| 0xFE 0x15 | `initobj`        |
| 0xFE 0x16 | `constrained.`   |
| 0xFE 0x17 | `cpblk`          |
| 0xFE 0x18 | `initblk`        |
| 0xFE 0x19 | `no.`            |
| 0xFE 0x1A | `rethrow`        |
| 0xFE 0x1C | `sizeof`         |
| 0xFE 0x1D | `refanytype`     |
| 0xFE 0x1E | `readonly.`      |

>---
### 堆栈转换图
<a id="stack-img"></a>

堆栈转换图显示了指令执行前后的求值堆栈状态。以下是一个典型的堆栈转换图。

&hellip;, _value1_, _value2_ &rarr; &hellip;, _result_

此图表表示堆栈上应至少有两个元素，并且在定义中，最顶部的值（"堆栈顶部" 或 "最近推送"）将被称为 _value2_，下面的值（在 _value2_ 之前推送）将被称为 _value1_。（在这样的图表中，堆栈向右侧，即页面的横向增长）。使用指令后将从堆栈中移除这些值，并用另一个值替换它们，在描述中称为 _result_。

>---
### 操作数类型表
<a id="Operand-type-table"></a>

许多 CIL 操作在堆栈上接受数字操作数。这些操作分为几个类别，取决于它们如何处理操作数的类型。以下表格总结了有效的操作数类型和结果类型。注意，这里所说的类型是 CLI 跟踪的类型，而不是 CIL 验证等工具使用的更详细的类型。CLI 跟踪的类型有：`int32`，`int64`，`native int`，`F`，`O` 和 `&`。

#### 二元数值操作
<a id="OpTable2"></a>

下表显示了 A `op` B 的结果类型 —— 其中 `op` 是 `add`，`div`，`mul`，`rem` 或 `sub` —— 对于每种可能的操作数类型组合。只包含结果类型的框适用于这五个指令。标有 &cross; 的框表示无效的 CIL 指令。<ins>标有 <sup>nv</sup> 的框</ins> 表示不可验证的 CIL 指令。带有指令列表的框表示只对那些指令有效。

 | A \ B            | **`int32`**                            | **`int64`** | **`native int`**                       | **`F`** | **`&`**                                  | **`O`** |
 | ---------------- | -------------------------------------- | ----------- | -------------------------------------- | ------- | ---------------------------------------- | ------- |
 | **`int32`**      | `int32`                                | &cross;     | `native int`                           | &cross; | `&` (`add`) <sup>nv</sup></ins>          | &cross; |
 | **`int64`**      | &cross;                                | `int64`     | &cross;                                | &cross; | &cross;                                  | &cross; |
 | **`native int`** | `native int`                           | &cross;     | `native int`                           | &cross; | `&` (`add`) <sup>nv</sup></ins>          | &cross; |
 | **`F`**          | &cross;                                | &cross;     | &cross;                                | `F`     | &cross;                                  | &cross; |
 | **`&`**          | `&` (`add`, `sub`) <sup>nv</sup></ins> | &cross;     | `&` (`add`, `sub`) <sup>nv</sup></ins> | &cross; | `native int` (`sub`) <sup>nv</sup></ins> | &cross; |
 | **`O`**          | &cross;                                | &cross;     | &cross;                                | &cross; | &cross;                                  | &cross; |

#### 一元数值操作
<a id="OpTable3"></a>

下表显示了一元数值操作的结果类型。用于 `neg` 指令。标有 &cross; 的框表示无效的 CIL 指令。此指令的所有有效用法都是可验证的。

 | Operand Type | Result Type  |
 | ------------ | ------------ |
 | `int32`      | `int32`      |
 | `int64`      | `int64`      |
 | `native int` | `native int` |
 | `F`          | `F`          |
 | `&`          | &cross;      |
 | `O`          | &cross;      |

#### 二元比较或分支操作
<a id="OpTable4"></a>

下表显示了比较和分支指令的结果类型。二元比较返回一个布尔值，分支操作基于堆栈上的前两个值进行分支。用于 `beq`，`beq.s`，`bge`，`bge.s`，`bge.un`，`bge.un.s`，`bgt`，`bgt.s`，`bgt.un`，`bgt.un.s`，`ble`，`ble.s`，`ble.un`，`ble.un.s`，`blt`，`blt.s`，`blt.un`，`blt.un.s`，`bne.un`，`bne.un.s`，`ceq`，`cgt`，`cgt.un`，`clt`，`clt.un`。标有 &check; 的框表示所有指令对于该操作数类型组合都是有效的。标有 &cross; 的框表示无效的 CIL 序列。<ins>标有 <sup>nv</sup> 的框</ins> 表示不可验证的 CIL 指令。带有指令列表的框只对那些指令有效。

 | A \ B            | `int32` | `int64` | `native int`                                 | `F`     | `&`                                          | `O`                                         |
 | ---------------- | ------- | ------- | -------------------------------------------- | ------- | -------------------------------------------- | ------------------------------------------- |
 | **`int32`**      | &check; | &cross; | &check;                                      | &cross; | &cross;                                      | &cross;                                     |
 | **`int64`**      | &cross; | &check; | &cross;                                      | &cross; | &cross;                                      | &cross;                                     |
 | **`native int`** | &check; | &cross; | &check;                                      | &cross; | `beq[.s]`, `bne.un[.s]`, `ceq` <sup>nv</sup> | &cross;                                     |
 | **`F`**          | &cross; | &cross; | &cross;                                      | &check; | &cross;                                      | &cross;                                     |
 | **`&`**          | &cross; | &cross; | `beq[.s]`, `bne.un[.s]`, `ceq` <sup>nv</sup> | &cross; | &check; <sup>1</sup>                         | &cross;                                     |
 | **`O`**          | &cross; | &cross; | &cross;                                      | &cross; | &cross;                                      | `beq[.s]`, `bne.un[.s]`, `ceq` <sup>2</sup> |

<sup>1</sup> 除了 `beq`，`bne.un`，`beq.s`，`bne.un.s` 或 `ceq`，如果两个操作数都已知为指向同一数组元素的指针，那么这些组合是有意义的。然而，对于不检查此约束的 CLI，没有安全问题。如果两个操作数不是指向同一数组的指针，那么结果就是两个无关数据项在垃圾收集堆中的距离。这个距离几乎肯定会在下一次垃圾收集时改变。本质上，此结果不能用来计算任何有用的东西。

<sup>2</sup> `cgt.un` 在 **ObjectRefs** (`O`) 上是允许的并且可以验证的。这通常用于将 **ObjectRef** 与 `null` 进行比较（没有 "compare-not-equal" 指令，否则这将是一个更明显的解决方案）

#### 整数操作
<a id="OpTable5"></a>

下表显示了整数操作中每种可能的操作数类型组合的结果类型。用于 `and`，`div.un`，`not`，`or`，`rem.un`，`xor`。`div.un` 和 `rem.un` 指令将其操作数视为无符号整数，并产生对应于无符号结果的位模式。然而，如 CLI 标准所述，CLI 不区分堆栈上的有符号和无符号整数。`not` 指令是一元的，并返回与输入相同的类型。`shl` 和 `shr` 指令返回与其第一个操作数相同的类型，其第二个操作数应为 `int32` 或 `native int` 类型。标有 &cross; 的框表示无效的 CIL 序列。所有其他框表示可验证的操作数组合。

| A \ B            | `int32`      | `int64` | `native int` | `F`     | `&`     | `O`     |
| ---------------- | ------------ | ------- | ------------ | ------- | ------- | ------- |
| **`int32`**      | `int32`      | &cross; | `native int` | &cross; | &cross; | &cross; |
| **`int64`**      | &cross;      | `int64` | &cross;      | &cross; | &cross; | &cross; |
| **`native int`** | `native int` | &cross; | `native int` | &cross; | &cross; | &cross; |
| **`F`**          | &cross;      | &cross; | &cross;      | &cross; | &cross; | &cross; |
| **`&`**          | &cross;      | &cross; | &cross;      | &cross; | &cross; | &cross; |
| **`O`**          | &cross;      | &cross; | &cross;      | &cross; | &cross; | &cross; |

#### 移位操作
<a id="OpTable6"></a>

下表显示了移位指令：`shl`，`shr`，`shr.un` 的有效操作数和结果的组合。标有 &cross; 的框表示无效的 CIL 序列。所有其他框表示可验证的操作数组合。如果 "Shift-By" 操作数大于 "To-Be-Shifted" 操作数的宽度，那么结果是未指定的。例如，将 `int32` 整数左移 37 位。

 | **To Be Shifted** \ Shift-By | **`int32`**  | **`int64`** | **`native int`** | **`F`** | **`&`** | **`O`** |
 | ---------------------------- | ------------ | ----------- | ---------------- | ------- | ------- | ------- |
 | **`int32`**                  | `int32`      | &cross;     | `int32`          | &cross; | &cross; | &cross; |
 | **`int64`**                  | `int64`      | &cross;     | `int64`          | &cross; | &cross; | &cross; |
 | **`native int`**             | `native int` | &cross;     | `native int`     | &cross; | &cross; | &cross; |
 | **`F`**                      | &cross;      | &cross;     | &cross;          | &cross; | &cross; | &cross; |
 | **`&`**                      | &cross;      | &cross;     | &cross;          | &cross; | &cross; | &cross; |
 | **`O`**                      | &cross;      | &cross;     | &cross;          | &cross; | &cross; | &cross; |

#### 溢出算术运算
<a id="OpTable7"></a>

下表显示了带有溢出检查的算术操作中每种可能的操作数类型组合的结果类型。如果结果不能表示为结果类型，将抛出异常。用于 `add.ovf`，`add.ovf.un`，`mul.ovf`，`mul.ovf.un`，`sub.ovf` 和 `sub.ovf.un`。有关抛出的异常的详细信息，请参阅特定指令的描述。<ins>标有 <sup>nv</sup> 的框</ins> 的是不可验证的，而标有 &cross; 的框表示无效的 CIL 序列。

 | A \ B            | **`int32`**                                  | **`int64`** | **`native int`**                             | **`F`** | **`&`**                                 | **`O`** |
 | ---------------- | -------------------------------------------- | ----------- | -------------------------------------------- | ------- | --------------------------------------- | ------- |
 | **`int32`**      | `int32`                                      | &cross;     | `native int`                                 | &cross; | `&` `add.ovf.un` <sup>nv</sup>          | &cross; |
 | **`int64`**      | &cross;                                      | `int64`     | &cross;                                      | &cross; | &cross;                                 | &cross; |
 | **`native int`** | `native int`                                 | &cross;     | `native int`                                 | &cross; | `&` `add.ovf.un` <sup>nv</sup>          | &cross; |
 | **`F`**          | &cross;                                      | &cross;     | &cross;                                      | &cross; | &cross;                                 | &cross; |
 | **`&`**          | `&` `add.ovf.un`, `sub.ovf.un` <sup>nv</sup> | &cross;     | `&` `add.ovf.un`, `sub.ovf.un` <sup>nv</sup> | &cross; | `native int` `sub.ovf.un` <sup>nv</sup> | &cross; |
 | **`O`**          | &cross;                                      | &cross;     | &cross;                                      | &cross; | &cross;                                 | &cross; |

#### 转换操作
<a id="OpTable8"></a>

下表显示了转换操作的结果类型。转换操作将求值堆栈顶部的项从一个数值类型转换为另一个数值类型。在转换过程中，如表中所示，会发生截断或扩展。结果类型保证可以表示为操作指定的数据类型（即，`conv.u2` 指令返回一个可以存储在 `unsigned int16` 中的值）。然而，堆栈只能存储最小为 4 字节宽的值。用于 `conv.<to type>`，`conv.ovf.<to type>`，和 `conv.ovf.<to type>.un` 指令。<ins>标有 <sup>nv</sup> 的框</ins> 的是不可验证的，而标有 &cross; 的框表示无效的 CIL 序列。

 | Convert-To \ Input                                                          | **`int32`**          | **`int64`**          | **`native int`**     | **`F`**                      | **`&`**                         | **`O`**                         |
 | --------------------------------------------------------------------------- | -------------------- | -------------------- | -------------------- | ---------------------------- | ------------------------------- | ------------------------------- |
 | **`int8`**,<br>**`unsigned int8`**,<br>**`int16`**,<br>**`unsigned int16`** | Truncate<sup>1</sup> | Truncate<sup>1</sup> | Truncate<sup>1</sup> | Truncate to zero<sup>2</sup> | &cross;                         | &cross;                         |
 | **`int32`**,<br>**`unsigned int32`**                                        | Nop                  | Truncate<sup>1</sup> | Truncate<sup>1</sup> | Truncate to zero<sup>2</sup> | &cross;                         | &cross;                         |
 | **`int64`**                                                                 | Sign extend          | Nop                  | Sign extend          | Truncate to zero<sup>2</sup> | Stop GC tracking<sup>nv</sup>   | Stop GC tracking<sup>nv</sup>   |
 | **`unsigned int64`**                                                        | Zero extend          | Nop                  | Zero extend          | Truncate to zero<sup>2</sup> | Stop GC tracking<sup>4,nv</sup> | Stop GC tracking<sup>4,nv</sup> |
 | **`native int`**                                                            | Sign extend          | Truncate<sup>1</sup> | Nop                  | Truncate to zero<sup>2</sup> | Stop GC tracking<sup>4,nv</sup> | Stop GC tracking<sup>4,nv</sup> |
 | **`native unsigned int`**                                                   | Zero extend          | Truncate<sup>1</sup> | Nop                  | Truncate to zero<sup>2</sup> | Stop GC tracking<sup>4,nv</sup> | Stop GC tracking<sup>4,nv</sup> |
 | **All Float Types**                                                         | To Float             | To Float             | To Float             | Change precision<sup>3</sup> | &cross;                         | &cross;                         |


<sup>1</sup> "Truncate" 的意思是将数字截断到所需的大小（即，输入值的最重要的字节被简单地忽略）。如果结果比最小堆栈宽度的 4 字节还要窄，那么这个结果就会被零扩展（如果结果类型是无符号的）或符号扩展（如果结果类型是有符号的）。因此，将值 `0x1234 ABCD` 从求值堆栈转换为 8 位数据产生的结果是 `0xCD`；如果结果类型是 `int8`，这将被符号扩展为 `0xFFFF FFCD`；如果结果类型是 `unsigned int8`，这将被零扩展为 `0x0000 00CD`。

<sup>2</sup> "Truncate to zero" 的意思是，浮点数将通过向零截断转换为整数。因此，1.1 被转换为 1，-1.1 被转换为 -1。

<sup>3</sup> 从求值堆栈上当前可用的精度转换为指令指定的精度。如果堆栈的精度比输出大小更高，那么将使用 IEC 60559:1989 的 "最接近舍入" 模式来计算结果的低位。

<sup>4</sup> "Stop GC tracking" 的意思是，转换后，该项的值将不会被报告给后续的垃圾收集操作（因此，这些操作不会更新该项的值）。

从整数到 `F` 的转换和从 `F` 到整数的转换的舍入模式与算术运算相同。

>---
### 隐式参数强制转换
<a id="OpTable9"></a>

方法调用涉及到在堆栈上的参数值被隐式地分配给被调用方法的参数（使用 `ldarg` 或 `ldarga`，指令访问）。这个分配是一个隐式的 `starg` 指令，可以被称为 *隐式参数强制转换* (_implicit argument coercion_)。在验证的 CLI 中，隐式参数强制转换的有效性，就像 `starg` 指令一样，由验证器可赋值关系（§[[↗]](#Verification-type-compatibility)）确定。正确的 CIL 也允许一个 `native int` 作为一个 **byref**（`&`）传递；在这种情况下，随后的隐式转换后，该值将被垃圾收集跟踪。

虽然 CLI 只操作 6 种类型（`int32`，`native int`，`int64`，`F`，`O` 和 `&`），但元数据为方法的参数提供了更丰富的模型。当准备调用一个方法时，CLI 执行隐式类型转换，详细信息在下表中。（从概念上讲，它将适当的 `conv.*` 指令插入到 CIL 流中，这可能会导致信息丢失，通过截断或舍入）这种隐式转换发生在标记为 &check; 的框中。<ins>标记为 <sup>nv</sup> 的框</ins> 是不可验证的。标记为 &cross; 的框表示无效的 CIL 序列。编译器可以自由地发出显式的 `conv.*` 或 `conv.*.ovf` 指令以达到任何期望的效果。

 | Type In Signature \ Stack Parameter      | **`int32`**            | **`native int`**                          | **`int64`**              | **`F`** | **`&`** | **`O`** | **value type**<sup>1</sup> |
 | ---------------------------------------- | ---------------------- | ----------------------------------------- | ------------------------ | ------- | ------- | ------- | -------------------------- |
 | **`int8`**                               | &check;<br>Truncate    | &check;<br>Truncate                       | &cross;                  | &cross; | &cross; | &cross; | &cross;                    |
 | **`unsigned int8`**,<br>**`bool`**       | &check;<br>Truncate    | &check;<br>Truncate                       | &cross;                  | &cross; | &cross; | &cross; | &cross;                    |
 | **`int16`**                              | &check;<br>Truncate    | &check;<br>Truncate                       | &cross;                  | &cross; | &cross; | &cross; | &cross;                    |
 | **`unsigned int16`**,<br>**`char`**      | &check;<br>Truncate    | &check;<br>Truncate                       | &cross;                  | &cross; | &cross; | &cross; | &cross;                    |
 | **`int32`**                              | &check;<br>Nop         | &check;<br>Truncate                       | &cross;                  | &cross; | &cross; | &cross; | &cross;                    |
 | **`unsigned int32`**                     | &check;<br>Nop         | &check;<br>Truncate                       | &cross;                  | &cross; | &cross; | &cross; | &cross;                    |
 | **`int64`**                              | &cross;                | &cross;                                   | &check;<br>Nop           | &cross; | &cross; | &cross; | &cross;                    |
 | **`unsigned int64`**                     | &cross;                | &cross;                                   | &check;<br>Nop           | &cross; | &cross; | &cross; | &cross;                    |
 | **`native int`**                         | &check;<br>Sign extend | &check;<br>Nop                            | &cross;                  | &cross; | &cross; | &cross; | &cross;                    |
 | **`native unsigned int`**                | &check;<br>Zero extend | &check;<br>Nop                            | &cross;                  | &cross; | &cross; | &cross; | &cross;                    |
 | **`float32`**                            | &cross;                | &cross;                                   | &cross; Note<sup>4</sup> | &cross; | &cross; | &cross; | &cross;                    |
 | **`float64`**                            | &cross;                | &cross;                                   | &cross; Note<sup>4</sup> | &cross; | &cross; | &cross; | &cross;                    |
 | **Class**                                | &cross;                | &cross;                                   | &cross;                  | &cross; | &cross; | &check; | &cross;                    |
 | **Value Type**<sup>1</sup>               | &cross;                | &cross;                                   | &cross;                  | &cross; | &cross; | &cross; | &check;<sup>2</sup>        |
 | **By-reference (Byref) (`&`)**           | &cross;                | &check;<br>Start GC tracking<sup>nv</sup> | &cross;                  | &cross; | &check; | &cross; | &cross;                    |
 | **Typed Reference (RefAny)<sup>3</sup>** | &cross;                | &cross;                                   | &cross;                  | &cross; | &cross; | &cross; | &cross;                    |

<sup>1</sup> 签名中的值类型不能是内置类型的长形式（§[[↗]](./02_CLI%20元数据定义和语义.md/#MethodSpec-blob)）。

<sup>2</sup> CLI 的堆栈可以包含一个值类型。这些只能在堆栈上的特定值类型与所需的值类型完全匹配的情况下传递。

<sup>3</sup> 有特殊的指令来构造和传递一个 `RefAny`。

<sup>4</sup> CLI 允许使用其内部的 `F` 类型传递浮点参数，参见 §[_数值数据类型_](#numeric-data-types)。CIL 生成器当然可以包含一个显式的 `conv.r4`，`conv.r4.ovf` 或类似的指令。

关于这个表的进一步说明：
* "Truncate" 表示截断；"Nop" 意味着没有转换被执行。
* "Start GC tracking" 意味着，在隐式转换后，该项的值将被报告给任何后续的垃圾收集操作，并且可能由于指向的项在堆中被重新定位而改变。

>---
### 对 CIL 代码序列的限制
<a id=""></a>

对 CIL 代码序列的详细限制，以确保:
- 正确的 CIL
- 可验证的 CIL

还有一些进一步的限制，这些限制是为了更容易地构建一个简单的 CIL-to-native-code 的编译器。本小节规定了适用于单个指令的一般限制。

#### 指令流

方法的实现由一块连续的 CIL 指令提供，编码方式如下所述。方法的指令块的地址以及其长度在文件格式中有所指定（参见 第二部分 [_CIL 物理布局_](./02_CLI%20元数据定义和语义.md/#metadata-physical-layout)）。第一条指令位于指令块的第一个字节（最低地址）。

指令的大小是可变的。每条指令的大小可以从指令字节的内容中确定（解码）。指令内部字节的大小和顺序由每个指令定义指定。指令在一个既不需要对齐也不敏感于字节顺序的字节流中连续跟随，没有填充。

每条指令占用确切的字节数，直到指令块的结束，下一条指令立即开始于下一个字节。如果指令块（由块的长度指定）在没有形成完整的最后一条指令的情况下结束，那么就是无效的。

指令前缀扩展了指令的长度，而没有引入新的指令；一个有一个或多个前缀的指令只引入了一个指令，该指令从第一个指令前缀的第一个字节开始。

直到指令块的结束，任何控制转移指令后面的指令都被解码为一条指令，从而参与后续指令的定位，即使它不是分支的目标。只有指令可以出现在指令流中，即使无法到达。没有与地址相关的数据寻址模式，原始数据不能直接嵌入到指令流中。某些指令允许将即时数据作为指令的一部分嵌入，然而这与允许在指令流中直接嵌入原始数据是不同的。无法到达的代码可以作为机器生成的代码的结果出现，并且是允许的，但它必须始终以正确形成指令序列的形式出现。

指令流可以被翻译，相关的指令块在执行翻译之前被丢弃。因此，即使是捕获和操作代码地址的指令，如 `call`，`ret` 等，也可以被虚拟化，以便在翻译的地址上操作，而不是在 CIL 指令流的地址上操作。

#### 有效的分支目标
<a id="valid-branch"></a>

由指令流中识别的每条指令的第一个字节组成的地址集合定义了唯一有效的指令目标。指令目标包括分支指令中指定的分支目标，异常表中指定的目标，如保护范围、过滤器和处理程序目标。

分支指令将分支目标指定为 1 字节或 4 字节的有符号相对偏移量；偏移量的大小由指令的操作码区分。偏移量被定义为相对于分支指令后面的字节。因此，偏移量为零的值目标是紧随其后的指令。1 字节偏移量的值是通过将该字节解释为有符号的 8 位整数来计算的。

4 字节偏移量的值可以通过将字节连接成一个有符号的整数来计算，方式如下：最低地址的字节形成整数的最低有效字节，最高地址的字节形成整数的最高有效字节。这种表示法通常被称为 "小端字节序的有符号整数"。

#### 异常范围

异常表描述了由 `catch`，`fault` 或 `finally` 处理程序保护的指令范围。受保护块，过滤子句或处理程序的起始地址应为 §[[↗]](#valid-branch) 中指定的有效分支目标。如果受保护块，过滤子句或处理程序在没有形成完整的最后一条指令的情况下结束，那么就是无效的。

#### 必须提供 maxstack
<a id="maxstack"></a>

每个方法都指定了可以推送到 CIL 求值堆栈上的元素的最大数量。该值存储在 *`IMAGE_COR_ILMETHOD`* 结构中，该结构位于每个方法的 CIL 主体之前。一个方法如果指定的元素最大数量小于方法的静态分析所需的数量（使用传统的控制流图，不分析数据），那么它就是无效的（因此也是不可验证的），并且不需要由符合 CLI 规范的实现来支持。

***Maxstack*** 与程序的分析相关，而不是与运行时堆栈的大小相关。它并没有指定堆栈帧的最大字节大小，而是指定了分析工具应该跟踪的元素的数量。
 
通过分析任何方法的 CIL 流，很容易确定将有多少元素被推送到 CIL 求值堆栈上。然而，提前指定最大数量有助于 CIL-to-native-code 编译器（特别是只通过 CIL 流进行一次遍历的简单编译器）在分配模拟堆栈和 / 或验证算法的内部数据结构。

#### 后向分支约束

对于任何方法，只要在 CIL 指令流中进行一次前向遍历，就有可能推断出每条指令的求值堆栈的确切状态 (这里的 “状态” 是指求值堆栈上每个元素的数量和类型)。

特别地，如果该单次遍历分析到达一个指令，称为位置 X，它紧随在无条件分支之后，并且 X 不是前向分支指令的目标，那么就无法从现有信息中推断出 X 处的求值堆栈状态。在这种情况下，CLI 要求 X 处的求值堆栈为空。

根据这个规则，如果后向分支指令到 X 处的求值堆栈非空，那么它显然是无效的 CIL。

这个约束确保 CIL 代码可以被一个简单的 CIL-to-native-code 编译器处理。它确保每个 CIL 开始时的求值堆栈状态可以从指令流的单次前向遍历分析中推断出来。

上述位置 X 处的堆栈状态可以通过各种方式推断：从前向分支到 X；因为 X 标记了异常处理程序的开始，等等。

有关进一步信息，请参见以下内容：

 * 异常：§[[↗]](./01_CLI%20基本概念和体系结构.md/#exception-handle)
 * 分支指令的验证条件：§[III.3【】]()
 * `tail.` 前缀：§[III.3.19【】]()

#### 分支验证约束

所有分支指令的目标应为该分支指令所在方法内的有效分支目标（参见 §[[↗]](#valid-branch)）。

>---
### 可验证性和正确性
<a id="Verifiability"></a>

内存安全是一种确保在同一地址空间运行的程序彼此正确隔离的属性。因此，希望在运行程序之前测试程序是否具有内存安全性。但是以 100% 的准确性做到这一点是不可能的。相反，CLI 可以测试一个更强的限制，称为 *可验证性* (_verifiability_)。每个被验证的程序都是内存安全的，但是一些不可验证的程序仍然是内存安全的。

正确的 CIL 是在所有符合 CLI 的实现上执行的 CIL，其行为如本标准所指定的那样具有良好的定义。然而，正确的 CIL 不必在所有符合的实现中产生相同的行为；也就是说，行为可以是特定于实现的。

生成不可验证但已知内存安全的正确 CIL 代码是完全可以接受的，这是由编译器编写者知道的。因此，即使生成的编译器 *知道* 它是内存安全的，正确的 CIL 也可能不可验证。CIL 指令的几个重要用途是不可验证的，例如 `add` 的指针算术版本，这是对 C 程序的忠实和高效编译所必需的。对于不可验证的代码，内存安全性是应用程序员的责任。

正确的 CIL 包含一个 *可验证的子集*。可验证性描述详细说明了指令使用在何种条件下是属于可验证的 CIL 子集。验证比 CLI 的基本功能更详细地跟踪值的类型，因为它检查 CIL 代码序列是否遵守 CLI 关于垃圾收集安全性的基本规则，并且是否还遵守 CTS 的类型规则。这有助于保证整个 CLI 的稳定运行。

每个操作描述的可验证性部分指定了正确生成 CIL 和验证的要求。正确的 CIL 生成始终需要保证堆栈顶部的元素对应于堆栈转换图中显示的类型。可验证性部分只指定了在该图中未捕获的正确 CIL 生成的需求。验证测试正确生成 CIL 的需求和指令中描述的特定验证条件。不满足 CIL 正确性要求的 CIL 序列的操作是未指定的。满足正确性要求但不可验证的 CIL 序列的操作，可能会违反类型安全性，因此也可能会违反安全性或内存访问约束。有关更多信息，请参见第二部分 [_验证和校验_](./02_CLI%20元数据定义和语义.md/#validation-and-verification)。

#### 可验证 CIL 的流控制限制

本小节指定了一个验证算法，该算法结合了关于单个 CIL 指令的信息（参见 §[III.3](【】)）和元数据验证，保证了内存完整性。

这里指定的算法为所有符合 CLI 的实现创建了一个最低级别，意味着任何被这个算法认为是可验证的程序都应被认为是可验证的，并且在所有符合 CLI 的实现上正确运行。

CLI 提供了一个安全权限（参见[Partition IV](【】)），用于控制 CLI 是否可以运行可能违反内存安全性的程序。任何根据这个标准可验证的程序都不会违反内存安全性，符合 CLI 的实现能够运行这样的程序。实现也可能运行其他程序，只要它能够显示它们不违反内存安全性（通常是因为它们使用了一种利用有关实现的特定存储信息的验证算法）。

虽然一个符合的实现需要接受并运行任何这个验证算法认为是可验证的程序，但可能有一些程序被一个给定的实现接受为可验证，但这个验证算法会认为它们不可验证。这样的程序将在给定的实现中运行，但不必被其他实现认为是可验证的。

CLI 的实现者被要求提供一种测试方法，以确定他们的实现生成的程序是否满足这个可移植的可验证性标准。他们也被要求详细说明他们的验证算法在哪些地方比这个标准更宽松。

只有有效的程序才能被验证。为了便于解释，这里描述的验证算法假设程序是有效的，并且并没有明确要求测试所有的有效性条件。有效性条件是在每个 CIL 指令的基础上指定的（参见 §[III.3](【】)）。

##### 验证算法

验证算法将尝试把一个有效的堆栈状态与每个 CIL 指令关联起来。堆栈状态指定了代码中该点上 CIL 堆栈上的槽数量，以及每个槽中应存在的所需类型。初始堆栈状态为空（堆栈上没有元素）。

验证假设 CLI 在对程序可见之前将除了求值堆栈之外的所有内存归零。符合 CLI 规范的实现应提供这种可观测的行为。此外，可验证的方法应设置 `localsinit` 位，参见第二部分的 [_Method Header Flags_](./02_CLI%20元数据定义和语义.md/#method-header)。如果没有设置这个位，那么 CLI 可能在访问局部变量的任何地方抛出一个验证异常，并且包含该方法的程序集没有被授予 _SecurityPermission.SkipVerification_。

这个要求极大增强了程序的可移植性，一个众所周知的技术（明确赋值分析）允许 CIL-to-native-code 编译器将其性能影响降至最低。注意，CLI 可能选择执行明确赋值分析 —— 在这种情况下，它可能确定一个方法即使没有设置 `localsinit` 位，实际上也可能是可验证的（因此不会抛出验证异常）。

CLI 可以使用明确赋值分析来确定哪些位置在读取之前被写入。这样的位置不需要归零，因为不可能观测到由 VES 提供的内存的内容。

在 C++ 实现（不需要明确赋值分析）上的性能测量表明，即使在高度优化的代码中，添加这个要求几乎没有影响。此外，当没有执行归零时，客户错误地将错误归咎于编译器，因为当对程序进行小的、无关的改变时，这样的代码通常会失败。

验证算法将模拟代码中所有可能的控制流路径，并确保每个可达的 CIL 指令存在一个有效的堆栈状态。验证算法在模拟过程中不利用任何数据值（例如，它不执行常量传递），而只使用类型赋值。用于验证的类型系统的详细信息和用于合并堆栈状态的算法在 §[_合并堆栈状态_](#merging-stack-states) 中提供。验证算法以以下方式终止：
 1. 当所有的控制路径均能通过模拟时成功。
 2. 当无法计算特定 CIL 指令的有效堆栈状态时失败。
 3. 当本小节指定的其他测试失败时失败。

除了无条件分支指令，`throw`，`rethrow` 和 `ret`，每个指令都有一条从当前指令到后续指令的控制流路径。每个分支指令（条件或无条件）也有一条到分支目标（或在 `switch` 指令的情况下的多条目标）的控制流路径。

验证模拟每个 CIL 指令的操作来计算新的堆栈状态，任何堆栈状态的指定条件（参见§[III.3](【】)）与模拟的堆栈状态之间的类型不匹配将导致验证算法失败。验证只模拟对堆栈状态的影响：它不执行实际的计算。如果在下一个指令地址（对于条件分支或在 **try** 块内的指令，可能有多个这样的地址）存在一个不能与刚刚计算的堆栈状态合并的现有堆栈状态，那么算法也将失败。对于这个合并操作的规则，参见 §[_合并堆栈状态_](#merging-stack-states)。

CLI 支持 *受控可变性* (_controlled-mutability_) 托管指针的概念（参见 §[*可控易变托管指针*](#controlled-mutability-managed-pointers)，合并规则在 §[_合并堆栈状态_](#merging-stack-states)，`readonly.` 指令前缀在 §[III.2.3](【】)，`ldfld` 指令在 §[III.4.10](【】)，`stfld` 指令在§[III.4.28](【】)，以及 `unbox` 指令在 §[III.4.32](【】)）。

VES 确保特殊约束和类型约束都得到满足。这些约束可以在构造闭类型时提前进行检查，也可以在调用受约束泛型类型的方法、受约束的泛型方法、访问受约束的泛型类型中的字段，或创建受约束的泛型类型的实例时尽可能晚地进行检查。

为了适应泛型，扩展类型兼容关系以处理：

 * 泛型参数：一个泛型参数只能 *可赋值给* 它自己。
 * 装箱的泛型参数：一个装箱的泛型参数可以 *可赋值给* 在泛型参数上声明的约束类型。

在验证语义中，在堆栈上装箱原始值或值类型的值会引入一个类型为 "装箱" 类型的值；如果值类型是 `Nullable<T>`，则引入了类型为 "装箱" `T` 的值。这种装箱类型的概念可以扩展到泛型参数。在堆栈上装箱类型为泛型参数（例如 `!0`）的值会引入了装箱参数类型的值（例如 "装箱"`!0`）。值类型的装箱形式，以及泛型参数的装箱形式，用来支持对装箱值进行有效的实例和虚方法调用。因为 "装箱" 类型在静态上记录了底层值的确切类型，所以不需要在一些信息较少但语法上可表达的引用类型上对实例执行有检查的强制转换。

就像原始和非原始值类型的装箱形式一样，泛型参数的装箱形式只出现在验证堆栈上（在被 `box` 指令引入之后）。它们不能使用元数据签名显式地指定。

##### 验证类型系统

验证算法压缩逻辑上等价的类型，因为它们不会违反内存安全性。验证算法使用的类型在 §[[↗]](#verification-types) 中指定，类型兼容性规则在 §[[↗]](#controlled-mutability-managed-pointers) 中指定，合并堆栈状态的规则在 §[[↗]](#merging-stack-states) 中指定。

> ***验证类型***
<a id="verification-types"></a>

第一部分 §[*赋值兼容性*](./01_CLI%20基本概念和体系结构.md/#assignment-compatibility) 指定了 CLI 和验证中使用的类型的映射。验证将 CLI 类型压缩到一个更小的集合，该集合保持了这些类型在内存中大小的信息，但之后再次压缩这些类型，以表示 CLI 堆栈将 1，2 和 4 字节的内置类型扩展到堆栈上的 4 字节类型的事实。类似地，验证将堆栈上的浮点数视为 64 位量，而不考虑实际的表示。

数组是对象，但具有特殊的兼容性规则。

CLI 有一个特殊的编码用于表示 `null`，它代表一个已知为 `null` 值的对象，其实际类型不确定。一个 `null` 值可能已知具有某种引用类型；例如，当它从局部变量或字段加载时；或者当它是由 `ldnull` 指令产生的具有特殊的 `null` 类型。`null` 类型的 `null` 值只能存在于求值堆栈上。当任何指令的正确性或验证部分需要某种特定引用类型的值时，也可以使用 `null` 类型的值。如果提供了 `null` 类型的值并且指令对其进行了解引用，那么将抛出 `System.NullReferenceException`。

在下表中，"CLI 类型" 是在元数据中描述的类型。在考虑被调用方法的局部变量、参数和参数的类型时，"验证类型" 是用于验证类型兼容性规则的相应类型。验证类型（在堆栈状态中）对应于中间类型，用于模拟将数据加载到堆栈的指令，并显示在验证算法的堆栈状态信息中实际维护的类型。"Managed Pointer to Type" 列显示了为托管指针跟踪的类型。

 | CLI Type                            | Verification Type | Verification Type (in stack state) | Managed Pointer to Type |
 | ----------------------------------- | ----------------- | ---------------------------------- | ----------------------- |
 | `int8`, `unsigned int8`, `bool`     | `int8`            | `int32`                            | `int8&`                 |
 | `int16`, `unsigned int16`, `char`   | `int16`           | `int32`                            | `int16&`                |
 | `int32`, `unsigned int32`           | `int32`           | `int32`                            | `int32&`                |
 | `int64`, `unsigned int64`           | `int64`           | `int64`                            | `int64&`                |
 | `native int`, `native unsigned int` | `native int`      | `native int`                       | `native int&`           |
 | `float32`                           | `float32`         | `float64`                          | `float32&`              |
 | `float64`                           | `float64`         | `float64`                          | `float64&`              |
 | Any value type                      | Same type         | Same type                          | Same type`&`            |
 | Any object type                     | Same type         | Same type                          | Same type`&`            |
 | Method pointer                      | Same type         | Same type                          | Not valid               |

一个方法可以被定义为返回一个托管指针，但是对这样方法的调用是不可验证的。当通过引用返回时，验证是在返回点进行的，而不是在调用点进行的。

返回托管指针的一些用途是完全可验证的（例如，返回一个对象中的字段的引用）；但有些不是（例如，返回被调用方法局部变量的指针）。在一般情况下跟踪它是一个负担，因此没有包含在这个标准中。

> ***可控易变托管指针***
<a id="controlled-mutability-managed-pointers"></a>

`readonly.` 前缀和 `unbox` 指令可以产生所谓的 *可控易变托管指针* (_controlled-mutability 
managed pointer_)。与普通的托管指针类型不同，可控易变托管指针不能作为 *验证可赋值给*（§[[↗]](#Verification-type-compatibility)）普通的托管指针；例如，它不能作为一个 **byref** 参数传递给一个方法。在控制流点，可控易变托管指针可以与相同类型的托管指针合并，以产生可控易变托管指针。

可控易变托管指针只能以以下方式使用：

 1. 作为 `ldfld`，`ldflda`，`stfld`，`call`，`callvirt` 或 `constrained. callvirt` 指令的对象参数。
 2. 作为 `ldind.*` 或 `ldobj` 指令的指针参数。
 3. 作为 `cpobj` 指令的源参数。

所有其他操作（包括 `stobj`，`stind.*`，`initobj` 和 `mkrefany`）都是无效的。

这个指针之所以被称为可控易变托管指针，是因为定义类型决定了值是否可以被改变。对于没有公开任何公共字段或就地更新值的方法的值类，指针是只读的（因此得名前缀）。特别地，表示原始类型（如 `System.Int32`）的类不公开设值方法，因此是只读的。

> ***验证类型兼容性***
<a id="Verification-type-compatibility"></a>

验证类型兼容性是根据赋值兼容性定义的（参见 §[*赋值兼容性*](./01_CLI%20基本概念和体系结构.md/#assignment-compatibility)）。

如果当且仅当 `T` 是 `Q` 的验证类型，`U` 是 `R` 的验证类型，并且满足以下至少一项条件时，类型 `Q` 是 *验证可赋值给* (_verifier-assignable-to_) `R`（有时写作 `R` := `Q`）：

 1. `T` 与 `U` 相同。这是验证类型兼容性的自反性。
 2. 存在某个 `V`，使得 `T` 是 *验证可赋值给* `V`，并且 `V` 是 *验证可赋值给* `U`。这是验证类型兼容性的传递性。
 3. 根据 §[_一般赋值兼容性_](./01_CLI%20基本概念和体系结构.md/#general-assignment-compatibility) 中的规则，`T` 是 *可赋值给* `U`。
 4. `T` 是类型 `V` 的可控易变托管指针类型，`U` 是类型 `W` 的可控易变托管指针类型，`V` 是 *指针元素可赋值给* `W`。
 5. `T` 是托管指针类型 `V&`，`U` 是类型 `W` 的可控易变托管指针类型，`V` 是 *指针元素可赋值给* `W`。
 6. `T` 是装箱的 `V`，`U` 是 `V` 的直接基类。
 7. `T` 是装箱的 `V`，`U` 是 `V` 直接实现的接口。
 8. `T` 是装箱的 `X`，对于泛型参数 `X`，`V` 是在参数 `X` 上声明的泛型约束。
 9. `T` 是 `null` 类型，`U` 是引用类型。

*验证可赋值* 给扩展了 *可赋值给*，以处理只能在堆栈上出现的类型，即装箱类型、可控易变托管指针类型和 `null` 类型。

在第三部分的其余部分，有时使用符号 "`U` := `T`" 表示 `T` 是 *验证可赋值给* `U`。

##### 合并堆栈状态
<a id="merging-stack-states"></a>

当验证算法模拟所有控制流路径时，它应将模拟的堆栈状态与流中下一个 CIL 指令的任何现有堆栈状态合并。如果没有现有的堆栈状态，模拟的堆栈状态将被存储以供将来使用。否则，合并应按照以下方式计算，并存储以替换 CIL 指令的现有堆栈状态。如果合并失败，验证算法将失败。

合并应通过比较每个堆栈状态中的插槽数量来计算。如果它们不同，合并将失败。如果它们匹配，那么整体合并应通过按以下方式逐插槽合并状态来计算。设 `T` 是新计算状态的插槽上的类型，`S` 是先前存储状态的相应插槽上的类型。合并的类型 `U`，应按照以下方式计算（`S` := `T` 是在 §[_可控易变托管指针_](#controlled-mutability-managed-pointers) 中定义的兼容性函数）：

 1. 如果 `S` := `T`，那么 `U` = `S`
 2. 否则，如果 `T` := `S`，那么 `U` = `T`
 3. 否则，如果 `S` 和 `T` 都是对象类型，那么让 `V` 是 `S` 和 `T` 的最近公共超类型，那么 `U` = `V`。
 4. 否则，合并应失败。

将可控易变托管指针与同一类型的普通（即非可控易变）托管指针合并，结果是该类型的可控易变托管指针。

##### 类和对象初始化规则

VES 确保所有静态变量初始化为全零位（即，内置类型为 0 或 `false`，对象引用为 `null`），因此验证算法不测试静态变量的明确分配。

除非在新构造的对象上调用了对象基类的构造函数或对象类的不同构造函数，否则对象构造函数不应返回。除非已经调用了基类构造函数，否则验证算法应将 **this** 指针视为未初始化。除了存储和加载对象的字段外，不能对未初始化的 **this** 执行任何操作。

如果构造函数产生异常，则对应 **catch** 块中的 **this** 指针仍未初始化。

##### 委托构造

委托构造的验证是基于代码序列而不是单个指令。这些信息在 `newobj` 指令的描述（§[III.4.21](【】)）中有详细说明。

如果分支目标在这些指令序列中（除了在序列的开始处），则验证算法应失败。

参见第二部分的 [_委托签名_](./02_CLI%20元数据定义和语义.md/#delegate-signature)，了解委托的签名以及关于在构造函数中使用的方法的签名以及委托类上的 `Invoke` 和其他方法的签名的有效性要求。

>---
### 元数据 Token

许多 CIL 指令后面都跟着一个 "元数据 *Token*"。这是一个 4 字节的值，它指定了元数据表中的一行，或者 ***UserString Heap*** 中的起始字节偏移量。*token* 的最高有效字节指定了表或堆。例如，值 0x02 指定了 **`TypeDef`** 表；值 0x70 指定了 ***UserString Heap***。该值对应于分配给该元数据表的编号或者对应于 ***UserString Heap*** 的 0x70。最低有效的 3 字节指定了元数据表中的目标行，或者 ***UserString Heap*** 中的起始字节偏移量。元数据表中的行是从 1 开始编号的，而堆中的偏移量是从 0 开始编号的。例如，元数据 _token_ 的值 0x02000007 指定了 **`TypeDef`** 表中的行号 7）

>---
### 异常抛出

一个 CIL 指令可以抛出一系列的异常。CLI 也可以抛出一个称为 `ExecutionEngineException` 的通用异常。

---
## 指令前缀

这些特殊的值被保留用在特定的指令之前，它们本身并不构成完整的指令。分支到在前缀后面的指令是无效的 CIL，但是前缀本身是一个有效的分支目标。如果一个前缀后面没有紧跟它允许的指令，那么它不是有效的 CIL。

>---
### constrained. ：在变量类型的值上调用成员

 | Format        | Assembly Format           | Description                           |
 | :------------ | :------------------------ | :------------------------------------ |
 | FE 16 _\<T\>_ | `constrained.` _thisType_ | 在被约束为类型 `T` 的类型上调用虚方法 |

> *堆栈转换*：

&hellip;, _ptr_, _arg1_, … _argN_ &rarr; &hellip;, _ptr_, _arg1_, … _argN_

> *描述*：

`constrained.` 前缀只允许在 `callvirt` 指令上。*ptr* 的类型必须是 _thisType_ 的托管指针（`&`）。`constrained.` 前缀的设计是为了允许以统一方式进行 `callvirt` 指令，而不考虑 _thisType_ 是值类型还是引用类型。

当 `callvirt` 方法指令被 `constrained.` _thisType_ 前缀修饰时，指令按以下方式执行：
- 如果 _thisType_ 是引用类型（而不是值类型），那么 _ptr_ 被解引用并作为 **this** 指针传递给 `callvirt` 的方法。
- 如果 _thisType_ 是值类型并且 _thisType_ 实现了 _method_，那么不修改 _ptr_ 并作为 **this** 指针传递给 _thisType_ 实现的 _method_ 的调用。
- 如果 _thisType_ 是值类型并且 _thisType_ 没有实现 _method_，那么 _ptr_ 被解引用、装箱，并作为 **this** 指针传递给 `callvirt` 的方法

这最后一种情况只能在 _method_ 被定义在 `System.Object`、`System.ValueType` 或 `System.Enum` 上，并且没有被 _thisType_ 重写时发生。在这最后一种情况下，装箱导致原始对象的副本被创建，然而由于所有在 `System.Object`、`System.ValueType` 和 `System.Enum` 上的方法都不修改对象的状态，因此实际上不会被检测到。

> *正确性*：

`constrained.` 前缀后紧随 `callvirt` 指令。_thisType_ 应该是一个有效的 `typedef`，`typeref`，或 `typespec` 元数据 *Token*。

> *可验证性*：

_ptr_ 参数是一个托管指针（`&`）到 _thisType_。此外，在上述 _ptr_ 转换之后，`callvirt` 指令的所有正常验证规则都适用。这相当于要求一个装箱的 _thisType_ 必须是方法所属类的子类。

这个指令的目标是实现虚函数调用的一致性，因此这样的调用可以在泛型例程中进行验证。实现这种一致性的一种方式是在进行 `callvirt` 之前总是对 **this** 指针进行装箱。这对于引用类型（其中 `box` 是无操作）和值类型都是有效的。这种方法的问题在于，在值类型的情况下会产生一个副本。因此，如果被调用的方法修改了值类型的状态，那么在调用完成后这种修改将不会反映出来，因为这种修改是在装箱的副本中进行的。这种语义差异（以及额外装箱的性能成本），使得这种替代方案无法接受。

>---
### no. ：可能跳过错误检查

 | Format                    | Assembly Format                                        | Description                                                       |
 | :------------------------ | :----------------------------------------------------- | :---------------------------------------------------------------- |
 | FE 19 _\<unsigned int8\>_ | `no.` \{ `typecheck` \| `rangecheck` \| `nullcheck` \} | 在执行后续指令的过程中，通常执行的指定错误检查可以 / 应该被跳过。 |

> *描述*：

`no.` 前缀表示在执行后续指令时不需要执行指定的错误检查。跟在指令代码后面的字节指示哪些检查可以选择性地被跳过。这个指令是不可验证的。

`no.` 前缀可以在以下情况下使用：
 * 0x01: `typecheck` (`castclass`, `unbox`, `ldelema`, `stelem`, `stelem`)。CLI 可以在执行后续指令的过程中，选择性地跳过通常执行的任何类型检查。如果检查失败，可以选择性地抛出 `InvalidCastException`。
 * 0x02: `rangecheck` (`ldelem.*`, `ldelema`, `stelem.*`)。CLI 可以在执行后续指令的过程中，选择性地跳过通常执行的任何数组范围检查。如果检查失败，可以选择性地抛出 `IndexOutOfRangeException`。
 * 0x04: `nullcheck` (`ldfld`, `stfld`, `callvirt`, `ldvirtftn`, `ldelem.*`, `stelem.*`, `ldelema`)。CLI 可以在执行后续指令的过程中，选择性地跳过通常执行的任何空引用检查。如果检查失败，可以选择性地抛出 `NullReferenceException`。

字节值可以按或组合；例如，值 0x05 表示 `typecheck` 和 `nullcheck` 都可以选择性地被忽略。

> *正确性*:

正确的 CIL 只允许在上面指定的指令上使用前缀 `no.`。

> *可验证性*：

可验证的 CIL 不允许使用前缀 `no.`。

>---
### readonly. ：后续指令返回可控易变托管指针

 | Format | Assembly Format | Description                                                                |
 | :----- | :-------------- | :------------------------------------------------------------------------- |
 | FE 1E  | `readonly.`     | 指定后续数组地址操作在运行时不执行类型检查，并且它返回一个可控易变托管指针 |

> *描述*：

`readonly.` 前缀只能出现在 `ldelema` 指令或调用数组上的特殊 *Address* 方法之前。它对后续操作的影响有两方面：
 1. 在运行时，不执行类型检查操作。对于值类的情况，从不在运行时检查，所以这是一个 *noop* 无操作。
 2. 验证器将地址操作的结果视为可控易变托管指针 §[[↗]](#controlled-mutability-managed-pointers)。

> *可验证性*：

可控易变托管指针必须遵守在 §[[↗]](#controlled-mutability-managed-pointers) 的 (2.) 中给出的验证规则。另请参见 §[_合并堆栈状态_](#merging-stack-states)。

`readonly.`前缀的主要目标是在泛型代码中从数组中获取元素时避免类型检查。例如，表达式 `array[i].method()`，其中 `array` 的类型为 `T[]`（其中 `T` 是一个泛型参数），并且 `T` 被约束为具有方法 `method` 的接口，可能会编译成以下 IL 代码。

```csharp
interface ISample { void method(); }
class Sample<T> where T: ISample
{
    public void Fun(T[] arr, int j) => arr[j].method();
}
```
```cil
ldloc array
ldloc j          // j is array index
readonly.
ldelema !0       // loads the pointer to the object
…                // load the arguments to the call
constrained. !0
callvirt method
```

如果没有 `readonly.` 前缀，`ldelema` 在 `!0` 是引用类的情况下会进行类型检查。这种类型检查不仅效率低下，而且在语义上是不正确的。`ldelema` 的类型检查执行精确匹配的强类型检查。如果数组中包含了 `!0` 的派生类，那么上面的代码将无法通过 `ldelema` 类型检查。我们获取数组元素的地址而不是元素本身（这是源代码所说的）的唯一原因，是因为我们需要一个对 `array[i]` 的句柄，这个句柄对于值类型和引用类型都可以传递给受约束 (`constrained.`) 的 `callvirt` 指令。

如果数组包含引用类型的元素，一般来说，跳过运行时检查是不安全的。为了安全，我们必须确保不能通过这个指针修改数组。上述的验证规则确保了这一点。由于我们显式允许只读指针作为实例方法调用的对象传递，这些指针对于值类型并不严格地只读，但是对于值类型来说没有类型安全问题。

### tail. ：调用终止当前方法

 | Format | Assembly Format | Description          |
 | :----- | :-------------- | :------------------- |
 | FE 14  | `tail.`         | 后续调用终止当前方法 |

> *描述*：

`tail.` 前缀后应紧随 `call`，`calli` 或 `callvirt` 指令。它表示当前方法的堆栈帧不再需要，因此可以在执行调用指令之前将其移除。因为调用返回的值将是此方法返回的值，所以调用可以转换为跨方法跳转。

求值堆栈应为空，除了由后续调用传递的参数。调用指令后面的指令应该是 `ret`。因此，唯一有效的代码序列是

```cil
 tail. call *somewhere*   // or `calli` or `callvirt`
 ret
```

正确的 CIL 不应分支到 `call` 指令，但是允许分支到 `ret`。堆栈上的唯一值应该是被调用方法的参数。

`tail. call`（或 `calli` 或 `callvirt`）指令不能在 **try**，**filter**，**catch** 或 **finally** 块中用于转移控制。

当从不受信任的代码转移到受信任的代码时，不能丢弃当前帧，因为这将危及代码标识安全性。因此，安全检查可能会导致忽略 `tail.`，并留下一个标准的调用指令。

同样，为了允许在调用返回后退出同步区域，当用于退出标记为同步 (**synchronized**) 的方法时，将忽略 `tail.` 前缀。

还可能存在一些特定实现的限制，防止在某些情况下遵守 `tail.` 前缀。虽然实现可以在这些情况下自由地忽略 `tail.` 前缀，但是它们应该被清楚地记录下来，因为它们可能会影响程序的行为。

CLI 实现需要尊重 `tail. call` 请求，其中调用方和被调用方的方法可以静态地确定为位于同一程序集中；并且调用方不在同步区域内；并且调用方和被调用方满足下面的 "可验证性" 规则中列出的所有条件。（"尊重" `tail.` 前缀意味着移除调用方的帧，而不是恢复到常规的调用序列）。因此，CLI 实现不需要尊重 `tail. calli` 或 `tail. callvirt` 序列。

`tail.` 调用允许将一些线性空间算法转换为常量空间算法，并且是某些语言所要求的。在存在 `ldloca` 和 `ldarga` 指令的情况下，从 CIL-to-native-code 的编译器并不总是能够最优地确定何时可以自动插入 `tail.`。

> *正确性*：

正确的 CIL 遵守上述的控制转移约束。此外，如果它们指向即将被移除的堆栈帧，那么不能将托管指针传递给被调用的方法。被调用方法的返回类型应该是 *可赋值给* 当前方法的返回类型。

> *可验证性*：

验证要求不应将托管指针传递给被调用的方法，因为它不跟踪进入当前帧的指针。

### unaligned. (prefix) &ndash; 指针指令可能不对齐

 | Format                    | Assembly Format          | Description            |
 | :------------------------ | :----------------------- | :--------------------- |
 | FE 12 _\<unsigned int8\>_ | `unaligned.` *alignment* | 后续指针指令可能不对齐 |
 
> *堆栈转换*：

&hellip;, *addr* &rarr; &hellip;, *addr*

> *描述*：

`unaligned.` 前缀指定堆栈上的 *addr*（一个非托管指针（`&`）或 `native int`）可能不对齐到紧随其后的 `ldind`，`stind`，`ldfld`，`stfld`，`ldobj`，`stobj`，`initblk` 或 `cpblk` 指令的自然大小。也就是说，对于 `ldind.i4` 指令，*addr* 的对齐可能不是到 4 字节边界。对于 `initblk` 和 `cpblk`，默认对齐是依赖于架构的（32 位 CPU 上是 4 字节，64 位 CPU 上是 8 字节）。不将其输出限制为 32 位字长的代码生成器如果在编译时不能确定对齐是否为 8 字节时使用 `unaligned.`。

*alignment* 的值应为 1，2 或 4，表示生成的代码应假定 *addr* 分别对齐到字节，双字节或四字节。

虽然 `cpblk` 指令的对齐逻辑上需要两个数字（一个用于源，一个用于目标），但是若只指定较低的数字，则对性能的影响并不明显。

`unaligned.` 和 `volatile.` 前缀可以以任何顺序组合，并在后面紧随 `ldind`，`stind`，`ldfld`，`stfld`，`ldobj`，`stobj`，`initblk` 或 `cpblk`指令。

> *正确性和可验证性*：

`unaligned.` 前缀后面应立即紧随上述的指令之一。

### volatile. ：指针引用是易变的

 | Format | Assembly Format | Description          |
 | :----- | :-------------- | :------------------- |
 | FE 13  | `volatile.`     | 后续指针引用是易变的 |

> *堆栈转换*：

&hellip;, *addr* &rarr; &hellip;, *addr*

> *描述*：

`volatile.` 前缀指定 *addr* 是一个易变地址（即，它可以被当前执行线程外部引用），并且不能缓存读取该位置的结果，或者不能抑制对该位置的多次存储。对标记为 `volatile.` 位置的访问只影响该单次访问；对同一位置的其他访问应分别标记。不需要原子地访问易变位置。

`unaligned.` 和 `volatile.` 前缀可以以任何顺序组合，并在后面紧随 `ldind`，`stind`，`ldfld`，`stfld`，`ldobj`，`stobj`，`initblk` 或 `cpblk`指令。只有 `volatile.` 前缀允许与 `ldsfld` 和 `stsfld` 指令一起使用。

> *正确性和可验证性*：

`volatile.` 前缀后面应立即紧随上述的指令之一。

---
## 基本指令

这些指令形成了一套 "***Turing*** ***Complete***" 的基本操作。它们独立于可能使用的对象模型。与 CTS 的对象模型具体相关的操作包含在对象模型指令部分。

>---
### add ：添加数值

 | Format | Assembly Format | Description              |
 | :----- | :-------------- | :----------------------- |
 | 58     | `add`           | 添加两个值，返回一个新值 |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;, _result_

> *描述*：

`add` 指令将 _value2_ 添加到 _value1_ 并将结果推入堆栈。对于整数操作，不检测溢出（但请参见 `add.ovf`）；浮点溢出返回 `+inf` 或 `-inf`。

可接受的操作数类型及其相应的结果数据类型包含在 [*二元数值操作*](#OpTable2) 中。

### add.ovf.\<signed\> ：添加整数值并检查溢出

 | Format | Assembly Format | Description                      |
 | :----- | :-------------- | :------------------------------- |
 | D6     | `add.ovf`       | 添加带有溢出检查的有符号整数值。 |
 | D7     | `add.ovf.un`    | 添加带有溢出检查的无符号整数值。 |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;, _result_

> *描述*：

`add.ovf` 指令将 _value1_ 和 _value2_ 相加并将结果推入堆栈。可接受的操作数类型及其相应的结果数据类型包含在 [*溢出算术运算*](#OpTable7) 中。

> *异常*：

如果结果不能用结果类型表示，则抛出 `System.OverflowException`。

### and ：按位与

 | Format | Assembly Format | Description                          |
 | :----- | :-------------- | :----------------------------------- |
 | 5F     | `and`           | 两个整数值的按位与，返回一个整数值。 |
 
> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;, _result_

> 描述：

`and` 指令计算 _value1_ 和 _value2_ 的按位与，并将结果推入堆栈。可接受的操作数类型及其相应的结果数据类型包含在 [*整数操作*](#OpTable5) 中。

### arglist ：获取参数列表

 | Format | Assembly Format | Description                  |
 | :----- | :-------------- | :--------------------------- |
 | FE 00  | `arglist`       | 返回当前方法的参数列表句柄。 |

> *堆栈转换*：

&hellip; &rarr; &hellip;, _argListHandle_

> *描述*：

`arglist` 指令返回一个不透明句柄 (类型为 `System.RuntimeArgumentHandle`)，代表当前方法的参数列表。这个句柄只在当前方法的生命周期内有效。但是只要当前方法在控制线程上，该句柄就可以传递给其他方法。`arglist` 指令只能在接受可变数量参数的方法中执行。

这个指令是用来实现 C 语言的 `va_*` 宏的，这些宏用来实现像 “`printf`” 方法的程序。它旨在与 `System.ArgIterator` 的类库实现一起使用。

> *正确性*：

除非在方法签名中表明它接受可变数量的参数，否则在其方法体中发出此指令是不正确的 CIL 生成。

> *可验证性*：

在其签名表明接受可变数量参数的方法主体中，该指令的使用是可验证的，但验证要求结果是 `System.RuntimeArgumentHandle` 类的实例。

>---
### beq.\<length\> - 相等分支

 | Format         | Assembly Format  | Description                    |
 | :------------- | :--------------- | :----------------------------- |
 | 3B _\<int32\>_ | `beq` _target_   | 如果等于则跳转到目标。         |
 | 2E _\<int8\>_  | `beq.s` _target_ | 如果等于则跳转到目标，短格式。 |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;

> *描述*：

如果 _value1_ 等于 _value2_，`beq` 指令将控制权转移到目标。效果等同于执行 `ceq` 指令后跟 `brtrue` 目标。_target_ 表示为从当前指令后的指令开始的有符号偏移（`beq` 为 4 字节，`beq.s` 为 1 字节）。

可接受的操作数类型包含在 [*二元比较或分支操作*](#OpTable4) 中。

如果目标指令有一个或多个前缀代码，控制只能转移到这些前缀中的第一个。

此指令不能执行进入和退出 **try**，**catch**，**filter** 和 **finally** 块的控制转移。这种转移受到严格限制，应使用 `leave` 指令代替。

> *正确性*：

正确的 CIL 应遵守上述所有控制转移规则，并保证堆栈顶部的两个元素对应于 [*二元比较或分支操作*](#OpTable4) 中显示的类型。

> *可验证性*：

可验证代码要求每个到达目标指令的可能路径的堆栈、局部变量和参数的类型一致性。

>---
### bge.\<length\> ：大于或等于分支

 | Format         | Assembly Format  | Description                          |
 | :------------- | :--------------- | :----------------------------------- |
 | 3C _\<int32\>_ | `bge` _target_   | 如果大于或等于则跳转到目标。         |
 | 2F _\<int8\>_  | `bge.s` _target_ | 如果大于或等于则跳转到目标，短格式。 |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;

> *描述*：

如果 _value1_ 大于或等于 _value2_，`bge` 指令将控制权转移到目标。效果等同于执行 `clt.un` 指令后跟 `brfalse` 目标。_target_ 表示为从当前指令后的指令开始的有符号偏移（`bge` 为 4 字节，`bge.s` 为 1 字节）。

`bge` _target_ 指令的效果等同于：
 * 如果堆栈操作数是整数，则执行 `clt` 后跟 `brfalse` 目标
 * 如果堆栈操作数是浮点数，则执行 `clt.un` 后跟 `brfalse` 目标

可接受的操作数类型包含在 [*二元比较或分支操作*](#OpTable4) 中。

如果目标指令有一个或多个前缀代码，控制只能转移到这些前缀中的第一个。

此指令不能执行进入和退出 **try**，**catch**，**filter** 和 **finally** 块的控制转移。这种转移受到严格限制，应使用 `leave` 指令代替。

> *正确性*：

正确的 CIL 应遵守上述所有控制转移规则，并保证堆栈顶部的两个元素对应于 [*二元比较或分支操作*](#OpTable4) 中显示的类型。

> *可验证性*：

可验证代码要求每个到达目标指令的可能路径的堆栈、局部变量和参数的类型一致性。

>---




---

> *堆栈转换*：

> *描述*：

> *异常*：

> *正确性*：

> *可验证性*：


> *堆栈转换*：

> *描述*：

> *异常*：

> *正确性*：

> *可验证性*：




## end
----


接下来你会翻译我说的每句英文为中文
