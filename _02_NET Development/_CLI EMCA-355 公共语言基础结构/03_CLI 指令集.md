# CLI：指令集

---

## III.1 引言

本部分详细描述了 Common Intermediate Language (CIL) 指令集，这是 CLI 规范的一部分。[Partition I]() 描述了 CLI 的架构，并提供了关于 CIL 指令集的大量问题的概述。这个概述对于理解这里描述的指令集是必要的。

在本部分中，每个指令都在其自己的子条款中描述，每页一个。相关的 CLI 机器指令一起描述。每个指令描述包括以下部分：

 * 一个描述二进制格式、汇编语言表示法和每个指令变体的描述的表格。参见 §[III.1.2](iii.1.2-instruction-variant-table.md)。

 * 一个堆栈转换图，描述了指令执行前后的评估堆栈状态。（参见 §[III.1.3](iii.1.3-stack-transition-diagram.md)。）

 * 指令的英文描述。参见 §[III.1.4](iii.1.4-english-description.md)。

 * 可能由指令抛出的异常的列表。（参见 [Partition I]() 以获取详细信息。）有三个异常可以由任何指令抛出，并且*不*在指令中列出：

   * `System.ExecutionEngineException`：表示执行引擎的内部状态已损坏，无法继续执行。在只执行可验证代码的系统中，不会抛出此异常。

   * `System.StackOverflowException`：表示已超过硬件堆栈大小。此异常的精确时间和发生的条件是实现特定的。_[注意：_此异常与 §[III.1.7.4](iii.1.7.4-must-provide-maxstack.md) 中描述的最大堆栈大小无关。该大小与 [Partition I]() 中描述的方法状态的一部分的评估堆栈的深度有关，而此异常与在物理硬件上实现该方法状态有关。_]_

   * `System.OutOfMemoryException`：表示可用的内存空间已耗尽，要么是因为指令本质上分配内存（`newobj`，`newarr`），要么是出于实现特定的原因（例如，基于 JIT 编译到本机代码的实现可以在执行给定方法的第一个 call 或 callvirt 时耗尽存储转换方法的空间）。

 * 描述与指令相关的可验证性条件的部分。参见 §[III.1.8](iii.1.8-verifiability-and-correctness.md)。

此外，具有数值操作数的操作还指定一个操作数类型表，描述它们如何基于操作数的类型进行操作。参见 §[III.1.5](iii.1.5-operand-type-table.md)。

请注意，并非所有指令都包含在所有 CLI 配置文件中。参见 [Partition IV]() 以获取详细信息。

## III.1.1 数据类型

虽然CTS定义了一个丰富的类型系统，CLS指定了一个可以用于语言互操作性的子集，但CLI本身处理的是一组更简单的类型。这些类型包括用户定义的值类型和内置类型的一个子集。这个子集被统称为"基本CLI类型"，包含以下类型：

 * 完整数值类型的一个子集（`int32`，`int64`，`native int`和`F`）。

 * 对象引用（`O`），不区分引用的对象类型。

 * 指针类型（`native unsigned int`和`&`），不区分指向的类型。

注意，对象引用和指针类型可以被赋值为`null`。在CLI中，这被定义为零（所有位都为零的位模式）。

_[注意：_就VES在求值堆栈上的操作而言，只有一种浮点类型，VES并不关心其大小。VES只在将这些值存储到堆、静态变量、局部变量或方法参数，或从中读取时，才对数值的大小进行区分。_结束说明]_

## III.1.1.1 数值数据类型

 * CLI只操作数值类型`int32`（4字节有符号整数），`int64`（8字节有符号整数），`native int`（本地大小整数）和`F`（本地大小浮点数）。然而，CIL指令集允许实现额外的数据类型：

 * **短整数：**求值栈只保存4字节或8字节整数，但其他位置（参数，局部变量，静态变量，数组元素，字段）可以保存1字节或2字节整数。对于栈操作，bool（§[III.1.1.2](iii.1.1.2-boolean-data-type.md)）和char类型被视为分别为1字节和2字节的无符号整数。从这些位置加载到栈上将它们转换为4字节值：

   * 对于类型`unsigned int8`，`unsigned int16`，`bool`和`char`进行零扩展；

   * 对于类型`int8`和`int16`进行符号扩展；

   * 对于无符号间接和元素加载（`ldind.u*`，`ldelem.u*`等）进行零扩展；和

   * 对于有符号的间接和元素加载（`ldind.i*`，`ldelem.i*`等）进行符号扩展。

   存储到整数，布尔值和字符（`stloc`，`stfld`，`stind.i1`，`stelem.i2`等）截断。使用`conv.ovf.*`指令检测当此截断导致的值不正确地表示原始值。

   _[注意：_短（即1字节和2字节）整数在所有架构上都作为4字节数字加载，这些4字节数字始终被跟踪为与8字节数字不同。这有助于代码的可移植性，确保默认的算术行为（即，当没有执行`conv`或`conv.ovf`指令时）在所有实现上都会得到相同的结果。_结束说明]_

   产生短整数值的转换指令实际上在栈上留下一个`int32`（32位）值，但保证只有低位有意义（即，对于无符号转换，更高位都是零，对于有符号转换，是符号扩展）。为了正确模拟短整数操作的完整集合，需要在`div`，`rem`，`shr`，比较和条件分支指令之前进行短整数转换。

   除了显式转换指令外，CLI在四种情况下以特殊方式处理短整数：

      1. 分配给局部变量（`stloc`）或参数（`starg`）的值，其类型被声明为短整数类型，会自动截断到为局部变量或参数指定的大小。

      2. 从局部变量（`ldloc`）或参数（`ldarg`）加载，其类型被声明为短有符号整数类型，会自动符号扩展

      3. 调用一个参数是短整数类型的过程等同于分配给参数值，所以它截断。

      4. 从返回类型为短整数的方法返回值被建模为在被调用的过程中存储到短整数（即，CLI自动截断），然后在调用过程中从短整数加载（即，CLI自动零或符号扩展）。

   在最后两种情况下，由本地调用约定决定是否实际截断或扩展值，以及这是否在被调用的过程或调用过程中完成。CIL指令序列不受影响，就像CIL序列包含了适当的`conv`指令。

 * **4字节整数：**实际存储在栈上的最短值是4字节整数。这些可以使用`conv.*`指令转换为8字节整数或本地大小整数。本地大小整数可以转换为4字节整数，但这样做在架构之间不可移植。如果应忽略多余的有效位，则可以使用`conv.i4`和`conv.u4`进行此转换；`conv.ovf.i4`和`conv.ovf.u4`指令可以用来检测信息的丢失。算术运算允许4字节整数被协

## III.1.1.2 布尔数据类型

CLI的布尔类型在内存中占用1字节。全零的位模式表示假值。任何一个或多个位设置的位模式（类似于非零整数）表示真值。为了堆栈操作的目的，布尔值被视为无符号的1字节整数（§[III.1.1.1](iii.1.1.1-numeric-data-types.md)）。

## III.1.1.3 字符数据类型

CLI的char类型在内存中占用2字节，并使用UTF-16编码表示一个Unicode代码单元。为了堆栈操作的目的，char值被视为无符号的2字节整数（§[III.1.1.1](iii.1.1.1-numeric-data-types.md)）。

## III.1.1.4 对象引用

对象引用（类型`O`）是完全不透明的。没有允许对象引用作为操作数的算术指令，允许的唯一比较操作是两个对象引用之间的等式和不等式。对象引用上没有定义转换操作。对象引用由某些CIL对象指令（特别是`newobj`和`newarr`）创建。对象引用可以作为参数传递，存储为局部变量，作为值返回，并存储在数组和对象的字段中。

## III.1.1.5 运行时指针类型

有两种指针：非托管指针和托管指针。对于指向同一数组或对象的指针（参见[Partition I]()），定义了以下算术运算：

 * 将整数加到指针上，其中整数被解释为字节数，结果是相同类型的指针。

 * 从指针中减去一个整数（字节数）得到的是相同类型的指针。（注意，不允许从整数中减去一个指针。）

 * 两个指针，无论类型如何，可以相互减去，产生一个有符号整数，指定它们引用的地址之间的字节数。

这些操作在可验证的代码中都是不允许的。

理解在不同类型的指针上使用算术运算对垃圾收集器的影响是很重要的。由于非托管指针永远不会引用由垃圾收集器控制的内存，因此在它们上执行算术运算可能会危及系统的内存安全性（因此它不是可验证的），但由于它们没有报告给垃圾收集器，所以对其操作没有影响。

然而，托管指针被报告给垃圾收集器。作为垃圾收集的一部分，它们指向的位置的内容*和*指针本身都可以被修改。如果托管指针指向不受其控制的内存（评估栈，调用栈，静态内存，或受其他分配器控制的内存），垃圾收集器将忽略托管指针。然而，如果一个托管指针引用了由垃圾收集器控制的内存，它*必须*指向对象的一个字段，数组的一个元素，或者刚好在数组末尾的元素的地址。如果使用地址算术创建一个引用任何其他位置（对象头或分配的内存中的间隙）的托管指针，垃圾收集器的行为是未指定的。

## III.1.1.5.1 未管理的指针

未管理的指针是像C和C++这样的语言中使用的传统指针。它们的使用没有限制，尽管在大多数情况下，它们会产生无法验证的代码。虽然将包含未管理指针的位置标记为无符号整数（实际上，这就是CLI如何处理它们的方式）是完全有效的，但通常更好的做法是将它们标记为指向特定数据类型的未管理指针。这是通过在返回值、局部变量或参数的签名中使用`ELEMENT_TYPE_PTR`，或者在字段或数组元素中使用指针类型来完成的。

未管理的指针不会被报告给垃圾收集器，并且可以以任何整数可以使用的方式使用。

 * 未管理的指针应被视为无符号（即，使用`conv.ovf.u`而不是`conv.ovf.i`等）。

 * 可验证的代码不能使用未管理的指针来引用内存。

 * 未验证的代码可以将未管理的指针传递给期望管理指针的方法。只有在以下情况之一为真时，这才是安全的：

     1. 未管理的指针引用的内存不在垃圾收集器管理的内存中。

     2. 未管理的指针引用对象内的字段。

     3. 未管理的指针引用数组内的元素。

     4. 未管理的指针引用的位置是数组中最后一个元素后面的元素所在的位置。

### III.1.1.5.2 Managed pointers (type &)

在 CLI 中，管理指针（`&`）可以指向局部变量、方法参数、对象的字段、值类型的字段、数组的元素、静态字段，或者存储数组末尾元素之后的元素的地址（用于指向管理数组的指针索引）。管理指针不能为 `null`。（即使它们不指向管理内存，也应该报告给垃圾收集器）

通过在返回值、局部变量或参数的签名中使用 `ELEMENT_TYPE_BYREF`，或者通过对字段或数组元素使用 byref 类型来指定管理指针。

 * 管理指针可以作为参数传递并存储在局部变量中。

 * 如果你通过引用传递一个参数，相应的参数就是一个管理指针。

 * 管理指针不能存储在静态变量、数组元素或对象或值类型的字段中。

 * 管理指针**不**可以与对象引用互换。

 * 管理指针不能指向另一个管理指针，但它可以指向对象引用或值类型。

 * 不指向管理内存的管理指针可以被转换（使用 `conv.u` 或 `conv.ovf`.u）为非管理指针，但这不是可验证的。

 * 错误地将管理指针转换为非管理指针的未验证代码可能严重损害 CLI 的完整性。如果已知以下任何一项为真，则此转换是安全的：

     1. 管理指针不指向垃圾收集器的内存区域

     2. 在非管理指针使用的整个时间内，所引用的内存已被固定

     3. 在非管理指针使用期间，不能进行垃圾收集

     4. 已知给定 CLI 实现的垃圾收集器不会移动所引用的内存

## III.1.2 指令变体表

在§[III.3](iii.3-base-instructions.md)中，为每个指令提供了一个指令变体表。它描述了指令的每个变体。表格的格式列列出了指令变体的操作码，以及跟随在指令流中的任何操作数。例如：

 格式 | 汇编格式 | 描述
 ---- | ---- | ----
 FE 0A _\<unsigned int16\>_ | `ldarga` _argNum_ | 获取参数_argNum_的地址。
 0F _\<unsigned int8\>_ | `ldarga.s` _argNum_ | 获取参数_argNum_的地址，短格式。
 
格式中的第一个或两个十六进制数字显示了这个指令是如何编码的（它的"操作码"）。例如，`ldarga`指令被编码为一个包含FE的字节，后面跟着一个包含0A的字节。由\<和\>分隔的斜体类型名表示应该在指令流中跟随的数字；例如，一个应该被视为无符号整数的2字节量直接跟随在FE 0A操作码后面。_[示例：_`ldc.`_\<type\>_指令的一种形式是`ldc.r8` _num_，它的格式为"23 _\<float64\>_”。对于指令`ldc.r8` 3.1415926535897931，结果代码为23 182D4454FB210940，其中182D4454FB210940是3.1415926535897931的8字节十六进制表示。

类似地，`ldc.`_\<type\>_指令的另一种形式是`ldc.i4.s` _num_，其格式为"1F _\<int8\>_”。对于指令`ldc.i4.s` -3，结果代码为1F FD，其中FD是-3的1字节十六进制表示。`.s`后缀表示指令是短格式指令。在这种情况下，它需要2字节，而不是长格式`ldc.i4`，它需要5字节。_结束示例]_

任何固定大小的内置类型（`int8`，`unsigned int8`，`int16`，`unsigned int16`，`int32`，`unsigned int32`，`int64`，`unsigned in64`，`float32`，和`float64`）都可以出现在格式描述中。这些类型定义了操作数的字节数以及如何解释它（有符号，无符号或浮点）。此外，元数据令牌可以出现，表示为_\<T\>_。令牌被编码为4字节整数。所有操作数数字都按最小地址的最低有效字节编码（这种模式通常被称为"小端"）。指令操作码和操作数的字节尽可能紧密地打包（不进行对齐填充）。

汇编格式列为每个指令变体定义了一个汇编代码助记符。对于具有指令流操作数的指令，此列还为指令的每个操作数分配了名称。对于每个指令操作数，汇编格式中都有一个名称。这些名称稍后在指令描述中使用。







## end
----


接下来你会翻译我说的每句英文为中文
