# CLI：指令集

---
## 引言

本部分详细描述了 Common Intermediate Language (CIL) 指令集，这是 CLI 规范的一部分。第一部分描述了 CLI 的架构，并提供了关于 CIL 指令集的大量问题的概述。这个概述对于理解这里描述的指令集是必要的。

在本部分中，每个指令都在其子小节中描述。相关的 CLI 机器指令一起描述。每个指令描述包括以下部分：

 * 一个描述二进制格式、汇编语言表示法和每个指令变体的描述的表格。参见 §[III.1.2](iii.1.2-instruction-variant-table.md)。
 - 一个堆栈转换图，描述了指令执行前后的求值堆栈状态。参见 §[III.1.3](iii.1.3-stack-transition-diagram.md)。
 * 可能由指令抛出的异常的列表。有三个异常可以由任何指令抛出，并且不在指令中列出：
   * `System.ExecutionEngineException`：表示执行引擎的内部状态已损坏，无法继续执行。在只执行可验证代码的系统中，不会抛出此异常。
   * `System.StackOverflowException`：表示已超过硬件堆栈大小。此异常的精确时间和发生的条件是实现特定的。此异常与 §[III.1.7.4](iii.1.7.4-must-provide-maxstack.md) 中描述的最大堆栈大小无关。该大小与第一部分中描述的方法状态的一部分的求值堆栈的深度有关，而此异常与在物理硬件上实现该方法状态有关。
   * `System.OutOfMemoryException`：表示可用的内存空间已耗尽，要么是因为指令本质上分配内存 (`newobj`，`newarr`)，要么是出于实现特定的原因 (例如，基于 JIT 编译到本地代码的实现可以在执行给定方法的第一个 `call` 或 `callvirt` 时耗尽存储转换方法的空间)。

 + 描述与指令相关的可验证性条件的部分。参见 §[III.1.8](iii.1.8-verifiability-and-correctness.md)。

此外，具有数值操作数的操作还指定一个操作数类型表，描述它们如何基于操作数的类型进行操作。参见 §[III.1.5](iii.1.5-operand-type-table.md)。

请注意，并非所有指令都包含在所有 CLI 配置文件中。参见 [Partition IV]() 以获取详细信息。

>---
### 数据类型

虽然 CTS 定义了一个丰富的类型系统，CLS 指定了一个可以用于语言互操作性的子集，但 CLI 本身处理的是一组更简单的类型。这些类型包括用户定义的值类型和内置类型的一个子集。这个子集被统称为 "基本 CLI 类型"，包含以下类型：
 * 完整数值类型的一个子集 (`int32`，`int64`，`native int` 和 `F`)。
 * 对象引用 (`O`)，不区分引用的对象类型。
 * 指针类型 (`native unsigned int` 和 `&`)，不区分指向的类型。

注意，对象引用和指针类型可以被赋值为 `null`。在 CLI 中，这被定义为零 (所有位都为零的位模式)。

就 VES 在求值堆栈上的操作而言，只有一种浮点类型，VES 并不关心其大小。VES 只在将这些值存储到堆、静态变量、局部变量或方法参数，或从中读取时，才对数值的大小进行区分。

#### 数值数据类型

CLI 只操作数值类型 `int32` (4 字节有符号整数)，`int64` (8 字节有符号整数)，`native int` (本地大小整数)和 `F` (本地大小浮点数)。然而，CIL 指令集允许实现额外的数据类型。

**短整数**：求值栈只保存 4 字节或 8 字节整数，但其他位置 (参数，局部变量，静态变量，数组元素，字段) 可以保存 1 字节或 2 字节整数。对于栈操作，`bool` 和 `char` 类型分别被视为为 1 字节和 2 字节的无符号整数。从这些位置加载到栈上时，会将它们转换为 4 字节值：
   * 对于类型 `unsigned int8`，`unsigned int16`，`bool` 和 `char` 进行零扩展；
   * 对于类型 `int8` 和 `int16` 进行符号扩展；
   * 对于无符号间接和元素加载 (`ldind.u*`，`ldelem.u*`等) 进行零扩展；和
   * 对于有符号的间接和元素加载 (`ldind.i*`，`ldelem.i*` 等) 进行符号扩展。

存储为整数、布尔值和字符时 (`stloc`，`stfld`，`stind.i1`，`stelem.i2` 等) 会发生截断。使用 `conv.ovf.*` 指令检测当此截断导致的值是否能正确表示为原始值。

短 (即 1 字节和 2 字节) 整数在所有架构上都作为 4 字节数字加载，这些 4 字节数字始终被跟踪为与 8 字节数字不同。这有助于代码的可移植性，并确保默认的算术行为 (即，当没有执行 `conv` 或 `conv.ovf` 指令时) 在所有实现上都会得到相同的结果。

产生短整数值的转换指令实际上在栈上留下一个 `int32` (32 位) 值，但保证只有低位有意义 (即，对于无符号转换，更高位都是零，对于有符号转换，是符号扩展)。为了正确模拟短整数操作的完整集合，需要在 `div`、`rem`、`shr`、比较和条件分支指令之前对短整数进行转换。

除了显式转换指令外，CLI 在四种情况下以特殊方式处理短整数：
  1. 分配给局部变量 (`stloc`) 或参数 (`starg`) 的值，其类型被声明为短整数类型，会自动截断到为局部变量或参数指定的大小。
  2. 从局部变量 (`ldloc`) 或参数 (`ldarg`) 加载时，其类型被声明为短有符号整数类型，会自动符号扩展。
  3. 调用带有短整数类型参数的过程相当于对参数值赋值，因此会截断。
  4. 从返回类型为短整数的方法返回值，被建模为在被调用过程中存储到短整数中 (CLI 会自动截断)，然后在调用过程中从短整数加载 (CLI 自动零或符号扩展)。

在最后两种情况下，取决于本地调用约定来确定值是否截断或扩展，以及这是在被调用过程还是调用过程中完成的。CIL 指令序列不受影响，就好像 CIL 序列包含了适当的 `conv` 指令。

**4 字节整数**：实际存储在栈上的最短值是 4 字节整数。这些可以使用 `conv.*` 指令转换为 8 字节整数或本地大小整数。本地大小整数可以转换为 4 字节整数，但这会导致程序在架构之间不可移植。如果可以忽略多余的有效位，则可以使用 `conv.i4` 和 `conv.u4` 进行此转换；`conv.ovf.i4` 和 `conv.ovf.u4` 指令可以用来检测信息丢失。算术运算允许 4 字节整数与本地大小整数相结合，结果是本地大小整数。4 字节整数不能直接与 8 字节整数相结合 (它们应首先转换为 8 字节整数)。

**本地大小整数**：本地大小整数可以使用任何正常的算术指令与 4 字节整数相结合，结果将是本地大小整数。本地大小整数在与 8 字节整数相结合之前，应显式转换为 8 字节整数。

**8 字节整数**：在 32 位硬件上支持 8 字节整数可能会很昂贵，而在当前的 64 位硬件上，32 位算术是可用且高效的。因此，数字指令允许 `int32` 和 `I` 数据类型混合 (产生最大的输入类型)，但这些类型不能与 `int64` 结合。相反，`native int` 或 `int32` 应显式转换为 `int64`，然后才能与`int64`结合。

**无符号整数**：使用特殊指令将堆栈上的整数解释为无符号，而不是将堆栈位置标记为无符号。

**浮点数**：浮点数的存储位置 (静态、数组元素和类的字段) 是固定大小的。支持的存储大小是 `float32` 和 `float64`。在其他地方 (在求值堆栈上，作为参数，作为返回类型，和作为局部变量)，浮点数使用内部浮点类型表示。在每个这样的实例中，变量或表达式的名义类型是 `float32` 或 `float64`，但其值可能以额外的范围和 / 或精度在内部表示。内部浮点表示的大小取决于实现，可能会变化，并且应至少具有与被表示的变量或表达式一样的精度。当这些类型从存储中加载时，将执行这些类型到内部表示的隐式扩展转换。内部表示通常是硬件的自然大小，或者是为了有效实现操作所需的大小。内部表示应具有以下特性：
  * 内部表示应具有大于或等于名义类型的精度和范围。
  * 到内部表示和从内部表示的转换应保留值。这意味着从 `float32` (或 `float64`) 到内部表示的隐式扩展转换，后又从内部表示到 `float32` (或 `float64`) 的显式转换，将得到与原始 `float32` (或 `float64`) 值相同的值。

上述规范允许符合规范的实现在中间计算中避免向目标类型的精度进行舍入，从而允许使用更宽精度的硬件寄存器，以及应用优化转换 (如收缩)，这将产生相同或更大的精度。当需要精确可重现的行为精度时，可以使用显式转换。然而，可重现的精度并不保证可重现的行为。具有额外精度的实现可能会舍入两次：一次是浮点运算，一次是显式转换。没有额外精度的实现实际上只舍入一次。在罕见的情况下，舍入两次与舍入一次可能会产生相差一个最小精度单位的结果。

当一个浮点值的内部表示比其名义类型具有更大的范围和 / 或精度，并且被放入存储位置时，它会自动强制转换为存储位置的类型。这可能涉及到精度的损失或创建一个超出范围的值 (**NaN**，**+infinity**，或 **-infinity**)。然而，如果它从存储位置重新加载而没有被修改，那么它的值可能会在内部表示中保留以供将来使用。编译器有责任确保在后续加载时内存位置仍然有效，考虑到别名和其他执行线程的影响。然而，在执行显式转换 (`conv.r4` 或 `conv.r8`) 之后，这种携带额外精度的自由是不允许的，此时内部表示必须能在关联类型中精确表示。

要检测不能转换为特定存储类型的值，可以使用转换指令 (`conv.r4` 或 `conv.r8`)，然后使用 `ckfinite` 检查超出范围的值。在转换为特定存储类型时检测下溢，需要在转换前后进行比较为零。_结束注释]_

   _[注：_本标准并未规定对非规格化浮点数的算术运算的行为，也没有规定何时或是否应该创建这样的表示。这与IEC 60559:1989保持一致。此外，本标准并未规定如何访问创建的**NaN**的确切位模式，以及在32位和64位表示之间转换**NaN**时的行为。所有这些行为都被有意地留给实现特定。_结束注释]_

#### 布尔数据类型

CLI 的布尔类型在内存中占用 1 字节。全零的位模式表示假值。任何一个或多个位设置的位模式 (类似于非零整数) 表示真值。为了堆栈操作的目的，布尔值被视为无符号的 1 字节整数。

#### 字符数据类型

CLI 的 `char` 类型在内存中占用 2 字节，并使用 UTF-16 编码表示一个 Unicode 代码单元。为了堆栈操作的目的，`char` 值被视为无符号的 2 字节整数。

#### 对象引用

对象引用 (类型 `O`) 是完全不透明的。没有允许对象引用作为操作数的算术指令，唯一允许的比较操作是两个对象引用之间的等式和不等式。对象引用上没有定义转换操作。对象引用由某些 CIL 对象指令 (特别是 `newobj` 和 `newarr`) 创建。对象引用可以作为参数传递，存储为局部变量，作为值返回，并存储在数组和对象的字段中。

#### 运行时指针类型

有两种指针：非托管指针和托管指针。对于指向同一数组或对象的指针，定义了以下算术运算：
 * 将整数加到指针上，其中整数被解释为字节数，结果是相同类型的指针。
 * 从指针中减去一个整数 (字节数) 得到的是相同类型的指针。注意，不允许从整数中减去一个指针。
 * 两个指针，无论类型如何，可以相互减去，并产生一个有符号整数，表示它们引用的地址之间的字节数。

这些操作在可验证的代码中都是不允许的。

理解在不同类型的指针上使用算术运算对垃圾收集器的影响是很重要的。由于非托管指针永远不会引用由垃圾收集器控制的内存，因此在它们上执行算术运算可能会危及系统的内存安全性 (因此它不是可验证的 )，但由于它们没有报告给垃圾收集器，所以对其操作没有影响。

然而，托管指针被报告给垃圾收集器。作为垃圾收集的一部分，它们指向的位置的内容*和*指针本身都可以被修改。如果托管指针指向不受其控制的内存 (评估栈，调用栈，静态内存，或受其他分配器控制的内存 )，垃圾收集器将忽略托管指针。然而，如果一个托管指针引用了由垃圾收集器控制的内存，它*必须*指向对象的一个字段，数组的一个元素，或者刚好在数组末尾的元素的地址。如果使用地址算术创建一个引用任何其他位置 (对象头或分配的内存中的间隙 )的托管指针，垃圾收集器的行为是未指定的。

## III.1.1.5.1 未管理的指针

未管理的指针是像C和C++这样的语言中使用的传统指针。它们的使用没有限制，尽管在大多数情况下，它们会产生无法验证的代码。虽然将包含未管理指针的位置标记为无符号整数 (实际上，这就是CLI如何处理它们的方式 )是完全有效的，但通常更好的做法是将它们标记为指向特定数据类型的未管理指针。这是通过在返回值、局部变量或参数的签名中使用`ELEMENT_TYPE_PTR`，或者在字段或数组元素中使用指针类型来完成的。

未管理的指针不会被报告给垃圾收集器，并且可以以任何整数可以使用的方式使用。

 * 未管理的指针应被视为无符号 (即，使用`conv.ovf.u`而不是`conv.ovf.i`等 )。

 * 可验证的代码不能使用未管理的指针来引用内存。

 * 未验证的代码可以将未管理的指针传递给期望管理指针的方法。只有在以下情况之一为真时，这才是安全的：

     1. 未管理的指针引用的内存不在垃圾收集器管理的内存中。

     2. 未管理的指针引用对象内的字段。

     3. 未管理的指针引用数组内的元素。

     4. 未管理的指针引用的位置是数组中最后一个元素后面的元素所在的位置。

### III.1.1.5.2 Managed pointers (type &)

在 CLI 中，管理指针 (`&` )可以指向局部变量、方法参数、对象的字段、值类型的字段、数组的元素、静态字段，或者存储数组末尾元素之后的元素的地址 (用于指向管理数组的指针索引 )。管理指针不能为 `null`。 (即使它们不指向管理内存，也应该报告给垃圾收集器 )

通过在返回值、局部变量或参数的签名中使用 `ELEMENT_TYPE_BYREF`，或者通过对字段或数组元素使用 byref 类型来指定管理指针。

 * 管理指针可以作为参数传递并存储在局部变量中。

 * 如果你通过引用传递一个参数，相应的参数就是一个管理指针。

 * 管理指针不能存储在静态变量、数组元素或对象或值类型的字段中。

 * 管理指针**不**可以与对象引用互换。

 * 管理指针不能指向另一个管理指针，但它可以指向对象引用或值类型。

 * 不指向管理内存的管理指针可以被转换 (使用 `conv.u` 或 `conv.ovf`.u )为非管理指针，但这不是可验证的。

 * 错误地将管理指针转换为非管理指针的未验证代码可能严重损害 CLI 的完整性。如果已知以下任何一项为真，则此转换是安全的：

     1. 管理指针不指向垃圾收集器的内存区域

     2. 在非管理指针使用的整个时间内，所引用的内存已被固定

     3. 在非管理指针使用期间，不能进行垃圾收集

     4. 已知给定 CLI 实现的垃圾收集器不会移动所引用的内存

## III.1.2 指令变体表

在§[III.3](iii.3-base-instructions.md)中，为每个指令提供了一个指令变体表。它描述了指令的每个变体。表格的格式列列出了指令变体的操作码，以及跟随在指令流中的任何操作数。例如：

 格式 | 汇编格式 | 描述
 ---- | ---- | ----
 FE 0A _\<unsigned int16\>_ | `ldarga` _argNum_ | 获取参数_argNum_的地址。
 0F _\<unsigned int8\>_ | `ldarga.s` _argNum_ | 获取参数_argNum_的地址，短格式。
 
格式中的第一个或两个十六进制数字显示了这个指令是如何编码的 (它的"操作码" )。例如，`ldarga`指令被编码为一个包含FE的字节，后面跟着一个包含0A的字节。由\<和\>分隔的斜体类型名表示应该在指令流中跟随的数字；例如，一个应该被视为无符号整数的2字节量直接跟随在FE 0A操作码后面。_[示例：_`ldc.`_\<type\>_指令的一种形式是`ldc.r8` _num_，它的格式为"23 _\<float64\>_”。对于指令`ldc.r8` 3.1415926535897931，结果代码为23 182D4454FB210940，其中182D4454FB210940是3.1415926535897931的8字节十六进制表示。

类似地，`ldc.`_\<type\>_指令的另一种形式是`ldc.i4.s` _num_，其格式为"1F _\<int8\>_”。对于指令`ldc.i4.s` -3，结果代码为1F FD，其中FD是-3的1字节十六进制表示。`.s`后缀表示指令是短格式指令。在这种情况下，它需要2字节，而不是长格式`ldc.i4`，它需要5字节。_结束示例]_

任何固定大小的内置类型 (`int8`，`unsigned int8`，`int16`，`unsigned int16`，`int32`，`unsigned int32`，`int64`，`unsigned in64`，`float32`，和`float64` )都可以出现在格式描述中。这些类型定义了操作数的字节数以及如何解释它 (有符号，无符号或浮点 )。此外，元数据令牌可以出现，表示为_\<T\>_。令牌被编码为4字节整数。所有操作数数字都按最小地址的最低有效字节编码 (这种模式通常被称为"小端" )。指令操作码和操作数的字节尽可能紧密地打包 (不进行对齐填充 )。

汇编格式列为每个指令变体定义了一个汇编代码助记符。对于具有指令流操作数的指令，此列还为指令的每个操作数分配了名称。对于每个指令操作数，汇编格式中都有一个名称。这些名称稍后在指令描述中使用。







## end
----


接下来你会翻译我说的每句英文为中文
