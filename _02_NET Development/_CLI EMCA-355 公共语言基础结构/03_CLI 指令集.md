# CLI：指令集

---
## 引言

本部分详细描述了 Common Intermediate Language (CIL) 指令集，这是 CLI 规范的一部分。第一部分描述了 CLI 的架构，并提供了关于 CIL 指令集的大量问题的概述。这个概述对于理解这里描述的指令集是必要的。

在本部分中，每个指令都在其子小节中描述。相关的 CLI 机器指令一起描述。每个指令描述包括以下部分：

 * 一个描述二进制格式、汇编语言表示法和每个指令变体的描述的表格。参见 §[[↗]](#ins-var-table)。
 - 一个堆栈转换图，描述了指令执行前后的求值堆栈状态。参见 §[[↗]](#stack-img)。
 * 可能由指令抛出的异常列表。有三个异常可以由任何指令抛出，并且不在指令中列出：
   * `System.ExecutionEngineException`：表示执行引擎的内部状态已损坏，无法继续执行。在只执行可验证代码的系统中，不会抛出此异常。
   * `System.StackOverflowException`：表示已超过硬件堆栈大小。此异常的精确时间和发生的条件是特定实现的。此异常与 §[_MaxStack_](#maxstack) 中描述的最大堆栈大小无关。该大小与第一部分中描述的方法状态中一部分的求值堆栈的深度有关，而此异常与在物理硬件上实现该方法状态有关。
   * `System.OutOfMemoryException`：表示可用的内存空间已耗尽，要么是因为指令本质上分配内存 (`newobj`，`newarr`)，要么是出于实现特定的原因 (例如，基于 JIT 编译到本地代码的实现可以在执行给定方法的第一个 `call` 或 `callvirt` 时耗尽存储转换方法的空间)。

 + 描述与指令相关的可验证性条件的部分。参见 §[[↗]](#Verifiability)。

此外，具有数值操作数的操作还指定一个操作数类型表，描述它们如何基于操作数的类型进行操作。参见 §[[↗]](#Operand-type-table)。

请注意，并非所有指令都包含在所有 CLI 配置文件中。参见 [Partition IV](【】) 以获取详细信息。

>---
### 数据类型

虽然 CTS 定义了一个丰富的类型系统，CLS 指定了一个可以用于语言互操作性的子集，但 CLI 本身处理的是一组更简单的类型。这些类型包括用户定义的值类型和内置类型的一个子集。这个子集被统称为 "基本 CLI 类型"，包含以下类型：
 * 完整数值类型的一个子集 (`int32`，`int64`，`native int` 和 `F`)。
 * 对象引用 (`O`)，不区分引用的对象类型。
 * 指针类型 (`native unsigned int` 和 `&`)，不区分指向的类型。

注意，对象引用和指针类型可以被赋值为 `null`。在 CLI 中，这被定义为零 (所有位都为零的位模式)。

就 VES 在求值堆栈上的操作而言，只有一种浮点类型，VES 并不关心其大小。VES 只在将这些值存储到堆、静态变量、局部变量或方法参数，或从中读取时，才对数值的大小进行区分。

#### 数值数据类型
<a id="numeric-data-types"></a>

CLI 只操作数值类型 `int32` (4 字节有符号整数)，`int64` (8 字节有符号整数)，`native int` (本地大小整数)和 `F` (本地大小浮点数)。然而，CIL 指令集允许实现额外的数据类型。

**短整数**：求值栈只保存 4 字节或 8 字节整数，但其他位置 (参数，局部变量，静态变量，数组元素，字段) 可以保存 1 字节或 2 字节整数。对于栈操作，`bool` 和 `char` 类型分别被视为为 1 字节和 2 字节的无符号整数。从这些位置加载到栈上时，会将它们转换为 4 字节值：
   * 对于类型 `unsigned int8`，`unsigned int16`，`bool` 和 `char` 进行零扩展；
   * 对于类型 `int8` 和 `int16` 进行符号扩展；
   * 对于无符号间接和元素加载 (`ldind.u*`，`ldelem.u*` 等) 进行零扩展；和
   * 对于有符号的间接和元素加载 (`ldind.i*`，`ldelem.i*` 等) 进行符号扩展。

存储为整数、布尔值和字符时 (`stloc`，`stfld`，`stind.i1`，`stelem.i2` 等) 会发生截断。使用 `conv.ovf.*` 指令检测当前截断的值是否能正确表示为原始值。

短整数 (即 1 字节和 2 字节) 在所有架构上都作为 4 字节数字加载，这些 4 字节数字始终被跟踪为与 8 字节数字不同。这有助于代码的可移植性，并确保默认的算术行为 (即，当没有执行 `conv` 或 `conv.ovf` 指令时) 在所有实现上都会得到相同的结果。

产生短整数值的转换指令实际上在栈上留下一个 `int32` 值，但保证只有低位有意义 (即，对于无符号转换，更高位都是零；对于有符号转换，是符号扩展)。为了正确模拟短整数操作的完整集合，需要在使用 `div`、`rem`、`shr`、比较和条件分支指令之前对短整数进行转换。

除了显式转换指令外，CLI 在四种情况下以特殊方式处理短整数：
  1. 分配给局部变量 (`stloc`) 或参数 (`starg`) 的值，其类型被声明为短整数类型，会自动截断到为局部变量或参数指定的大小。
  2. 从局部变量 (`ldloc`) 或参数 (`ldarg`) 加载时，若其类型被声明为短有符号整数类型，则会自动符号扩展。
  3. 调用带有短整数类型参数的过程相当于对参数赋值，因此值会被截断。
  4. 从返回类型为短整数的方法返回值，被建模为在被调用过程中存储到短整数中 (CLI 会自动截断)，然后在调用过程中从短整数加载 (CLI 自动零或符号扩展)。

在最后两种情况下，取决于本地调用约定来确定值是否截断或扩展，以及这是在被调用过程还是调用过程中完成的。CIL 指令序列不受影响，就好像 CIL 序列包含了适当的 `conv` 指令。

**4 字节整数**：实际存储在栈上的最短值是 4 字节整数。这些可以使用 `conv.*` 指令转换为 8 字节整数或本地大小整数。本地大小整数可以转换为 4 字节整数，但这会导致程序在架构之间不可移植。如果可以忽略多余的有效位，则可以使用 `conv.i4` 和 `conv.u4` 进行此转换；`conv.ovf.i4` 和 `conv.ovf.u4` 指令可以用来检测信息丢失。算术运算允许 4 字节整数与本地大小整数相结合，结果是本地大小整数。4 字节整数不能直接与 8 字节整数相结合 (它们应首先转换为 8 字节整数)。

**本地大小整数**：本地大小整数可以使用任何正常的算术指令与 4 字节整数相结合，结果将是本地大小整数。本地大小整数在与 8 字节整数相结合之前，应显式转换为 8 字节整数。

**8 字节整数**：在 32 位硬件上支持 8 字节整数可能会很昂贵，而在 64 位硬件上，32 位算术是可用且高效的。因此，数字指令允许 `int32` 和 `I` 数据类型混合 (产生最大的输入类型)，但这些类型不能与 `int64` 结合。相反，`native int` 或 `int32` 应显式转换为 `int64`，然后才能与 `int64` 结合。

**无符号整数**：使用特殊指令将堆栈上的整数解释为无符号，而不是将堆栈位置标记为无符号。

**浮点数**：浮点数的存储位置 (静态、数组元素和类的字段) 是固定大小的。支持的存储大小是 `float32` 和 `float64`。在其他地方 (在求值堆栈上，作为参数，作为返回类型，和作为局部变量)，浮点数使用内部浮点类型表示。在每个这样的实例中，变量或表达式的名义类型是 `float32` 或 `float64`，但其值可能以额外的范围和 / 或精度在内部表示。内部浮点表示的大小取决于实现，可能会变化，并且应至少具有与被表示的变量或表达式一样的精度。当这些类型从存储中加载时，将执行这些类型到内部表示的隐式扩展转换。内部表示通常是硬件的自然大小，或者是为了有效实现操作所需的大小。内部表示应具有以下特性：
  * 内部表示应具有大于或等于名义类型的精度和范围。
  * 到 / 从内部表示的转换应保留值。这意味着从 `float32` (或 `float64`) 到内部表示的隐式扩展转换，后又从内部表示到 `float32` (或 `float64`) 的显式转换，将得到与原始 `float32` (或 `float64`) 值相同的值。

上述规范允许符合规范的实现在中间计算中避免向目标类型的精度进行舍入，从而允许使用更宽精度的硬件寄存器，以及应用优化转换 (如收缩)，这将产生相同或更大的精度。当需要精确可重现的行为精度时，可以使用显式转换。然而，可重现的精度并不保证可重现的行为。具有额外精度的实现可能会舍入两次：一次是浮点运算，一次是显式转换。没有额外精度的实现实际上只舍入一次。在罕见的情况下，舍入两次与舍入一次可能会产生相差一个最小精度单位的结果。

当一个浮点值的内部表示比其名义类型具有更大的范围和 / 或精度，并且被放入存储位置时，它会自动强制转换为存储位置的类型。这可能涉及到精度的损失或创建一个超出范围的值 (**NaN**，**+infinity**，或 **-infinity**)。然而，如果它从存储位置重新加载而没有被修改，那么它的值可能会在内部表示中保留以供将来使用。编译器有责任确保在后续加载时内存位置仍然有效，考虑到别名和其他执行线程的影响。然而，在执行显式转换 (`conv.r4` 或 `conv.r8`) 之后，这种携带额外精度的自由是不允许的，此时内部表示必须能在关联类型中精确表示。

要检测不能转换为特定存储类型的值，可以使用转换指令 (`conv.r4` 或 `conv.r8`)，然后使用 `ckfinite` 检查超出范围的值。在转换为特定存储类型时检测下溢，需要在转换前后与零进行比较。

本标准并未规定对非规格化浮点数的算术运算的行为，也没有规定何时或是否应该创建这样的表示。这与 IEC 60559:1989 保持一致。此外，本标准并未规定如何访问创建的 **NaN** 的确切位模式，以及在 32 位和 64 位表示之间转换 **NaN** 时的行为。所有这些行为都被有意地留给特定实现。

#### 布尔数据类型

CLI 的布尔类型在内存中占用 1 字节。全零的位模式表示假值。任何一个或多个位设置的位模式 (类似于非零整数) 表示真值。为了堆栈操作的目的，布尔值被视为无符号的 1 字节整数。

#### 字符数据类型

CLI 的 `char` 类型在内存中占用 2 字节，并使用 UTF-16 编码表示一个 Unicode 代码单元。为了堆栈操作的目的，`char` 值被视为无符号的 2 字节整数。

#### 对象引用

对象引用 (类型 `O`) 是完全不透明的。没有允许对象引用作为操作数的算术指令，唯一允许的比较操作是两个对象引用之间的等式和不等式。对象引用上没有定义转换操作。对象引用由某些 CIL 对象指令 (特别是 `newobj` 和 `newarr`) 创建。对象引用可以作为参数传递，存储为局部变量，作为值返回，或存储在数组和对象的字段中。

#### 运行时指针类型

有两种指针：非托管指针和托管指针。对于指向同一数组或对象的指针，定义了以下算术运算：
 * 将整数加到指针上，其中整数被解释为字节数，结果是相同类型的指针。
 * 从指针中减去一个整数 (字节数) 得到的是相同类型的指针。注意，不允许从整数中减去一个指针。
 * 两个指针，无论类型如何，可以相互减去，并产生一个有符号整数，表示它们引用的地址之间的字节数。

这些操作在可验证的代码中都是不允许的。

理解在不同类型的指针上使用算术运算对垃圾收集器的影响是很重要的。由于非托管指针永远不会引用由垃圾收集器控制的内存，因此在它们上执行算术运算可能会危及系统的内存安全性 (因此它不是可验证的)，但由于它们没有报告给垃圾收集器，所以对其操作没有影响。

然而，托管指针被报告给垃圾收集器。作为垃圾收集的一部分，它们指向的位置的内容和指针本身都可以被修改。如果托管指针指向不受其控制的内存 (求值栈，调用栈，静态内存，或受其他分配器控制的内存)，垃圾收集器将忽略托管指针。然而，如果一个托管指针引用了由垃圾收集器控制的内存，它必须指向对象的一个字段，数组的一个元素，或者刚好在数组末尾元素的地址。如果使用地址算术创建一个引用任何其他位置 (对象头或分配的内存中的间隙) 的托管指针，垃圾收集器的行为是未指定的。

##### 非托管指针

非托管指针是像 C 和 C++ 这样的语言中使用的传统指针。它们的使用没有限制，尽管在大多数情况下，它们会产生无法验证的代码。虽然将包含非托管指针的位置标记为无符号整数 (实际上，这就是 CLI 处理它们的方式) 是完全有效的，但通常更好的做法是将它们标记为指向特定数据类型的非托管指针。这是通过在返回值、局部变量或参数的签名中使用 *`ELEMENT_TYPE_PTR`*，或者在字段或数组元素中使用指针类型来完成的。

非托管指针不会被报告给垃圾收集器，并且可以以任何整数可以使用的方式使用。

 * 非托管指针应被视为无符号 (即，应使用 `conv.ovf.u` 而不是 `conv.ovf.i` 等)。
 * 可验证的代码不能使用非托管指针来引用内存。
 * 未验证的代码可以将非托管指针传递给期望托管指针的方法。只有在以下情况之一为真时，这才是安全的：
     1. 非托管指针引用的内存不在垃圾收集器管理的内存中。
     2. 非托管指针引用对象内的字段。
     3. 非托管指针引用数组内的元素。
     4. 非托管指针引用的位置是数组中最后一个元素后面的元素所在的位置。

##### 托管指针 (&)

在 CLI 中，托管指针 (`&`) 可以指向局部变量、方法参数、对象字段、值类型字段、数组元素、静态字段，或者存储数组末尾元素之后的元素的地址 (用于指向托管数组的指针索引)。指针不能为 `null`。 (即使它们不指向托管内存，也应该报告给垃圾收集器 )

通过在返回值、局部变量或参数的签名中使用 *`ELEMENT_TYPE_BYREF`*，或者通过对字段或数组元素使用 **byref** 类型来指定托管指针。
 * 托管指针可以作为参数传递并存储在局部变量中。
 * 如果通过引用传递一个参数时，相应的参数就是一个托管指针。
 * 托管指针不能存储在静态变量、数组元素或对象或值类型的字段中。(C# 除 *ref-struct* 类型以外的值类型。) 
 * 托管指针不可以与对象引用互换。
 * 托管指针不能指向另一个托管指针，但它可以指向对象引用或值类型。
 * 不指向托管内存的托管指针可以被转换 (使用 `conv.u` 或 `conv.ovf.u`) 为非托管指针，但这不是可验证的。
 * 错误地将托管指针转换为非托管指针的未验证代码可能严重损害 CLI 的完整性。如果已知以下任何一项为真，则此转换是安全的：
     1. 托管指针不指向垃圾收集器的内存区域。
     2. 在非托管指针使用的整个时间内，所引用的内存已被固定。
     3. 在非托管指针使用期间，不能进行垃圾收集。
     4. 已知给定 CLI 实现的垃圾收集器不会移动所引用的内存。

>---
### 指令变体表
<a id= "ins-var-table"></a>

在 §[[↗]](#base-ins) 中，为每个指令提供了一个指令变体表。它描述了指令的每个变体。表格的格式列列出了指令变体的操作码，以及跟随在指令流中的任何操作数。例如：

 | 格式                       | 汇编格式            | 描述                               |
 | -------------------------- | ------------------- | ---------------------------------- |
 | FE 0A _\<unsigned int16\>_ | `ldarga` _argNum_   | 获取参数 _argNum_ 的地址。         |
 | 0F _\<unsigned int8\>_     | `ldarga.s` _argNum_ | 获取参数 _argNum_ 的地址，短格式。 |
 
格式中的第一个或两个十六进制数字显示了这个指令是如何编码的 (它的 "操作码")。例如，`ldarga` 指令被编码为一个包含 FE 的字节，后面跟着一个包含 0A 的字节。由 `< >` 分隔的类型名表示应该在指令流中跟随的数字；例如，一个应该被视为无符号整数的 2 字节量直接跟随在 FE 0A 操作码后面。例如：`ldc.<type>` 指令的一种形式是 `ldc.r8 num`，它的格式为 `23 <float64>`。对于指令 `ldc.r8 3.1415926535897931`，结果代码为 `23 182D4454FB210940`，其中 `182D4454FB210940` 是 `3.1415926535897931` 的 8 字节十六进制表示。

类似地，`ldc. <type>` 指令的另一种形式是 `ldc.i4.s num`，其格式为 `1F <int8>`。对于指令 `ldc.i4.s -3`，结果代码为 `1F FD`，其中 `FD` 是 `-3` 的 1 字节十六进制表示。`.s` 后缀表示指令是短格式指令。在这种情况下，它需要 2 字节，而不是需要 5 字节的长格式 `ldc.i4`。

任何固定大小的内置类型 (`int8`，`unsigned int8`，`int16`，`unsigned int16`，`int32`，`unsigned int32`，`int64`，`unsigned in64`，`float32` 和 `float64`) 都可以出现在格式描述中。这些类型定义了操作数的字节数以及如何解释它 (有符号，无符号或浮点)。此外，元数据 _token_ 可以出现，表示为 `<T>`。_token_ 被编码为 4 字节整数。所有操作数数字都按最小地址的最低有效字节编码 (这种模式通常被称为 "小端")。指令操作码和操作数的字节尽可能紧密地打包 (不进行对齐填充)。

汇编格式列为每个指令变体定义了一个汇编代码助记符。对于具有指令流操作数的指令，此列还为指令的每个操作数分配了名称。对于每个指令操作数，汇编格式中都有一个名称。这些名称稍后在指令描述中使用。

#### Opcode 编码

CIL 操作码长度为一个或多个字节；它们可以后跟零个或多个操作数字节。所有第一个字节位于 0x00 ~ 0xEF，以及 0xFC ~ 0xFF 范围内的操作码都保留用于标准化。第一个字节位于 0xF0 ~ 0xFB（包含）范围内的操作码可用于实验目的。在任何方法中使用实验操作码会使该方法无效，因此无法验证。

> Opcode 编码
<a id="OpTable1"></a>

| Opcode    | Instruction      | description                                                                                |
| :-------- | :--------------- | :----------------------------------------------------------------------------------------- |
| 0x00      | `nop`            | 无操作                                                                                     |
| 0x01      | `break`          | 断点指令                                                                                   |
| 0x02      | `ldarg.0`        | 将参数 0 加载到堆栈                                                                        |
| 0x03      | `ldarg.1`        | 将参数 1 加载到堆栈                                                                        |
| 0x04      | `ldarg.2`        | 将参数 2 加载到堆栈                                                                        |
| 0x05      | `ldarg.3`        | 将参数 3 加载到堆栈                                                                        |
| 0x06      | `ldloc.0`        | 将局部变量 0 加载到堆栈                                                                    |
| 0x07      | `ldloc.1`        | 将局部变量 1 加载到堆栈                                                                    |
| 0x08      | `ldloc.2`        | 将局部变量 2 加载到堆栈                                                                    |
| 0x09      | `ldloc.3`        | 将局部变量 3 加载到堆栈                                                                    |
| 0x0A      | `stloc.0`        | 将值从堆栈弹出到局部变量 0                                                                 |
| 0x0B      | `stloc.1`        | 将值从堆栈弹出到局部变量 1                                                                 |
| 0x0C      | `stloc.2`        | 将值从堆栈弹出到局部变量 2                                                                 |
| 0x0D      | `stloc.3`        | 将值从堆栈弹出到局部变量 3                                                                 |
| 0x0E      | `ldarg.s`        | 将编号为 _num_ 的参数加载到堆栈，短格式                                                    |
| 0x0F      | `ldarga.s`       | 获取参数 _argNum_ 的地址，短格式                                                           |
| 0x10      | `starg.s`        | 将值存储到编号为 _num_ 的参数中，短格式                                                    |
| 0x11      | `ldloc.s`        | 将索引为 _indx_ 的局部变量加载到堆栈，短格式                                               |
| 0x12      | `ldloca.s`       | 加载索引为 _indx_ 的局部变量的地址，短格式                                                 |
| 0x13      | `stloc.s`        | 将值从堆栈弹出到局部变量 _indx_，短格式                                                    |
| 0x14      | `ldnull`         | 在堆栈上推送一个空引用                                                                     |
| 0x15      | `ldc.i4.m1`      | 将 -1 推送到堆栈作为 `int32`                                                               |
| 0x16      | `ldc.i4.0`       | 将 0 推送到堆栈作为 `int32`                                                                |
| 0x17      | `ldc.i4.1`       | 将 1 推送到堆栈作为 `int32`                                                                |
| 0x18      | `ldc.i4.2`       | 将 2 推送到堆栈作为 `int32`                                                                |
| 0x19      | `ldc.i4.3`       | 将 3 推送到堆栈作为 `int32`                                                                |
| 0x1A      | `ldc.i4.4`       | 将 4 推送到堆栈作为 `int32`                                                                |
| 0x1B      | `ldc.i4.5`       | 将 5 推送到堆栈作为 `int32`                                                                |
| 0x1C      | `ldc.i4.6`       | 将 6 推送到堆栈作为 `int32`                                                                |
| 0x1D      | `ldc.i4.7`       | 将 7 推送到堆栈作为 `int32`                                                                |
| 0x1E      | `ldc.i4.8`       | 将 8 推送到堆栈作为 `int32`                                                                |
| 0x1F      | `ldc.i4.s`       | 将 _num_ 推送到堆栈作为 `int32`，短格式                                                    |
| 0x20      | `ldc.i4`         | 将类型为 `int32` 的 _num_ 推送到堆栈作为 `int32`                                           |
| 0x21      | `ldc.i8`         | 将类型为 `int64` 的 _num_ 推送到堆栈作为 `int64`                                           |
| 0x22      | `ldc.r4`         | 将类型为 `float32` 的 _num_ 推送到堆栈作为 `F`                                             |
| 0x23      | `ldc.r8`         | 将类型为 `float64` 的 _num_ 推送到堆栈作为 `F`                                             |
| 0x25      | `dup`            | 复制堆栈顶部的值                                                                           |
| 0x26      | `pop`            | 从堆栈弹出值                                                                               |
| 0x27      | `jmp`            | 退出当前方法并跳转到指定的方法                                                             |
| 0x28      | `call`           | 调用由 _method_ 描述的方法                                                                 |
| 0x29      | `calli`          | 使用由 _callsitedescr_ 描述的参数调用堆栈上指示的方法                                      |
| 0x2A      | `ret`            | 可能带有值的从方法返回                                                                     |
| 0x2B      | `br.s`           | 分支到 _target_，短格式                                                                    |
| 0x2C      | `brfalse.s`      | 如果 _value_ 为零（假），则分支到 _target_，短格式                                         |
| 0x2D      | `brtrue.s`       | 如果 _value_ 为非零（真），则分支到 _target_，短格式                                       |
| 0x2E      | `beq.s`          | 如果等于则跳转到 _target_，短格式                                                          |
| 0x2F      | `bge.s`          | 如果大于或等于则跳转到 _target_，短格式                                                    |
| 0x30      | `bgt.s`          | 如果大于，则分支到 _target_，短格式                                                        |
| 0x31      | `ble.s`          | 如果小于或等于，则分支到 _target_，短格式                                                  |
| 0x32      | `blt.s`          | 如果小于，则分支到 _target_，短格式                                                        |
| 0x33      | `bne.un.s`       | 如果不等于或无序，则分支到 _target_，短格式                                                |
| 0x34      | `bge.un.s`       | 如果大于或等于（无符号或无序），则分支到 _target_，短格式                                  |
| 0x35      | `bgt.un.s`       | 如果大于（无符号或无序），则分支到 _target_，短格式                                        |
| 0x36      | `ble.un.s`       | 如果小于或等于（无符号或无序），则分支到 _target_，短格式                                  |
| 0x37      | `blt.un.s`       | 如果小于（无符号或无序），则分支到 _target_，短格式                                        |
| 0x38      | `br`             | 分支到 _target_                                                                            |
| 0x39      | `brfalse`        | 如果 _value_ 为零（假），则分支到 _target_                                                 |
| 0x3A      | `brtrue`         | 如果 _value_ 为非零（真），则分支到 _target_                                               |
| 0x3B      | `beq`            | 如果等于则跳转到 _target_                                                                  |
| 0x3C      | `bge`            | 如果大于或等于则跳转到 _target_                                                            |
| 0x3D      | `bgt`            | 如果大于，则分支到 _target_                                                                |
| 0x3E      | `ble`            | 如果小于或等于，则分支到 _target_                                                          |
| 0x3F      | `blt`            | 如果小于，则分支到 _target_                                                                |
| 0x40      | `bne.un`         | 如果不等于或无序，则分支到 _target_                                                        |
| 0x41      | `bge.un`         | 如果大于或等于（无符号或无序），则分支到 _target_                                          |
| 0x42      | `bgt.un`         | 如果大于（无符号或无序），则分支到 _target_                                                |
| 0x43      | `ble.un`         | 如果小于或等于（无符号或无序），则分支到 _target_                                          |
| 0x44      | `blt.un`         | 如果小于（无符号或无序），则分支到 _target_                                                |
| 0x45      | `switch`         | 跳转到 _n_ 个值中的一个                                                                    |
| 0x46      | `ldind.i1`       | 将类型为 `int8` 的值作为 `int32` 间接加载到堆栈                                            |
| 0x47      | `ldind.u1`       | 将类型为 `unsigned int8` 的值作为 `int32` 间接加载到堆栈                                   |
| 0x48      | `ldind.i2`       | 将类型为 `int16` 的值作为 `int32` 间接加载到堆栈                                           |
| 0x49      | `ldind.u2`       | 将类型为 `unsigned int16` 的值作为 `int32` 间接加载到堆栈                                  |
| 0x4A      | `ldind.i4`       | 将类型为 `int32` 的值作为 `int32` 间接加载到堆栈                                           |
| 0x4B      | `ldind.u4`       | 将类型为 `unsigned int32` 的值作为 `int32` 间接加载到堆栈                                  |
| 0x4C      | `ldind.i8`       | 将类型为 `int64` 的值作为 `int64` 间接加载到堆栈                                           |
| 0x4D      | `ldind.i`        | 将类型为 `native int` 的值作为 `native int` 间接加载到堆栈                                 |
| 0x4E      | `ldind.r4`       | 将类型为 `float32` 的值作为 `F` 间接加载到堆栈                                             |
| 0x4F      | `ldind.r8`       | 将类型为 `float64` 的值作为 `F` 间接加载到堆栈                                             |
| 0x50      | `ldind.ref`      | 将类型为对象引用的值作为 `O` 间接加载到堆栈                                                |
| 0x51      | `stind.ref`      | 将类型为对象引用（类型 `O`）的值存储到 _address_ 处的内存中                                |
| 0x52      | `stind.i1`       | 将类型为 `int8` 的值存储到 _address_ 处的内存中                                            |
| 0x53      | `stind.i2`       | 将类型为 `int16` 的值存储到 _address_ 处的内存中                                           |
| 0x54      | `stind.i4`       | 将类型为 `int32` 的值存储到 _address_ 处的内存中                                           |
| 0x55      | `stind.i8`       | 将类型为 `int64` 的值存储到 _address_ 处的内存中                                           |
| 0x56      | `stind.r4`       | 将类型为 `float32` 的值存储到 _address_ 处的内存中                                         |
| 0x57      | `stind.r8`       | 将类型为 `float64` 的值存储到 _address_ 处的内存中                                         |
| 0x58      | `add`            | 添加两个值，返回一个新值                                                                   |
| 0x59      | `sub`            | 从 _value1_ 中减去 _value2_，返回一个新值。                                                |
| 0x5A      | `mul`            | 乘法运算                                                                                   |
| 0x5B      | `div`            | 除法运算两个值，返回商或浮点结果                                                           |
| 0x5C      | `div.un`         | 除法运算两个值，无符号，返回商                                                             |
| 0x5D      | `rem`            | 一个值除以另一个值后的余数                                                                 |
| 0x5E      | `rem.un`         | 一个无符号值除以另一个值后的余数                                                           |
| 0x5F      | `and`            | 两个整数值的按位与，返回一个整数值                                                         |
| 0x60      | `or`             | 两个整数值的按位或，返回一个整数                                                           |
| 0x61      | `xor`            | 整数值的按位异或，返回一个整数                                                             |
| 0x62      | `shl`            | 将整数左移（移入零），返回一个整数                                                         |
| 0x63      | `shr`            | 将整数右移（移入符号），返回一个整数                                                       |
| 0x64      | `shr.un`         | 将整数右移（移入零），返回一个整数                                                         |
| 0x65      | `neg`            | 取反                                                                                       |
| 0x66      | `not`            | 按位取反                                                                                   |
| 0x67      | `conv.i1`        | 转换为 `int8`，在堆栈上推送 `int32`                                                        |
| 0x68      | `conv.i2`        | 转换为 `int16`，在堆栈上推送 `int32`                                                       |
| 0x69      | `conv.i4`        | 转换为 `int32`，在堆栈上推送 `int32`                                                       |
| 0x6A      | `conv.i8`        | 转换为 `int64`，在堆栈上推送 `int64`                                                       |
| 0x6B      | `conv.r4`        | 转换为 `float32`，在堆栈上推送 `F`                                                         |
| 0x6C      | `conv.r8`        | 转换为 `float64`，在堆栈上推送 `F`                                                         |
| 0x6D      | `conv.u4`        | 转换为 `unsigned int32`，在堆栈上推送 `int32`                                              |
| 0x6E      | `conv.u8`        | 转换为 `unsigned int64`，在堆栈上推送 `int64`                                              |
| 0x6F      | `callvirt`       | 调用与对象关联的方法                                                                       |
| 0x70      | `cpobj`          | 将值类型从 _src_ 复制到 _dest_                                                             |
| 0x71      | `ldobj`          | 将存储在地址 _src_ 处的值复制到堆栈                                                        |
| 0x72      | `ldstr`          | 将字面 _string_ 的字符串对象推入堆栈                                                       |
| 0x73      | `newobj`         | 分配一个未初始化的对象或值类型并调用 _ctor_                                                |
| 0x74      | `castclass`      | 将 _obj_ 转换为 _typeTok_                                                                  |
| 0x75      | `isinst`         | 测试 _obj_ 是否是 _typeTok_ 的实例，返回 null 或该类或接口的实例                           |
| 0x76      | `conv.r.un`      | 将无符号整数转换为浮点数，将 `F` 推送到堆栈                                                |
| 0x79      | `unbox`          | 从 _obj_ 中提取值类型，这是其装箱表示形式                                                  |
| 0x7A      | `throw`          | 抛出异常                                                                                   |
| 0x7B      | `ldfld`          | 将对象（或值类型）_obj_ 的 _field_ 的值推入堆栈                                            |
| 0x7C      | `ldflda`         | 将对象 _obj_ 的 _field_ 的地址推入堆栈                                                     |
| 0x7D      | `stfld`          | 用 _value_ 替换对象 _obj_ 的 _field_ 的值                                                  |
| 0x7E      | `ldsfld`         | 将 _field_ 的值推入堆栈                                                                    |
| 0x7F      | `ldsflda`        | 将静态字段 _field_ 的地址推入堆栈                                                          |
| 0x80      | `stsfld`         | 用 _val_ 替换 _field_ 的值                                                                 |
| 0x81      | `stobj`          | 将类型为 _typeTok_ 的值存储到地址中                                                        |
| 0x82      | `conv.ovf.i1.un` | 转换为 `int8`（在堆栈上为 `int32`），并在溢出时抛出异常                                    |
| 0x83      | `conv.ovf.i2.un` | 转换为 `int16`（在堆栈上为 `int32`），并在溢出时抛出异常                                   |
| 0x84      | `conv.ovf.i4.un` | 转换为 `int32`（在堆栈上为 `int32`），并在溢出时抛出异常                                   |
| 0x85      | `conv.ovf.i8.un` | 转换为 `int64`（在堆栈上为 `int64`），并在溢出时抛出异常                                   |
| 0x86      | `conv.ovf.u1.un` | 转换为 `unsigned int8`（在堆栈上为 `int32`），并在溢出时抛出异常                           |
| 0x87      | `conv.ovf.u2.un` | 转换为 `unsigned int16`（在堆栈上为 `int32`），并在溢出时抛出异常                          |
| 0x88      | `conv.ovf.u4.un` | 转换为 `unsigned int32`（在堆栈上为 `int32`），并在溢出时抛出异常                          |
| 0x89      | `conv.ovf.u8.un` | 转换为 `unsigned int64`（在堆栈上为 `int64`），并在溢出时抛出异常                          |
| 0x8A      | `conv.ovf.i.un`  | 转换为 `native int`（在堆栈上为 `native int`），并在溢出时抛出异常                         |
| 0x8B      | `conv.ovf.u.un`  | 转换为 `native unsigned int`（在堆栈上为 `native int`），并在溢出时抛出异常                |
| 0x8C      | `box`            | 将可装箱值转换为其装箱形式                                                                 |
| 0x8D      | `newarr`         | 创建一个元素类型为 _etype_ 的新数组                                                        |
| 0x8E      | `ldlen`          | 将数组的长度（类型为 `native unsigned int`）推入堆栈                                       |
| 0x8F      | `ldelema`        | 将索引处的元素的地址加载到堆栈顶部                                                         |
| 0x90      | `ldelem.i1`      | 将类型为 `int8` 的元素在 _index_ 处加载到堆栈顶部，作为 `int32`                            |
| 0x91      | `ldelem.u1`      | 将类型为 `unsigned int8` 的元素在 _index_ 处加载到堆栈顶部，作为 `int32`                   |
| 0x92      | `ldelem.i2`      | 将类型为 `int16` 的元素在 _index_ 处加载到堆栈顶部，作为 `int32`                           |
| 0x93      | `ldelem.u2`      | 将类型为 `unsigned int16` 的元素在 _index_ 处加载到堆栈顶部，作为 `int32`                  |
| 0x94      | `ldelem.i4`      | 将类型为 `int32` 的元素在 _index_ 处加载到堆栈顶部，作为 `int32`                           |
| 0x95      | `ldelem.u4`      | 将类型为 `unsigned int32` 的元素在 _index_ 处加载到堆栈顶部，作为 `int32`                  |
| 0x96      | `ldelem.i8`      | 将类型为 `int64` 的元素在 _index_ 处加载到堆栈顶部，作为 `int64`                           |
| 0x97      | `ldelem.i`       | 将类型为 `native int` 的元素在 _index_ 处加载到堆栈顶部，作为 `native int`                 |
| 0x98      | `ldelem.r4`      | 将类型为 `float32` 的元素在 _index_ 处加载到堆栈顶部，作为 `F`                             |
| 0x99      | `ldelem.r8`      | 将类型为 `float64` 的元素在 _index_ 处加载到堆栈顶部，作为 `F`                             |
| 0x9A      | `ldelem.ref`     | 将 _index_ 处的元素加载到堆栈顶部，作为 `O`。`O` 的类型与推入 CIL 堆栈的数组的元素类型相同 |
| 0x9B      | `stelem.i`       | 用堆栈上的 `native int` _value_ 替换数组中 _index_ 处的元素                                |
| 0x9C      | `stelem.i1`      | 用堆栈上的 `int8` _value_ 替换数组中 _index_ 处的元素                                      |
| 0x9D      | `stelem.i2`      | 用堆栈上的 `int16` _value_ 替换数组中 _index_ 处的元素                                     |
| 0x9E      | `stelem.i4`      | 用堆栈上的 `int32` _value_ 替换数组中 _index_ 处的元素                                     |
| 0x9F      | `stelem.i8`      | 用堆栈上的 `int64` _value_ 替换数组中 _index_ 处的元素                                     |
| 0xA0      | `stelem.r4`      | 用堆栈上的 `float32` _value_ 替换数组中 _index_ 处的元素                                   |
| 0xA1      | `stelem.r8`      | 用堆栈上的 `float64` _value_ 替换数组中 _index_ 处的元素                                   |
| 0xA2      | `stelem.ref`     | 用堆栈上的 ref _value_ 替换数组中 _index_ 处的元素                                         |
| 0xA3      | `ldelem`         | 将索引处的元素加载到堆栈顶部                                                               |
| 0xA4      | `stelem`         | 用堆栈上的值替换数组中 _index_ 处的元素                                                    |
| 0xA5      | `unbox.any`      | 从 _obj_ 中提取值类型，这是其装箱表示形式                                                  |
| 0xB3      | `conv.ovf.i1`    | 转换为 `int8`（在堆栈上为 `int32`），并在溢出时抛出异常                                    |
| 0xB4      | `conv.ovf.u1`    | 转换为 `unsigned int8`（在堆栈上为 `int32`），并在溢出时抛出异常                           |
| 0xB5      | `conv.ovf.i2`    | 转换为 `int16`（在堆栈上为 `int32`），并在溢出时抛出异常                                   |
| 0xB6      | `conv.ovf.u2`    | 转换为 `unsigned int16`（在堆栈上为 `int32`），并在溢出时抛出异常                          |
| 0xB7      | `conv.ovf.i4`    | 转换为 `int32`（在堆栈上为 `int32`），并在溢出时抛出异常                                   |
| 0xB8      | `conv.ovf.u4`    | 转换为 `unsigned int32`（在堆栈上为 `int32`），并在溢出时抛出异常                          |
| 0xB9      | `conv.ovf.i8`    | 转换为 `int64`（在堆栈上为 `int64`），并在溢出时抛出异常                                   |
| 0xBA      | `conv.ovf.u8`    | 转换为 `unsigned int64`（在堆栈上为 `int64`），并在溢出时抛出异常                          |
| 0xC2      | `refanyval`      | 推送存储在类型引用中的地址                                                                 |
| 0xC3      | `ckfinite`       | 如果 _value_ 不是有限数，抛出 `ArithmeticException` 异常                                   |
| 0xC6      | `mkrefany`       | 将类型为 _class_ 的 _ptr_ 的类型引用推入堆栈                                               |
| 0xD0      | `ldtoken`        | 将元数据 *token* 转换为其运行时表示                                                        |
| 0xD1      | `conv.u2`        | 转换为 `unsigned int16`，在堆栈上推送 `int32`                                              |
| 0xD2      | `conv.u1`        | 转换为 `unsigned int8`，在堆栈上推送 `int32`                                               |
| 0xD3      | `conv.i`         | 转换为 `native int`，在堆栈上推送 `native int`                                             |
| 0xD4      | `conv.ovf.i`     | 转换为 `native int`（在堆栈上为 `native int`），并在溢出时抛出异常                         |
| 0xD5      | `conv.ovf.u`     | 转换为 `native unsigned int`（在堆栈上为 `native int`），并在溢出时抛出异常                |
| 0xD6      | `add.ovf`        | 添加带有溢出检查的有符号整数值                                                             |
| 0xD7      | `add.ovf.un`     | 添加带有溢出检查的无符号整数值                                                             |
| 0xD8      | `mul.ovf`        | 乘以有符号整数值。有符号结果应适合相同的大小                                               |
| 0xD9      | `mul.ovf.un`     | 乘以无符号整数值。无符号结果应适合相同的大小                                               |
| 0xDA      | `sub.ovf`        | 从一个 native int 中减去另一个 native int。有符号结果应适合相同的大小                      |
| 0xDB      | `sub.ovf.un`     | 从一个 native unsigned int 中减去另一个 native unsigned int。无符号结果应适合相同的大小    |
| 0xDC      | `endfinally`     | 结束异常块的 **finally** 子句                                                              |
| 0xDD      | `leave`          | 退出代码的受保护区域                                                                       |
| 0xDE      | `leave.s`        | 退出代码的受保护区域，短格式                                                               |
| 0xDF      | `stind.i`        | 将类型为 `native int` 的值存储到 _address_ 处的内存中                                      |
| 0xE0      | `conv.u`         | 转换为 `native unsigned int`，在堆栈上推送 `native int`                                    |
| 0xFE 0x00 | `arglist`        | 返回当前方法的参数列表句柄                                                                 |
| 0xFE 0x01 | `ceq`            | 如果 _value1_ 等于 _value2_，则推送 1（类型为 `int32`），否则推送 0                        |
| 0xFE 0x02 | `cgt`            | 如果 _value1_ > _value2_，则推送 1（类型为 `int32`），否则推送 0                           |
| 0xFE 0x03 | `cgt.un`         | 如果 _value1_ > _value2_，无符号或无序，推送 1（类型为 `int32`），否则推送 0               |
| 0xFE 0x04 | `clt`            | 如果 _value1_ < _value2_，推送 1（类型为 `int32`），否则推送 0                             |
| 0xFE 0x05 | `clt.un`         | 如果 _value1_ < _value2_，无符号或无序，推送 1（类型为 `int32`），否则推送 0               |
| 0xFE 0x06 | `ldftn`          | 将一个指向由 _method_ 引用的方法的指针推送到堆栈                                           |
| 0xFE 0x07 | `ldvirtftn`      | 将虚方法 *method* 的地址推入堆栈                                                           |
| 0xFE 0x09 | `ldarg`          | 将编号为 _num_ 的参数加载到堆栈                                                            |
| 0xFE 0x0A | `ldarga`         | 获取参数 _argNum_ 的地址                                                                   |
| 0xFE 0x0B | `starg`          | 将值存储到编号为 _num_ 的参数中                                                            |
| 0xFE 0x0C | `ldloc`          | 将索引为 _indx_ 的局部变量加载到堆栈                                                       |
| 0xFE 0x0D | `ldloca`         | 加载索引为 _indx_ 的局部变量的地址                                                         |
| 0xFE 0x0E | `stloc`          | 将值从堆栈弹出到局部变量 _indx_                                                            |
| 0xFE 0x0F | `localloc`       | 从局部内存池分配空间                                                                       |
| 0xFE 0x11 | `endfilter`      | 结束异常处理过滤器子句                                                                     |
| 0xFE 0x12 | `unaligned.`     | 后续指针指令可能不对齐                                                                     |
| 0xFE 0x13 | `volatile.`      | 后续指针引用是易变的                                                                       |
| 0xFE 0x14 | `tail.`          | 后续调用终止当前方法                                                                       |
| 0xFE 0x15 | `initobj`        | 初始化地址 _dest_ 处的值                                                                   |
| 0xFE 0x16 | `constrained.`   | 在被约束为类型 `T` 的类型上调用虚方法                                                      |
| 0xFE 0x17 | `cpblk`          | 从内存复制数据到内存                                                                       |
| 0xFE 0x18 | `initblk`        | 将一块内存的所有字节设置为给定的字节值                                                     |
| 0xFE 0x19 | `no.`            | 在执行后续指令的过程中，通常执行的指定错误检查可以 / 应该被跳过                            |
| 0xFE 0x1A | `rethrow`        | 重新抛出当前异常                                                                           |
| 0xFE 0x1C | `sizeof`         | 以 `unsigned int32` 的形式推送类型的字节大小                                               |
| 0xFE 0x1D | `refanytype`     | 推送存储在类型引用中的类型标记                                                             |
| 0xFE 0x1E | `readonly.`      | 指定后续数组地址操作在运行时不执行类型检查，并且它返回一个可控易变托管指针                 |

>---
### 堆栈转换图
<a id="stack-img"></a>

堆栈转换图显示了指令执行前后的求值堆栈状态。以下是一个典型的堆栈转换图。

&hellip;, _value1_, _value2_ &rarr; &hellip;, _result_

此图表表示堆栈上应至少有两个元素，并且在定义中，最顶部的值（"堆栈顶部" 或 "最近推送"）将被称为 _value2_，下面的值（在 _value2_ 之前推送）将被称为 _value1_。（在这样的图表中，堆栈向右侧，即页面的横向增长）。使用指令后将从堆栈中移除这些值，并用另一个值替换它们，在描述中称为 _result_。

>---
### 操作数类型表
<a id="Operand-type-table"></a>

许多 CIL 操作在堆栈上接受数字操作数。这些操作分为几个类别，取决于它们如何处理操作数的类型。以下表格总结了有效的操作数类型和结果类型。注意，这里所说的类型是 CLI 跟踪的类型，而不是 CIL 验证等工具使用的更详细的类型。CLI 跟踪的类型有：`int32`，`int64`，`native int`，`F`，`O` 和 `&`。

#### 二元数值操作
<a id="OpTable2"></a>

下表显示了 A `op` B 的结果类型 —— 其中 `op` 是 `add`，`div`，`mul`，`rem` 或 `sub` —— 对于每种可能的操作数类型组合。只包含结果类型的框适用于这五个指令。标有 &cross; 的框表示无效的 CIL 指令。<ins>标有 <sup>nv</sup> 的框</ins> 表示不可验证的 CIL 指令。带有指令列表的框表示只对那些指令有效。

 | A \ B            | **`int32`**                            | **`int64`** | **`native int`**                       | **`F`** | **`&`**                                  | **`O`** |
 | ---------------- | -------------------------------------- | ----------- | -------------------------------------- | ------- | ---------------------------------------- | ------- |
 | **`int32`**      | `int32`                                | &cross;     | `native int`                           | &cross; | `&` (`add`) <sup>nv</sup></ins>          | &cross; |
 | **`int64`**      | &cross;                                | `int64`     | &cross;                                | &cross; | &cross;                                  | &cross; |
 | **`native int`** | `native int`                           | &cross;     | `native int`                           | &cross; | `&` (`add`) <sup>nv</sup></ins>          | &cross; |
 | **`F`**          | &cross;                                | &cross;     | &cross;                                | `F`     | &cross;                                  | &cross; |
 | **`&`**          | `&` (`add`, `sub`) <sup>nv</sup></ins> | &cross;     | `&` (`add`, `sub`) <sup>nv</sup></ins> | &cross; | `native int` (`sub`) <sup>nv</sup></ins> | &cross; |
 | **`O`**          | &cross;                                | &cross;     | &cross;                                | &cross; | &cross;                                  | &cross; |

#### 一元数值操作
<a id="OpTable3"></a>

下表显示了一元数值操作的结果类型。用于 `neg` 指令。标有 &cross; 的框表示无效的 CIL 指令。此指令的所有有效用法都是可验证的。

 | Operand Type | Result Type  |
 | ------------ | ------------ |
 | `int32`      | `int32`      |
 | `int64`      | `int64`      |
 | `native int` | `native int` |
 | `F`          | `F`          |
 | `&`          | &cross;      |
 | `O`          | &cross;      |

#### 二元比较或分支操作
<a id="OpTable4"></a>

下表显示了比较和分支指令的结果类型。二元比较返回一个布尔值，分支操作基于堆栈上的前两个值进行分支。用于 `beq`，`beq.s`，`bge`，`bge.s`，`bge.un`，`bge.un.s`，`bgt`，`bgt.s`，`bgt.un`，`bgt.un.s`，`ble`，`ble.s`，`ble.un`，`ble.un.s`，`blt`，`blt.s`，`blt.un`，`blt.un.s`，`bne.un`，`bne.un.s`，`ceq`，`cgt`，`cgt.un`，`clt`，`clt.un`。标有 &check; 的框表示所有指令对于该操作数类型组合都是有效的。标有 &cross; 的框表示无效的 CIL 序列。<ins>标有 <sup>nv</sup> 的框</ins> 表示不可验证的 CIL 指令。带有指令列表的框只对那些指令有效。

 | A \ B            | `int32` | `int64` | `native int`                                 | `F`     | `&`                                          | `O`                                         |
 | ---------------- | ------- | ------- | -------------------------------------------- | ------- | -------------------------------------------- | ------------------------------------------- |
 | **`int32`**      | &check; | &cross; | &check;                                      | &cross; | &cross;                                      | &cross;                                     |
 | **`int64`**      | &cross; | &check; | &cross;                                      | &cross; | &cross;                                      | &cross;                                     |
 | **`native int`** | &check; | &cross; | &check;                                      | &cross; | `beq[.s]`, `bne.un[.s]`, `ceq` <sup>nv</sup> | &cross;                                     |
 | **`F`**          | &cross; | &cross; | &cross;                                      | &check; | &cross;                                      | &cross;                                     |
 | **`&`**          | &cross; | &cross; | `beq[.s]`, `bne.un[.s]`, `ceq` <sup>nv</sup> | &cross; | &check; <sup>1</sup>                         | &cross;                                     |
 | **`O`**          | &cross; | &cross; | &cross;                                      | &cross; | &cross;                                      | `beq[.s]`, `bne.un[.s]`, `ceq` <sup>2</sup> |

<sup>1</sup> 除了 `beq`，`bne.un`，`beq.s`，`bne.un.s` 或 `ceq`，如果两个操作数都已知为指向同一数组元素的指针，那么这些组合是有意义的。然而，对于不检查此约束的 CLI，没有安全问题。如果两个操作数不是指向同一数组的指针，那么结果就是两个无关数据项在垃圾收集堆中的距离。这个距离几乎肯定会在下一次垃圾收集时改变。本质上，此结果不能用来计算任何有用的东西。

<sup>2</sup> `cgt.un` 在 **ObjectRefs** (`O`) 上是允许的并且可以验证的。这通常用于将 **ObjectRef** 与 `null` 进行比较（没有 "compare-not-equal" 指令，否则这将是一个更明显的解决方案）

#### 整数操作
<a id="OpTable5"></a>

下表显示了整数操作中每种可能的操作数类型组合的结果类型。用于 `and`，`div.un`，`not`，`or`，`rem.un`，`xor`。`div.un` 和 `rem.un` 指令将其操作数视为无符号整数，并产生对应于无符号结果的位模式。然而，如 CLI 标准所述，CLI 不区分堆栈上的有符号和无符号整数。`not` 指令是一元的，并返回与输入相同的类型。`shl` 和 `shr` 指令返回与其第一个操作数相同的类型，其第二个操作数应为 `int32` 或 `native int` 类型。标有 &cross; 的框表示无效的 CIL 序列。所有其他框表示可验证的操作数组合。

| A \ B            | `int32`      | `int64` | `native int` | `F`     | `&`     | `O`     |
| ---------------- | ------------ | ------- | ------------ | ------- | ------- | ------- |
| **`int32`**      | `int32`      | &cross; | `native int` | &cross; | &cross; | &cross; |
| **`int64`**      | &cross;      | `int64` | &cross;      | &cross; | &cross; | &cross; |
| **`native int`** | `native int` | &cross; | `native int` | &cross; | &cross; | &cross; |
| **`F`**          | &cross;      | &cross; | &cross;      | &cross; | &cross; | &cross; |
| **`&`**          | &cross;      | &cross; | &cross;      | &cross; | &cross; | &cross; |
| **`O`**          | &cross;      | &cross; | &cross;      | &cross; | &cross; | &cross; |

#### 移位操作
<a id="OpTable6"></a>

下表显示了移位指令：`shl`，`shr`，`shr.un` 的有效操作数和结果的组合。标有 &cross; 的框表示无效的 CIL 序列。所有其他框表示可验证的操作数组合。如果 "Shift-By" 操作数大于 "To-Be-Shifted" 操作数的宽度，那么结果是未指定的。例如，将 `int32` 整数左移 37 位。

 | **To Be Shifted** \ Shift-By | **`int32`**  | **`int64`** | **`native int`** | **`F`** | **`&`** | **`O`** |
 | ---------------------------- | ------------ | ----------- | ---------------- | ------- | ------- | ------- |
 | **`int32`**                  | `int32`      | &cross;     | `int32`          | &cross; | &cross; | &cross; |
 | **`int64`**                  | `int64`      | &cross;     | `int64`          | &cross; | &cross; | &cross; |
 | **`native int`**             | `native int` | &cross;     | `native int`     | &cross; | &cross; | &cross; |
 | **`F`**                      | &cross;      | &cross;     | &cross;          | &cross; | &cross; | &cross; |
 | **`&`**                      | &cross;      | &cross;     | &cross;          | &cross; | &cross; | &cross; |
 | **`O`**                      | &cross;      | &cross;     | &cross;          | &cross; | &cross; | &cross; |

#### 溢出算术运算
<a id="OpTable7"></a>

下表显示了带有溢出检查的算术操作中每种可能的操作数类型组合的结果类型。如果结果不能表示为结果类型，将抛出异常。用于 `add.ovf`，`add.ovf.un`，`mul.ovf`，`mul.ovf.un`，`sub.ovf` 和 `sub.ovf.un`。有关抛出的异常的详细信息，请参阅特定指令的描述。<ins>标有 <sup>nv</sup> 的框</ins> 的是不可验证的，而标有 &cross; 的框表示无效的 CIL 序列。

 | A \ B            | **`int32`**                                  | **`int64`** | **`native int`**                             | **`F`** | **`&`**                                 | **`O`** |
 | ---------------- | -------------------------------------------- | ----------- | -------------------------------------------- | ------- | --------------------------------------- | ------- |
 | **`int32`**      | `int32`                                      | &cross;     | `native int`                                 | &cross; | `&` `add.ovf.un` <sup>nv</sup>          | &cross; |
 | **`int64`**      | &cross;                                      | `int64`     | &cross;                                      | &cross; | &cross;                                 | &cross; |
 | **`native int`** | `native int`                                 | &cross;     | `native int`                                 | &cross; | `&` `add.ovf.un` <sup>nv</sup>          | &cross; |
 | **`F`**          | &cross;                                      | &cross;     | &cross;                                      | &cross; | &cross;                                 | &cross; |
 | **`&`**          | `&` `add.ovf.un`, `sub.ovf.un` <sup>nv</sup> | &cross;     | `&` `add.ovf.un`, `sub.ovf.un` <sup>nv</sup> | &cross; | `native int` `sub.ovf.un` <sup>nv</sup> | &cross; |
 | **`O`**          | &cross;                                      | &cross;     | &cross;                                      | &cross; | &cross;                                 | &cross; |

#### 转换操作
<a id="OpTable8"></a>

下表显示了转换操作的结果类型。转换操作将求值堆栈顶部的项从一个数值类型转换为另一个数值类型。在转换过程中，如表中所示，会发生截断或扩展。结果类型保证可以表示为操作指定的数据类型（即，`conv.u2` 指令返回一个可以存储在 `unsigned int16` 中的值）。然而，堆栈只能存储最小为 4 字节宽的值。用于 `conv.<to type>`，`conv.ovf.<to type>`，和 `conv.ovf.<to type>.un` 指令。<ins>标有 <sup>nv</sup> 的框</ins> 的是不可验证的，而标有 &cross; 的框表示无效的 CIL 序列。

 | Convert-To \ Input                                                          | **`int32`**          | **`int64`**          | **`native int`**     | **`F`**                      | **`&`**                         | **`O`**                         |
 | --------------------------------------------------------------------------- | -------------------- | -------------------- | -------------------- | ---------------------------- | ------------------------------- | ------------------------------- |
 | **`int8`**,<br>**`unsigned int8`**,<br>**`int16`**,<br>**`unsigned int16`** | Truncate<sup>1</sup> | Truncate<sup>1</sup> | Truncate<sup>1</sup> | Truncate to zero<sup>2</sup> | &cross;                         | &cross;                         |
 | **`int32`**,<br>**`unsigned int32`**                                        | Nop                  | Truncate<sup>1</sup> | Truncate<sup>1</sup> | Truncate to zero<sup>2</sup> | &cross;                         | &cross;                         |
 | **`int64`**                                                                 | Sign extend          | Nop                  | Sign extend          | Truncate to zero<sup>2</sup> | Stop GC tracking<sup>nv</sup>   | Stop GC tracking<sup>nv</sup>   |
 | **`unsigned int64`**                                                        | Zero extend          | Nop                  | Zero extend          | Truncate to zero<sup>2</sup> | Stop GC tracking<sup>4,nv</sup> | Stop GC tracking<sup>4,nv</sup> |
 | **`native int`**                                                            | Sign extend          | Truncate<sup>1</sup> | Nop                  | Truncate to zero<sup>2</sup> | Stop GC tracking<sup>4,nv</sup> | Stop GC tracking<sup>4,nv</sup> |
 | **`native unsigned int`**                                                   | Zero extend          | Truncate<sup>1</sup> | Nop                  | Truncate to zero<sup>2</sup> | Stop GC tracking<sup>4,nv</sup> | Stop GC tracking<sup>4,nv</sup> |
 | **All Float Types**                                                         | To Float             | To Float             | To Float             | Change precision<sup>3</sup> | &cross;                         | &cross;                         |


<sup>1</sup> "Truncate" 的意思是将数字截断到所需的大小（即，输入值的最重要的字节被简单地忽略）。如果结果比最小堆栈宽度的 4 字节还要窄，那么这个结果就会被零扩展（如果结果类型是无符号的）或符号扩展（如果结果类型是有符号的）。因此，将值 `0x1234 ABCD` 从求值堆栈转换为 8 位数据产生的结果是 `0xCD`；如果结果类型是 `int8`，这将被符号扩展为 `0xFFFF FFCD`；如果结果类型是 `unsigned int8`，这将被零扩展为 `0x0000 00CD`。

<sup>2</sup> "Truncate to zero" 的意思是，浮点数将通过向零截断转换为整数。因此，1.1 被转换为 1，-1.1 被转换为 -1。

<sup>3</sup> 从求值堆栈上当前可用的精度转换为指令指定的精度。如果堆栈的精度比输出大小更高，那么将使用 IEC 60559:1989 的 "最接近舍入" 模式来计算结果的低位。

<sup>4</sup> "Stop GC tracking" 的意思是，转换后，该项的值将不会被报告给后续的垃圾收集操作（因此，这些操作不会更新该项的值）。

从整数到 `F` 的转换和从 `F` 到整数的转换的舍入模式与算术运算相同。

>---
### 隐式参数强制转换
<a id="OpTable9"></a>

方法调用涉及到在堆栈上的参数值被隐式地分配给被调用方法的参数（使用 `ldarg` 或 `ldarga`，指令访问）。这个分配是一个隐式的 `starg` 指令，可以被称为 *隐式参数强制转换* (_implicit argument coercion_)。在验证的 CLI 中，隐式参数强制转换的有效性，就像 `starg` 指令一样，由验证器可赋值关系（§[[↗]](#Verification-type-compatibility)）确定。正确的 CIL 也允许一个 `native int` 作为一个 **byref**（`&`）传递；在这种情况下，随后的隐式转换后，该值将被垃圾收集跟踪。

虽然 CLI 只操作 6 种类型（`int32`，`native int`，`int64`，`F`，`O` 和 `&`），但元数据为方法的参数提供了更丰富的模型。当准备调用一个方法时，CLI 执行隐式类型转换，详细信息在下表中。（从概念上讲，它将适当的 `conv.*` 指令插入到 CIL 流中，这可能会导致信息丢失，通过截断或舍入）这种隐式转换发生在标记为 &check; 的框中。<ins>标记为 <sup>nv</sup> 的框</ins> 是不可验证的。标记为 &cross; 的框表示无效的 CIL 序列。编译器可以自由地发出显式的 `conv.*` 或 `conv.*.ovf` 指令以达到任何期望的效果。

 | Type In Signature \ Stack Parameter      | **`int32`**            | **`native int`**                          | **`int64`**              | **`F`** | **`&`** | **`O`** | **value type**<sup>1</sup> |
 | ---------------------------------------- | ---------------------- | ----------------------------------------- | ------------------------ | ------- | ------- | ------- | -------------------------- |
 | **`int8`**                               | &check;<br>Truncate    | &check;<br>Truncate                       | &cross;                  | &cross; | &cross; | &cross; | &cross;                    |
 | **`unsigned int8`**,<br>**`bool`**       | &check;<br>Truncate    | &check;<br>Truncate                       | &cross;                  | &cross; | &cross; | &cross; | &cross;                    |
 | **`int16`**                              | &check;<br>Truncate    | &check;<br>Truncate                       | &cross;                  | &cross; | &cross; | &cross; | &cross;                    |
 | **`unsigned int16`**,<br>**`char`**      | &check;<br>Truncate    | &check;<br>Truncate                       | &cross;                  | &cross; | &cross; | &cross; | &cross;                    |
 | **`int32`**                              | &check;<br>Nop         | &check;<br>Truncate                       | &cross;                  | &cross; | &cross; | &cross; | &cross;                    |
 | **`unsigned int32`**                     | &check;<br>Nop         | &check;<br>Truncate                       | &cross;                  | &cross; | &cross; | &cross; | &cross;                    |
 | **`int64`**                              | &cross;                | &cross;                                   | &check;<br>Nop           | &cross; | &cross; | &cross; | &cross;                    |
 | **`unsigned int64`**                     | &cross;                | &cross;                                   | &check;<br>Nop           | &cross; | &cross; | &cross; | &cross;                    |
 | **`native int`**                         | &check;<br>Sign extend | &check;<br>Nop                            | &cross;                  | &cross; | &cross; | &cross; | &cross;                    |
 | **`native unsigned int`**                | &check;<br>Zero extend | &check;<br>Nop                            | &cross;                  | &cross; | &cross; | &cross; | &cross;                    |
 | **`float32`**                            | &cross;                | &cross;                                   | &cross; Note<sup>4</sup> | &cross; | &cross; | &cross; | &cross;                    |
 | **`float64`**                            | &cross;                | &cross;                                   | &cross; Note<sup>4</sup> | &cross; | &cross; | &cross; | &cross;                    |
 | **Class**                                | &cross;                | &cross;                                   | &cross;                  | &cross; | &cross; | &check; | &cross;                    |
 | **Value Type**<sup>1</sup>               | &cross;                | &cross;                                   | &cross;                  | &cross; | &cross; | &cross; | &check;<sup>2</sup>        |
 | **By-reference (Byref) (`&`)**           | &cross;                | &check;<br>Start GC tracking<sup>nv</sup> | &cross;                  | &cross; | &check; | &cross; | &cross;                    |
 | **Typed Reference (RefAny)<sup>3</sup>** | &cross;                | &cross;                                   | &cross;                  | &cross; | &cross; | &cross; | &cross;                    |

<sup>1</sup> 签名中的值类型不能是内置类型的长形式（§[[↗]](./02_CLI%20元数据定义和语义.md/#MethodSpec-blob)）。

<sup>2</sup> CLI 的堆栈可以包含一个值类型。这些只能在堆栈上的特定值类型与所需的值类型完全匹配的情况下传递。

<sup>3</sup> 有特殊的指令来构造和传递一个 `RefAny`。

<sup>4</sup> CLI 允许使用其内部的 `F` 类型传递浮点参数，参见 §[_数值数据类型_](#numeric-data-types)。CIL 生成器当然可以包含一个显式的 `conv.r4`，`conv.r4.ovf` 或类似的指令。

关于这个表的进一步说明：
* "Truncate" 表示截断；"Nop" 意味着没有转换被执行。
* "Start GC tracking" 意味着，在隐式转换后，该项的值将被报告给任何后续的垃圾收集操作，并且可能由于指向的项在堆中被重新定位而改变。

>---
### 对 CIL 代码序列的限制
<a id=""></a>

对 CIL 代码序列的详细限制，以确保:
- 正确的 CIL
- 可验证的 CIL

还有一些进一步的限制，这些限制是为了更容易地构建一个简单的 CIL-to-native-code 的编译器。本小节规定了适用于单个指令的一般限制。

#### 指令流

方法的实现由一块连续的 CIL 指令提供，编码方式如下所述。方法的指令块的地址以及其长度在文件格式中有所指定（参见 第二部分 [_CIL 物理布局_](./02_CLI%20元数据定义和语义.md/#metadata-physical-layout)）。第一条指令位于指令块的第一个字节（最低地址）。

指令的大小是可变的。每条指令的大小可以从指令字节的内容中确定（解码）。指令内部字节的大小和顺序由每个指令定义指定。指令在一个既不需要对齐也不敏感于字节顺序的字节流中连续跟随，没有填充。

每条指令占用确切的字节数，直到指令块的结束，下一条指令立即开始于下一个字节。如果指令块（由块的长度指定）在没有形成完整的最后一条指令的情况下结束，那么就是无效的。

指令前缀扩展了指令的长度，而没有引入新的指令；一个有一个或多个前缀的指令只引入了一个指令，该指令从第一个指令前缀的第一个字节开始。

直到指令块的结束，任何控制转移指令后面的指令都被解码为一条指令，从而参与后续指令的定位，即使它不是分支的目标。只有指令可以出现在指令流中，即使无法到达。没有与地址相关的数据寻址模式，原始数据不能直接嵌入到指令流中。某些指令允许将即时数据作为指令的一部分嵌入，然而这与允许在指令流中直接嵌入原始数据是不同的。无法到达的代码可以作为机器生成的代码的结果出现，并且是允许的，但它必须始终以正确形成指令序列的形式出现。

指令流可以被翻译，相关的指令块在执行翻译之前被丢弃。因此，即使是捕获和操作代码地址的指令，如 `call`，`ret` 等，也可以被虚拟化，以便在翻译的地址上操作，而不是在 CIL 指令流的地址上操作。

#### 有效的分支目标
<a id="valid-branch"></a>

由指令流中识别的每条指令的第一个字节组成的地址集合定义了唯一有效的指令目标。指令目标包括分支指令中指定的分支目标，异常表中指定的目标，如保护范围、过滤器和处理程序目标。

分支指令将分支目标指定为 1 字节或 4 字节的有符号相对偏移量；偏移量的大小由指令的操作码区分。偏移量被定义为相对于分支指令后面的字节。因此，偏移量为零的值目标是紧随其后的指令。1 字节偏移量的值是通过将该字节解释为有符号的 8 位整数来计算的。

4 字节偏移量的值可以通过将字节连接成一个有符号的整数来计算，方式如下：最低地址的字节形成整数的最低有效字节，最高地址的字节形成整数的最高有效字节。这种表示法通常被称为 "小端字节序的有符号整数"。

#### 异常范围

异常表描述了由 `catch`，`fault` 或 `finally` 处理程序保护的指令范围。受保护块，过滤子句或处理程序的起始地址应为 §[[↗]](#valid-branch) 中指定的有效分支目标。如果受保护块，过滤子句或处理程序在没有形成完整的最后一条指令的情况下结束，那么就是无效的。

#### 必须提供 maxstack
<a id="maxstack"></a>

每个方法都指定了可以推送到 CIL 求值堆栈上的元素的最大数量。该值存储在 *`IMAGE_COR_ILMETHOD`* 结构中，该结构位于每个方法的 CIL 主体之前。一个方法如果指定的元素最大数量小于方法的静态分析所需的数量（使用传统的控制流图，不分析数据），那么它就是无效的（因此也是不可验证的），并且不需要由符合 CLI 规范的实现来支持。

***Maxstack*** 与程序的分析相关，而不是与运行时堆栈的大小相关。它并没有指定堆栈帧的最大字节大小，而是指定了分析工具应该跟踪的元素的数量。
 
通过分析任何方法的 CIL 流，很容易确定将有多少元素被推送到 CIL 求值堆栈上。然而，提前指定最大数量有助于 CIL-to-native-code 编译器（特别是只通过 CIL 流进行一次遍历的简单编译器）在分配模拟堆栈和 / 或验证算法的内部数据结构。

#### 后向分支约束

对于任何方法，只要在 CIL 指令流中进行一次前向遍历，就有可能推断出每条指令的求值堆栈的确切状态 (这里的 “状态” 是指求值堆栈上每个元素的数量和类型)。

特别地，如果该单次遍历分析到达一个指令，称为位置 X，它紧随在无条件分支之后，并且 X 不是前向分支指令的目标，那么就无法从现有信息中推断出 X 处的求值堆栈状态。在这种情况下，CLI 要求 X 处的求值堆栈为空。

根据这个规则，如果后向分支指令到 X 处的求值堆栈非空，那么它显然是无效的 CIL。

这个约束确保 CIL 代码可以被一个简单的 CIL-to-native-code 编译器处理。它确保每个 CIL 开始时的求值堆栈状态可以从指令流的单次前向遍历分析中推断出来。

上述位置 X 处的堆栈状态可以通过各种方式推断：从前向分支到 X；因为 X 标记了异常处理程序的开始，等等。

有关进一步信息，请参见以下内容：

 * 异常：§[[↗]](./01_CLI%20基本概念和体系结构.md/#exception-handle)
 * 分支指令的验证条件：§[III.3【】]()
 * `tail.` 前缀：§[III.3.19【】]()

#### 分支验证约束

所有分支指令的目标应为该分支指令所在方法内的有效分支目标（参见 §[[↗]](#valid-branch)）。

>---
### 可验证性和正确性
<a id="Verifiability"></a>

内存安全是一种确保在同一地址空间运行的程序彼此正确隔离的属性。因此，希望在运行程序之前测试程序是否具有内存安全性。但是以 100% 的准确性做到这一点是不可能的。相反，CLI 可以测试一个更强的限制，称为 *可验证性* (_verifiability_)。每个被验证的程序都是内存安全的，但是一些不可验证的程序仍然是内存安全的。

正确的 CIL 是在所有符合 CLI 的实现上执行的 CIL，其行为如本标准所指定的那样具有良好的定义。然而，正确的 CIL 不必在所有符合的实现中产生相同的行为；也就是说，行为可以是特定于实现的。

生成不可验证但已知内存安全的正确 CIL 代码是完全可以接受的，这是由编译器编写者知道的。因此，即使生成的编译器 *知道* 它是内存安全的，正确的 CIL 也可能不可验证。CIL 指令的几个重要用途是不可验证的，例如 `add` 的指针算术版本，这是对 C 程序的忠实和高效编译所必需的。对于不可验证的代码，内存安全性是应用程序员的责任。

正确的 CIL 包含一个 *可验证的子集*。可验证性描述详细说明了指令使用在何种条件下是属于可验证的 CIL 子集。验证比 CLI 的基本功能更详细地跟踪值的类型，因为它检查 CIL 代码序列是否遵守 CLI 关于垃圾收集安全性的基本规则，并且是否还遵守 CTS 的类型规则。这有助于保证整个 CLI 的稳定运行。

每个操作描述的可验证性部分指定了正确生成 CIL 和验证的要求。正确的 CIL 生成始终需要保证堆栈顶部的元素对应于堆栈转换图中显示的类型。可验证性部分只指定了在该图中未捕获的正确 CIL 生成的需求。验证测试正确生成 CIL 的需求和指令中描述的特定验证条件。不满足 CIL 正确性要求的 CIL 序列的操作是未指定的。满足正确性要求但不可验证的 CIL 序列的操作，可能会违反类型安全性，因此也可能会违反安全性或内存访问约束。有关更多信息，请参见第二部分 [_验证和校验_](./02_CLI%20元数据定义和语义.md/#validation-and-verification)。

#### 可验证 CIL 的流控制限制

本小节指定了一个验证算法，该算法结合了关于单个 CIL 指令的信息（参见 §[[↗]](#base-ins)）和元数据验证，保证了内存完整性。

这里指定的算法为所有符合 CLI 的实现创建了一个最低级别，意味着任何被这个算法认为是可验证的程序都应被认为是可验证的，并且在所有符合 CLI 的实现上正确运行。

CLI 提供了一个安全权限（参见[Partition IV](【】)），用于控制 CLI 是否可以运行可能违反内存安全性的程序。任何根据这个标准可验证的程序都不会违反内存安全性，符合 CLI 的实现能够运行这样的程序。实现也可能运行其他程序，只要它能够显示它们不违反内存安全性（通常是因为它们使用了一种利用有关实现的特定存储信息的验证算法）。

虽然一个符合的实现需要接受并运行任何这个验证算法认为是可验证的程序，但可能有一些程序被一个给定的实现接受为可验证，但这个验证算法会认为它们不可验证。这样的程序将在给定的实现中运行，但不必被其他实现认为是可验证的。

CLI 的实现者被要求提供一种测试方法，以确定他们的实现生成的程序是否满足这个可移植的可验证性标准。他们也被要求详细说明他们的验证算法在哪些地方比这个标准更宽松。

只有有效的程序才能被验证。为了便于解释，这里描述的验证算法假设程序是有效的，并且并没有明确要求测试所有的有效性条件。有效性条件是在每个 CIL 指令的基础上指定的（参见 §[_基本指令_](#base-ins)）。

##### 验证算法

验证算法将尝试把一个有效的堆栈状态与每个 CIL 指令关联起来。堆栈状态指定了代码中该点上 CIL 堆栈上的槽数量，以及每个槽中应存在的所需类型。初始堆栈状态为空（堆栈上没有元素）。

验证假设 CLI 在对程序可见之前将除了求值堆栈之外的所有内存归零。符合 CLI 规范的实现应提供这种可观测的行为。此外，可验证的方法应设置 `localsinit` 位，参见第二部分的 [_Method Header Flags_](./02_CLI%20元数据定义和语义.md/#method-header)。如果没有设置这个位，那么 CLI 可能在访问局部变量的任何地方抛出一个验证异常，并且包含该方法的程序集没有被授予 _SecurityPermission.SkipVerification_。

这个要求极大增强了程序的可移植性，一个众所周知的技术（明确赋值分析）允许 CIL-to-native-code 编译器将其性能影响降至最低。注意，CLI 可能选择执行明确赋值分析 —— 在这种情况下，它可能确定一个方法即使没有设置 `localsinit` 位，实际上也可能是可验证的（因此不会抛出验证异常）。

CLI 可以使用明确赋值分析来确定哪些位置在读取之前被写入。这样的位置不需要归零，因为不可能观测到由 VES 提供的内存的内容。

在 C++ 实现（不需要明确赋值分析）上的性能测量表明，即使在高度优化的代码中，添加这个要求几乎没有影响。此外，当没有执行归零时，客户错误地将错误归咎于编译器，因为当对程序进行小的、无关的改变时，这样的代码通常会失败。

验证算法将模拟代码中所有可能的控制流路径，并确保每个可达的 CIL 指令存在一个有效的堆栈状态。验证算法在模拟过程中不利用任何数据值（例如，它不执行常量传递），而只使用类型赋值。用于验证的类型系统的详细信息和用于合并堆栈状态的算法在 §[_合并堆栈状态_](#merging-stack-states) 中提供。验证算法以以下方式终止：
 1. 当所有的控制路径均能通过模拟时成功。
 2. 当无法计算特定 CIL 指令的有效堆栈状态时失败。
 3. 当本小节指定的其他测试失败时失败。

除了无条件分支指令，`throw`，`rethrow` 和 `ret`，每个指令都有一条从当前指令到后续指令的控制流路径。每个分支指令（条件或无条件）也有一条到分支目标（或在 `switch` 指令的情况下的多条目标）的控制流路径。

验证模拟每个 CIL 指令的操作来计算新的堆栈状态，任何堆栈状态的指定条件（参见 §[[↗]](#base-ins)）与模拟的堆栈状态之间的类型不匹配将导致验证算法失败。验证只模拟对堆栈状态的影响：它不执行实际的计算。如果在下一个指令地址（对于条件分支或在 **try** 块内的指令，可能有多个这样的地址）存在一个不能与刚刚计算的堆栈状态合并的现有堆栈状态，那么算法也将失败。对于这个合并操作的规则，参见 §[_合并堆栈状态_](#merging-stack-states)。

CLI 支持 *受控可变性* (_controlled-mutability_) 托管指针的概念（参见 §[*可控易变托管指针*](#controlled-mutability-managed-pointers)，合并规则在 §[_合并堆栈状态_](#merging-stack-states)，`readonly.` 指令前缀在 §[[↗]](#readonly)，`ldfld` 指令在 §[[↗]](#ldfld)，`stfld` 指令在 §[[↗]](#stfld)，以及 `unbox` 指令在 §[[↗]](#unbox)）。

VES 确保特殊约束和类型约束都得到满足。这些约束可以在构造闭类型时提前进行检查，也可以在调用受约束泛型类型的方法、受约束的泛型方法、访问受约束的泛型类型中的字段，或创建受约束的泛型类型的实例时尽可能晚地进行检查。

为了适应泛型，扩展类型兼容关系以处理：

 * 泛型参数：一个泛型参数只能 *可赋值给* 它自己。
 * 装箱的泛型参数：一个装箱的泛型参数可以 *可赋值给* 在泛型参数上声明的约束类型。

在验证语义中，在堆栈上装箱原始值或值类型的值会引入一个类型为 "装箱" 类型的值；如果值类型是 `Nullable<T>`，则引入了类型为 "装箱" `T` 的值。这种装箱类型的概念可以扩展到泛型参数。在堆栈上装箱类型为泛型参数（例如 `!0`）的值会引入了装箱参数类型的值（例如 "装箱"`!0`）。值类型的装箱形式，以及泛型参数的装箱形式，用来支持对装箱值进行有效的实例和虚方法调用。因为 "装箱" 类型在静态上记录了底层值的确切类型，所以不需要在一些信息较少但语法上可表达的引用类型上对实例执行有检查的强制转换。

就像原始和非原始值类型的装箱形式一样，泛型参数的装箱形式只出现在验证堆栈上（在被 `box` 指令引入之后）。它们不能使用元数据签名显式地指定。

##### 验证类型系统

验证算法压缩逻辑上等价的类型，因为它们不会违反内存安全性。验证算法使用的类型在 §[[↗]](#verification-types) 中指定，类型兼容性规则在 §[[↗]](#controlled-mutability-managed-pointers) 中指定，合并堆栈状态的规则在 §[[↗]](#merging-stack-states) 中指定。

> ***验证类型***
<a id="verification-types"></a>

第一部分 §[*赋值兼容性*](./01_CLI%20基本概念和体系结构.md/#assignment-compatibility) 指定了 CLI 和验证中使用的类型的映射。验证将 CLI 类型压缩到一个更小的集合，该集合保持了这些类型在内存中大小的信息，但之后再次压缩这些类型，以表示 CLI 堆栈将 1，2 和 4 字节的内置类型扩展到堆栈上的 4 字节类型的事实。类似地，验证将堆栈上的浮点数视为 64 位量，而不考虑实际的表示。

数组是对象，但具有特殊的兼容性规则。

CLI 有一个特殊的编码用于表示 `null`，它代表一个已知为 `null` 值的对象，其实际类型不确定。一个 `null` 值可能已知具有某种引用类型；例如，当它从局部变量或字段加载时；或者当它是由 `ldnull` 指令产生的具有特殊的 `null` 类型。`null` 类型的 `null` 值只能存在于求值堆栈上。当任何指令的正确性或验证部分需要某种特定引用类型的值时，也可以使用 `null` 类型的值。如果提供了 `null` 类型的值并且指令对其进行了解引用，那么将抛出 `System.NullReferenceException`。

在下表中，"CLI 类型" 是在元数据中描述的类型。在考虑被调用方法的局部变量、参数和参数的类型时，"验证类型" 是用于验证类型兼容性规则的相应类型。验证类型（在堆栈状态中）对应于中间类型，用于模拟将数据加载到堆栈的指令，并显示在验证算法的堆栈状态信息中实际维护的类型。"Managed Pointer to Type" 列显示了为托管指针跟踪的类型。

 | CLI Type                            | Verification Type | Verification Type (in stack state) | Managed Pointer to Type |
 | ----------------------------------- | ----------------- | ---------------------------------- | ----------------------- |
 | `int8`, `unsigned int8`, `bool`     | `int8`            | `int32`                            | `int8&`                 |
 | `int16`, `unsigned int16`, `char`   | `int16`           | `int32`                            | `int16&`                |
 | `int32`, `unsigned int32`           | `int32`           | `int32`                            | `int32&`                |
 | `int64`, `unsigned int64`           | `int64`           | `int64`                            | `int64&`                |
 | `native int`, `native unsigned int` | `native int`      | `native int`                       | `native int&`           |
 | `float32`                           | `float32`         | `float64`                          | `float32&`              |
 | `float64`                           | `float64`         | `float64`                          | `float64&`              |
 | Any value type                      | Same type         | Same type                          | Same type`&`            |
 | Any object type                     | Same type         | Same type                          | Same type`&`            |
 | Method pointer                      | Same type         | Same type                          | Not valid               |

一个方法可以被定义为返回一个托管指针，但是对这样方法的调用是不可验证的。当通过引用返回时，验证是在返回点进行的，而不是在调用点进行的。

返回托管指针的一些用途是完全可验证的（例如，返回一个对象中的字段的引用）；但有些不是（例如，返回被调用方法局部变量的指针）。在一般情况下跟踪它是一个负担，因此没有包含在这个标准中。

> ***可控易变托管指针***
<a id="controlled-mutability-managed-pointers"></a>

`readonly.` 前缀和 `unbox` 指令可以产生所谓的 *可控易变托管指针* (_controlled-mutability 
managed pointer_)。与普通的托管指针类型不同，可控易变托管指针不能作为 *验证可赋值给*（§[[↗]](#Verification-type-compatibility)）普通的托管指针；例如，它不能作为一个 **byref** 参数传递给一个方法。在控制流点，可控易变托管指针可以与相同类型的托管指针合并，以产生可控易变托管指针。

可控易变托管指针只能以以下方式使用：

 1. 作为 `ldfld`，`ldflda`，`stfld`，`call`，`callvirt` 或 `constrained. callvirt` 指令的对象参数。
 2. 作为 `ldind.*` 或 `ldobj` 指令的指针参数。
 3. 作为 `cpobj` 指令的源参数。

所有其他操作（包括 `stobj`，`stind.*`，`initobj` 和 `mkrefany`）都是无效的。

这个指针之所以被称为可控易变托管指针，是因为定义类型决定了值是否可以被改变。对于没有公开任何公共字段或就地更新值的方法的值类，指针是只读的（因此得名前缀）。特别地，表示原始类型（如 `System.Int32`）的类不公开设值方法，因此是只读的。

> ***验证类型兼容性***
<a id="Verification-type-compatibility"></a>

验证类型兼容性是根据赋值兼容性定义的（参见 §[*赋值兼容性*](./01_CLI%20基本概念和体系结构.md/#assignment-compatibility)）。

如果当且仅当 `T` 是 `Q` 的验证类型，`U` 是 `R` 的验证类型，并且满足以下至少一项条件时，类型 `Q` 是 *验证可赋值给* (_verifier-assignable-to_) `R`（有时写作 `R` := `Q`）：

 1. `T` 与 `U` 相同。这是验证类型兼容性的自反性。
 2. 存在某个 `V`，使得 `T` 是 *验证可赋值给* `V`，并且 `V` 是 *验证可赋值给* `U`。这是验证类型兼容性的传递性。
 3. 根据 §[_一般赋值兼容性_](./01_CLI%20基本概念和体系结构.md/#general-assignment-compatibility) 中的规则，`T` 是 *可赋值给* `U`。
 4. `T` 是类型 `V` 的可控易变托管指针类型，`U` 是类型 `W` 的可控易变托管指针类型，`V` 是 *指针元素可赋值给* `W`。
 5. `T` 是托管指针类型 `V&`，`U` 是类型 `W` 的可控易变托管指针类型，`V` 是 *指针元素可赋值给* `W`。
 6. `T` 是装箱的 `V`，`U` 是 `V` 的直接基类。
 7. `T` 是装箱的 `V`，`U` 是 `V` 直接实现的接口。
 8. `T` 是装箱的 `X`，对于泛型参数 `X`，`V` 是在参数 `X` 上声明的泛型约束。
 9. `T` 是 `null` 类型，`U` 是引用类型。

*验证可赋值* 给扩展了 *可赋值给*，以处理只能在堆栈上出现的类型，即装箱类型、可控易变托管指针类型和 `null` 类型。

在第三部分的其余部分，有时使用符号 "`U` := `T`" 表示 `T` 是 *验证可赋值给* `U`。

##### 合并堆栈状态
<a id="merging-stack-states"></a>

当验证算法模拟所有控制流路径时，它应将模拟的堆栈状态与流中下一个 CIL 指令的任何现有堆栈状态合并。如果没有现有的堆栈状态，模拟的堆栈状态将被存储以供将来使用。否则，合并应按照以下方式计算，并存储以替换 CIL 指令的现有堆栈状态。如果合并失败，验证算法将失败。

合并应通过比较每个堆栈状态中的插槽数量来计算。如果它们不同，合并将失败。如果它们匹配，那么整体合并应通过按以下方式逐插槽合并状态来计算。设 `T` 是新计算状态的插槽上的类型，`S` 是先前存储状态的相应插槽上的类型。合并的类型 `U`，应按照以下方式计算（`S` := `T` 是在 §[_可控易变托管指针_](#controlled-mutability-managed-pointers) 中定义的兼容性函数）：

 1. 如果 `S` := `T`，那么 `U` = `S`
 2. 否则，如果 `T` := `S`，那么 `U` = `T`
 3. 否则，如果 `S` 和 `T` 都是对象类型，那么让 `V` 是 `S` 和 `T` 的最近公共超类型，那么 `U` = `V`。
 4. 否则，合并应失败。

将可控易变托管指针与同一类型的普通（即非可控易变）托管指针合并，结果是该类型的可控易变托管指针。

##### 类和对象初始化规则

VES 确保所有静态变量初始化为全零位（即，内置类型为 0 或 `false`，对象引用为 `null`），因此验证算法不测试静态变量的明确分配。

除非在新构造的对象上调用了对象基类的构造函数或对象类的不同构造函数，否则对象构造函数不应返回。除非已经调用了基类构造函数，否则验证算法应将 **this** 指针视为未初始化。除了存储和加载对象的字段外，不能对未初始化的 **this** 执行任何操作。

如果构造函数产生异常，则对应 **catch** 块中的 **this** 指针仍未初始化。

##### 委托构造

委托构造的验证是基于代码序列而不是单个指令。这些信息在 `newobj` 指令的描述（§[[↗]](#newobj)）中有详细说明。

如果分支目标在这些指令序列中（除了在序列的开始处），则验证算法应失败。

参见第二部分的 [_委托签名_](./02_CLI%20元数据定义和语义.md/#delegate-signature)，了解委托的签名以及关于在构造函数中使用的方法的签名以及委托类上的 `Invoke` 和其他方法的签名的有效性要求。

>---
### 元数据 Token

许多 CIL 指令后面都跟着一个 "元数据 *Token*"。这是一个 4 字节的值，它指定了元数据表中的一行，或者 ***UserString Heap*** 中的起始字节偏移量。*token* 的最高有效字节指定了表或堆。例如，值 0x02 指定了 **`TypeDef`** 表；值 0x70 指定了 ***UserString Heap***。该值对应于分配给该元数据表的编号或者对应于 ***UserString Heap*** 的 0x70。最低有效的 3 字节指定了元数据表中的目标行，或者 ***UserString Heap*** 中的起始字节偏移量。元数据表中的行是从 1 开始编号的，而堆中的偏移量是从 0 开始编号的。例如，元数据 _token_ 的值 0x02000007 指定了 **`TypeDef`** 表中的行号 7）

>---
### 异常抛出

一个 CIL 指令可以抛出一系列的异常。CLI 也可以抛出一个称为 `ExecutionEngineException` 的通用异常。

---
## 指令前缀

这些特殊的值被保留用在特定的指令之前，它们本身并不构成完整的指令。分支到在前缀后面的指令是无效的 CIL，但是前缀本身是一个有效的分支目标。如果一个前缀后面没有紧跟它允许的指令，那么它不是有效的 CIL。

>---
### constrained. ：在变量类型的值上调用成员

 | Format        | Assembly Format           | Description                           |
 | :------------ | :------------------------ | :------------------------------------ |
 | FE 16 _\<T\>_ | `constrained.` _thisType_ | 在被约束为类型 `T` 的类型上调用虚方法 |

> *堆栈转换*：

&hellip;, _ptr_, _arg1_, … _argN_ &rarr; &hellip;, _ptr_, _arg1_, … _argN_

> *描述*：

`constrained.` 前缀只允许在 `callvirt` 指令上。*ptr* 的类型必须是 _thisType_ 的托管指针（`&`）。`constrained.` 前缀的设计是为了允许以统一方式进行 `callvirt` 指令，而不考虑 _thisType_ 是值类型还是引用类型。

当 `callvirt` 方法指令被 `constrained.` _thisType_ 前缀修饰时，指令按以下方式执行：
- 如果 _thisType_ 是引用类型（而不是值类型），那么 _ptr_ 被解引用并作为 **this** 指针传递给 `callvirt` 的方法。
- 如果 _thisType_ 是值类型并且 _thisType_ 实现了 _method_，那么不修改 _ptr_ 并作为 **this** 指针传递给 _thisType_ 实现的 _method_ 的调用。
- 如果 _thisType_ 是值类型并且 _thisType_ 没有实现 _method_，那么 _ptr_ 被解引用、装箱，并作为 **this** 指针传递给 `callvirt` 的方法

这最后一种情况只能在 _method_ 被定义在 `System.Object`、`System.ValueType` 或 `System.Enum` 上，并且没有被 _thisType_ 重写时发生。在这最后一种情况下，装箱导致原始对象的副本被创建，然而由于所有在 `System.Object`、`System.ValueType` 和 `System.Enum` 上的方法都不修改对象的状态，因此实际上不会被检测到。

> *正确性*：

`constrained.` 前缀后紧随 `callvirt` 指令。_thisType_ 应该是一个有效的 `typedef`，`typeref`，或 `typespec` 元数据 *Token*。

> *可验证性*：

_ptr_ 参数是一个托管指针（`&`）到 _thisType_。此外，在上述 _ptr_ 转换之后，`callvirt` 指令的所有正常验证规则都适用。这相当于要求一个装箱的 _thisType_ 必须是方法所属类的子类。

这个指令的目标是实现虚函数调用的一致性，因此这样的调用可以在泛型例程中进行验证。实现这种一致性的一种方式是在进行 `callvirt` 之前总是对 **this** 指针进行装箱。这对于引用类型（其中 `box` 是无操作）和值类型都是有效的。这种方法的问题在于，在值类型的情况下会产生一个副本。因此，如果被调用的方法修改了值类型的状态，那么在调用完成后这种修改将不会反映出来，因为这种修改是在装箱的副本中进行的。这种语义差异（以及额外装箱的性能成本），使得这种替代方案无法接受。

>---
### no. ：可能跳过错误检查

 | Format                    | Assembly Format                                        | Description                                                       |
 | :------------------------ | :----------------------------------------------------- | :---------------------------------------------------------------- |
 | FE 19 _\<unsigned int8\>_ | `no.` \{ `typecheck` \| `rangecheck` \| `nullcheck` \} | 在执行后续指令的过程中，通常执行的指定错误检查可以 / 应该被跳过。 |

> *描述*：

`no.` 前缀表示在执行后续指令时不需要执行指定的错误检查。跟在指令代码后面的字节指示哪些检查可以选择性地被跳过。这个指令是不可验证的。

`no.` 前缀可以在以下情况下使用：
 * 0x01: `typecheck` (`castclass`, `unbox`, `ldelema`, `stelem`, `stelem`)。CLI 可以在执行后续指令的过程中，选择性地跳过通常执行的任何类型检查。如果检查失败，可以选择性地抛出 `InvalidCastException`。
 * 0x02: `rangecheck` (`ldelem.*`, `ldelema`, `stelem.*`)。CLI 可以在执行后续指令的过程中，选择性地跳过通常执行的任何数组范围检查。如果检查失败，可以选择性地抛出 `IndexOutOfRangeException`。
 * 0x04: `nullcheck` (`ldfld`, `stfld`, `callvirt`, `ldvirtftn`, `ldelem.*`, `stelem.*`, `ldelema`)。CLI 可以在执行后续指令的过程中，选择性地跳过通常执行的任何空引用检查。如果检查失败，可以选择性地抛出 `NullReferenceException`。

字节值可以按或组合；例如，值 0x05 表示 `typecheck` 和 `nullcheck` 都可以选择性地被忽略。

> *正确性*:

正确的 CIL 只允许在上面指定的指令上使用前缀 `no.`。

> *可验证性*：

可验证的 CIL 不允许使用前缀 `no.`。

>---
### readonly. ：后续指令返回可控易变托管指针
<a id="readonly"></a>

 | Format | Assembly Format | Description                                                                |
 | :----- | :-------------- | :------------------------------------------------------------------------- |
 | FE 1E  | `readonly.`     | 指定后续数组地址操作在运行时不执行类型检查，并且它返回一个可控易变托管指针 |

> *描述*：

`readonly.` 前缀只能出现在 `ldelema` 指令或调用数组上的特殊 *Address* 方法之前。它对后续操作的影响有两方面：
 1. 在运行时，不执行类型检查操作。对于值类的情况，从不在运行时检查，所以这是一个 *noop* 无操作。
 2. 验证器将地址操作的结果视为可控易变托管指针 §[[↗]](#controlled-mutability-managed-pointers)。

> *可验证性*：

可控易变托管指针必须遵守在 §[[↗]](#controlled-mutability-managed-pointers) 的 (2.) 中给出的验证规则。另请参见 §[_合并堆栈状态_](#merging-stack-states)。

`readonly.`前缀的主要目标是在泛型代码中从数组中获取元素时避免类型检查。例如，表达式 `array[i].method()`，其中 `array` 的类型为 `T[]`（其中 `T` 是一个泛型参数），并且 `T` 被约束为具有方法 `method` 的接口，可能会编译成以下 IL 代码。

```csharp
interface ISample { void method(); }
class Sample<T> where T: ISample
{
    public void Fun(T[] arr, int j) => arr[j].method();
}
```
```cil
ldloc array
ldloc j          // j is array index
readonly.
ldelema !0       // loads the pointer to the object
…                // load the arguments to the call
constrained. !0
callvirt method
```

如果没有 `readonly.` 前缀，`ldelema` 在 `!0` 是引用类的情况下会进行类型检查。这种类型检查不仅效率低下，而且在语义上是不正确的。`ldelema` 的类型检查执行精确匹配的强类型检查。如果数组中包含了 `!0` 的派生类，那么上面的代码将无法通过 `ldelema` 类型检查。我们获取数组元素的地址而不是元素本身（这是源代码所说的）的唯一原因，是因为我们需要一个对 `array[i]` 的句柄，这个句柄对于值类型和引用类型都可以传递给受约束 (`constrained.`) 的 `callvirt` 指令。

如果数组包含引用类型的元素，一般来说，跳过运行时检查是不安全的。为了安全，我们必须确保不能通过这个指针修改数组。上述的验证规则确保了这一点。由于我们显式允许只读指针作为实例方法调用的对象传递，这些指针对于值类型并不严格地只读，但是对于值类型来说没有类型安全问题。

>---
### tail. ：调用终止当前方法

 | Format | Assembly Format | Description          |
 | :----- | :-------------- | :------------------- |
 | FE 14  | `tail.`         | 后续调用终止当前方法 |

> *描述*：

`tail.` 前缀后应紧随 `call`，`calli` 或 `callvirt` 指令。它表示当前方法的堆栈帧不再需要，因此可以在执行调用指令之前将其移除。因为调用返回的值将是此方法返回的值，所以调用可以转换为跨方法跳转。

求值堆栈应为空，除了由后续调用传递的参数。调用指令后面的指令应该是 `ret`。因此，唯一有效的代码序列是

```cil
 tail. call *somewhere*   // or `calli` or `callvirt`
 ret
```

正确的 CIL 不应分支到 `call` 指令，但是允许分支到 `ret`。堆栈上的唯一值应该是被调用方法的参数。

`tail. call`（或 `calli` 或 `callvirt`）指令不能在 **try**，**filter**，**catch** 或 **finally** 块中用于转移控制。

当从不受信任的代码转移到受信任的代码时，不能丢弃当前帧，因为这将危及代码标识安全性。因此，安全检查可能会导致忽略 `tail.`，并留下一个标准的调用指令。

同样，为了允许在调用返回后退出同步区域，当用于退出标记为同步 (**synchronized**) 的方法时，将忽略 `tail.` 前缀。

还可能存在一些特定实现的限制，防止在某些情况下遵守 `tail.` 前缀。虽然实现可以在这些情况下自由地忽略 `tail.` 前缀，但是它们应该被清楚地记录下来，因为它们可能会影响程序的行为。

CLI 实现需要尊重 `tail. call` 请求，其中调用方和被调用方的方法可以静态地确定为位于同一程序集中；并且调用方不在同步区域内；并且调用方和被调用方满足下面的 "可验证性" 规则中列出的所有条件。（"尊重" `tail.` 前缀意味着移除调用方的帧，而不是恢复到常规的调用序列）。因此，CLI 实现不需要尊重 `tail. calli` 或 `tail. callvirt` 序列。

`tail.` 调用允许将一些线性空间算法转换为常量空间算法，并且是某些语言所要求的。在存在 `ldloca` 和 `ldarga` 指令的情况下，从 CIL-to-native-code 的编译器并不总是能够最优地确定何时可以自动插入 `tail.`。

> *正确性*：

正确的 CIL 遵守上述的控制转移约束。此外，如果它们指向即将被移除的堆栈帧，那么不能将托管指针传递给被调用的方法。被调用方法的返回类型应该是 *可赋值给* 当前方法的返回类型。

> *可验证性*：

验证要求不应将托管指针传递给被调用的方法，因为它不跟踪进入当前帧的指针。

>---
### unaligned. (prefix) &ndash; 指针指令可能不对齐

 | Format                    | Assembly Format          | Description            |
 | :------------------------ | :----------------------- | :--------------------- |
 | FE 12 _\<unsigned int8\>_ | `unaligned.` *alignment* | 后续指针指令可能不对齐 |
 
> *堆栈转换*：

&hellip;, *addr* &rarr; &hellip;, *addr*

> *描述*：

`unaligned.` 前缀指定堆栈上的 *addr*（一个非托管指针（`&`）或 `native int`）可能不对齐到紧随其后的 `ldind`，`stind`，`ldfld`，`stfld`，`ldobj`，`stobj`，`initblk` 或 `cpblk` 指令的自然大小。也就是说，对于 `ldind.i4` 指令，*addr* 的对齐可能不是到 4 字节边界。对于 `initblk` 和 `cpblk`，默认对齐是依赖于架构的（32 位 CPU 上是 4 字节，64 位 CPU 上是 8 字节）。不将其输出限制为 32 位字长的代码生成器如果在编译时不能确定对齐是否为 8 字节时使用 `unaligned.`。

*alignment* 的值应为 1，2 或 4，表示生成的代码应假定 *addr* 分别对齐到字节，双字节或四字节。

虽然 `cpblk` 指令的对齐逻辑上需要两个数字（一个用于源，一个用于目标），但是若只指定较低的数字，则对性能的影响并不明显。

`unaligned.` 和 `volatile.` 前缀可以以任何顺序组合，并在后面紧随 `ldind`，`stind`，`ldfld`，`stfld`，`ldobj`，`stobj`，`initblk` 或 `cpblk`指令。

> *正确性和可验证性*：

`unaligned.` 前缀后面应立即紧随上述的指令之一。

>---
### volatile. ：指针引用是易变的

 | Format | Assembly Format | Description          |
 | :----- | :-------------- | :------------------- |
 | FE 13  | `volatile.`     | 后续指针引用是易变的 |

> *堆栈转换*：

&hellip;, *addr* &rarr; &hellip;, *addr*

> *描述*：

`volatile.` 前缀指定 *addr* 是一个易变地址（即，它可以被当前执行线程外部引用），并且不能缓存读取该位置的结果，或者不能抑制对该位置的多次存储。对标记为 `volatile.` 位置的访问只影响该单次访问；对同一位置的其他访问应分别标记。不需要原子地访问易变位置。

`unaligned.` 和 `volatile.` 前缀可以以任何顺序组合，并在后面紧随 `ldind`，`stind`，`ldfld`，`stfld`，`ldobj`，`stobj`，`initblk` 或 `cpblk`指令。只有 `volatile.` 前缀允许与 `ldsfld` 和 `stsfld` 指令一起使用。

> *正确性和可验证性*：

`volatile.` 前缀后面应立即紧随上述的指令之一。

---
## 基本指令
<a id="base-ins"></a>

这些指令形成了一套 "***Turing*** ***Complete***" 的基本操作。它们独立于可能使用的对象模型。与 CTS 的对象模型具体相关的操作包含在对象模型指令部分。

>---
### add ：添加数值

 | Format | Assembly Format | Description              |
 | :----- | :-------------- | :----------------------- |
 | 58     | `add`           | 添加两个值，返回一个新值 |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;, _result_

> *描述*：

`add` 指令将 _value2_ 添加到 _value1_ 并将结果推入堆栈。对于整数操作，不检测溢出（但请参见 `add.ovf`）；浮点溢出返回 `+inf` 或 `-inf`。

可接受的操作数类型及其相应的结果数据类型包含在 [*二元数值操作*](#OpTable2) 中。

>---
### add.ovf.\<signed\> ：添加整数值并检查溢出

 | Format | Assembly Format | Description                      |
 | :----- | :-------------- | :------------------------------- |
 | D6     | `add.ovf`       | 添加带有溢出检查的有符号整数值。 |
 | D7     | `add.ovf.un`    | 添加带有溢出检查的无符号整数值。 |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;, _result_

> *描述*：

`add.ovf` 指令将 _value1_ 和 _value2_ 相加并将结果推入堆栈。可接受的操作数类型及其相应的结果数据类型包含在 [*溢出算术运算*](#OpTable7) 中。

> *异常*：

如果结果不能用结果类型表示，则抛出 `System.OverflowException`。

>---
### and ：按位与

 | Format | Assembly Format | Description                          |
 | :----- | :-------------- | :----------------------------------- |
 | 5F     | `and`           | 两个整数值的按位与，返回一个整数值。 |
 
> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;, _result_

> 描述：

`and` 指令计算 _value1_ 和 _value2_ 的按位与，并将结果推入堆栈。可接受的操作数类型及其相应的结果数据类型包含在 [*整数操作*](#OpTable5) 中。

### arglist ：获取参数列表

 | Format | Assembly Format | Description                  |
 | :----- | :-------------- | :--------------------------- |
 | FE 00  | `arglist`       | 返回当前方法的参数列表句柄。 |

> *堆栈转换*：

&hellip; &rarr; &hellip;, _argListHandle_

> *描述*：

`arglist` 指令返回一个不透明句柄 (类型为 `System.RuntimeArgumentHandle`)，代表当前方法的参数列表。这个句柄只在当前方法的生命周期内有效。但是只要当前方法在控制线程上，该句柄就可以传递给其他方法。`arglist` 指令只能在接受可变数量参数的方法中执行。

这个指令是用来实现 C 语言的 `va_*` 宏的，这些宏用来实现像 “`printf`” 方法的程序。它旨在与 `System.ArgIterator` 的类库实现一起使用。

> *正确性*：

除非在方法签名中表明它接受可变数量的参数，否则在其方法体中发出此指令是不正确的 CIL 生成。

> *可验证性*：

在其签名表明接受可变数量参数的方法主体中，该指令的使用是可验证的，但验证要求结果是 `System.RuntimeArgumentHandle` 类的实例。

>---
### beq.\<length\> ：相等分支

 | Format         | Assembly Format  | Description                         |
 | :------------- | :--------------- | :---------------------------------- |
 | 3B _\<int32\>_ | `beq` _target_   | 如果等于则跳转到 _target_。         |
 | 2E _\<int8\>_  | `beq.s` _target_ | 如果等于则跳转到 _target_，短格式。 |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;

> *描述*：

如果 _value1_ 等于 _value2_，`beq` 指令将控制权转移到 _target_。效果等同于执行 `ceq` 指令后跟 `brtrue` _target_。_target_ 表示为从当前指令后的指令开始的有符号偏移（`beq` 为 4 字节，`beq.s` 为 1 字节）。

可接受的操作数类型包含在 [*二元比较或分支操作*](#OpTable4) 中。如果 _target_ 指令有一个或多个前缀代码，控制只能转移到这些前缀中的第一个。此指令不能执行进入和退出 **try**，**catch**，**filter** 和 **finally** 块的控制转移。这种转移受到严格限制，应使用 `leave` 指令代替。

> *正确性*：

正确的 CIL 应遵守上述所有控制转移规则，并保证堆栈顶部的两个元素对应于 [*二元比较或分支操作*](#OpTable4) 中显示的类型。

> *可验证性*：

可验证代码要求每个到达 _target_ 指令的可能路径的堆栈、局部变量和参数的类型一致性。

>---
### bge.\<length\> ：大于或等于分支

 | Format         | Assembly Format  | Description                               |
 | :------------- | :--------------- | :---------------------------------------- |
 | 3C _\<int32\>_ | `bge` _target_   | 如果大于或等于则跳转到 _target_。         |
 | 2F _\<int8\>_  | `bge.s` _target_ | 如果大于或等于则跳转到 _target_，短格式。 |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;

> *描述*：

如果 _value1_ 大于或等于 _value2_，`bge` 指令将控制权转移到 _target_。效果等同于执行 `clt.un` 指令后跟 `brfalse` _target_。_target_ 表示为从当前指令后的指令开始的有符号偏移（`bge` 为 4 字节，`bge.s` 为 1 字节）。

`bge` _target_ 指令的效果等同于：
 * 如果堆栈操作数是整数，则执行 `clt` 后跟 `brfalse` _target_
 * 如果堆栈操作数是浮点数，则执行 `clt.un` 后跟 `brfalse` _target_

可接受的操作数类型包含在 [*二元比较或分支操作*](#OpTable4) 中。如果 _target_ 指令有一个或多个前缀代码，控制只能转移到这些前缀中的第一个。此指令不能执行进入和退出 **try**，**catch**，**filter** 和 **finally** 块的控制转移。这种转移受到严格限制，应使用 `leave` 指令代替。

> *正确性*：

正确的 CIL 应遵守上述所有控制转移规则，并保证堆栈顶部的两个元素对应于 [*二元比较或分支操作*](#OpTable4) 中显示的类型。

> *可验证性*：

可验证代码要求每个到达 _target_ 指令的可能路径的堆栈、局部变量和参数的类型一致性。

>---
### bge.un.\<length\> ：无符号 / 无序的大于或等于分支

 | Format         | Assembly Format     | Description                                                 |
 | :------------- | :------------------ | :---------------------------------------------------------- |
 | 41 _\<int32\>_ | `bge.un` _target_   | 如果大于或等于（无符号或无序），则分支到 _target_。         |
 | 34 _\<int8\>_  | `bge.un.s` _target_ | 如果大于或等于（无符号或无序），则分支到 _target_，短格式。 |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;

> *描述*：

如果 _value1_ 大于或等于 _value2_，当比较无符号（对于整数值）或无序（对于浮点值）时，`bge.un` 指令将控制权转移到 _target_。

_target_ 表示为从当前指令后的指令开始的有符号偏移（`bge.un` 为 4 字节，`bge.un.s` 为 1 字节）。

可接受的操作数类型包含在 [*二元比较或分支操作*](#OpTable4) 中。如果 _target_ 指令有一个或多个前缀代码，控制只能转移到这些前缀中的第一个。此指令不能执行进入和退出 **try**，**catch**，**filter** 和 **finally** 块的控制转移。这种转移受到严格限制，应使用 `leave` 指令代替。

> *正确性*：

正确的 CIL 应遵守上述所有控制转移规则，并保证堆栈顶部的两个元素对应于 [*二元比较或分支操作*](#OpTable4) 中显示的类型。

> *可验证性*：

可验证代码要求每个到达 _target_ 指令的可能路径的堆栈、局部变量和参数的类型一致性。

>---
### bgt.\<length\> ：大于分支

 | Format         | Assembly Format  | Description                           |
 | :------------- | :--------------- | :------------------------------------ |
 | 3D _\<int32\>_ | `bgt` _target_   | 如果大于，则分支到 _target_。         |
 | 30 _\<int8\>_  | `bgt.s` _target_ | 如果大于，则分支到 _target_，短格式。 |


> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;

> *描述*：

如果 _value1_ 大于 _value2_，`bgt` 指令将控制权转移到 _target_。效果与执行 `cgt` 指令后跟 `brtrue` _target_ 相同。_target_ 表示为从当前指令后的指令开始的有符号偏移（`bgt` 为 4 字节，`bgt.s` 为 1 字节）。

可接受的操作数类型包含在 [*二元比较或分支操作*](#OpTable4) 中。如果 _target_ 指令有一个或多个前缀代码，控制只能转移到这些前缀中的第一个。此指令不能执行进入和退出 **try**，**catch**，**filter** 和 **finally** 块的控制转移。这种转移受到严格限制，应使用 `leave` 指令代替。

> *正确性*：

正确的 CIL 应遵守上述所有控制转移规则，并保证堆栈顶部的两个元素对应于 [*二元比较或分支操作*](#OpTable4) 中显示的类型。

> *可验证性*：

可验证代码要求每个到达 _target_ 指令的可能路径的堆栈、局部变量和参数的类型一致性。

>---
### bgt.un.\<length\> ：无符号 / 无序的大于分支

 | Format         | Assembly Format     | Description                                           |
 | :------------- | :------------------ | :---------------------------------------------------- |
 | 42 _\<int32\>_ | `bgt.un` _target_   | 如果大于（无符号或无序），则分支到 _target_。         |
 | 35 _\<int8\>_  | `bgt.un.s` _target_ | 如果大于（无符号或无序），则分支到 _target_，短格式。 |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;

> *描述*：

如果 _value1_ 大于 _value2_，当比较无符号（对于整数值）或无序（对于浮点值）时，`bgt.un` 指令将控制权转移到 _target_。效果与执行 `cgt.un` 指令后跟 `brtrue` _target_ 相同。_target_ 表示为从当前指令后的指令开始的有符号偏移（`bgt.un` 为 4 字节，`bgt.un.s` 为 1 字节）。

可接受的操作数类型包含在 [*二元比较或分支操作*](#OpTable4) 中。如果 _target_ 指令有一个或多个前缀代码，控制只能转移到这些前缀中的第一个。此指令不能执行进入和退出 **try**，**catch**，**filter** 和 **finally** 块的控制转移。这种转移受到严格限制，应使用 `leave` 指令代替。

> *正确性*：

正确的 CIL 应遵守上述所有控制转移规则，并保证堆栈顶部的两个元素对应于 [*二元比较或分支操作*](#OpTable4) 中显示的类型。

> *可验证性*：

可验证代码要求每个到达 _target_ 指令的可能路径的堆栈、局部变量和参数的类型一致性。

>---
### ble.\<length\> ：小于或等于分支

 | Format         | Assembly Format  | Description                                 |
 | :------------- | :--------------- | :------------------------------------------ |
 | 3E _\<int32\>_ | `ble` _target_   | 如果小于或等于，则分支到 _target_。         |
 | 31 _\<int8\>_  | `ble.s` _target_ | 如果小于或等于，则分支到 _target_，短格式。 |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;

> *描述*：

如果 _值1_ 小于或等于 _值2_，`ble` 指令将控制权转移到 _target_。_target_ 表示为从当前指令后的指令开始的有符号偏移（`ble` 为 4 字节，`ble.s` 为 1 字节）。

`ble` _target_ 指令的效果与以下相同：
 * 如果堆栈操作数是整数，则：`cgt` 后跟 `brfalse` _target_
 * 如果堆栈操作数是浮点数，则：`cgt.un` 后跟 `brfalse` _target_

可接受的操作数类型包含在 [*二元比较或分支操作*](#OpTable4) 中。如果 _target_ 指令有一个或多个前缀代码，控制只能转移到这些前缀中的第一个。此指令不能执行进入和退出 **try**，**catch**，**filter** 和 **finally** 块的控制转移。这种转移受到严格限制，应使用 `leave` 指令代替。

> *正确性*：

正确的 CIL 应遵守上述所有控制转移规则，并保证堆栈顶部的两个元素对应于 [*二元比较或分支操作*](#OpTable4) 中显示的类型。

> *可验证性*：

可验证代码要求每个到达 _target_ 指令的可能路径的堆栈、局部变量和参数的类型一致性。

>---
### ble.un.\<length\> ：无符号 / 无序的小于或等于分支

 | Format         | Assembly Format     | Description                                                 |
 | :------------- | :------------------ | :---------------------------------------------------------- |
 | 43 _\<int32\>_ | `ble.un` _target_   | 如果小于或等于（无符号或无序），则分支到 _target_。         |
 | 36 _\<int8\>_  | `ble.un.s` _target_ | 如果小于或等于（无符号或无序），则分支到 _target_，短格式。 |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;

> *描述*：

如果 _value1_ 小于或等于 _value2_，当比较无符号（对于整数值）或无序（对于浮点值）时，`ble.un` 指令将控制权转移到 _target_。_target_ 表示为从当前指令后的指令开始的有符号偏移（`ble.un` 为 4 字节，`ble.un.s` 为 1 字节）。

`ble.un` _target_ 指令的效果与以下相同：

 * 如果堆栈操作数是整数，则：`cgt.un` 后跟 `brfalse` _target_
 * 如果堆栈操作数是浮点数，则：`cgt` 后跟 `brfalse` _target_

可接受的操作数类型包含在 [*二元比较或分支操作*](#OpTable4) 中。如果 _target_ 指令有一个或多个前缀代码，控制只能转移到这些前缀中的第一个。此指令不能执行进入和退出 **try**，**catch**，**filter** 和 **finally** 块的控制转移。这种转移受到严格限制，应使用 `leave` 指令代替。

> *正确性*：

正确的 CIL 应遵守上述所有控制转移规则，并保证堆栈顶部的两个元素对应于 [*二元比较或分支操作*](#OpTable4) 中显示的类型。

> *可验证性*：

可验证代码要求每个到达 _target_ 指令的可能路径的堆栈、局部变量和参数的类型一致性。

>---
### blt.\<length\> ：小于分支

 | Format         | Assembly Format  | Description                           |
 | :------------- | :--------------- | :------------------------------------ |
 | 3F _\<int32\>_ | `blt` _target_   | 如果小于，则分支到 _target_。         |
 | 32 _\<int8\>_  | `blt.s` _target_ | 如果小于，则分支到 _target_，短格式。 |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;

> *描述*：

如果 _value1_ 小于 _value2_，`blt` 指令将控制权转移到 _target_。效果与执行 `clt` 指令后跟 `brtrue` _target_ 相同。

_target_ 表示为从当前指令后的指令开始的有符号偏移（`blt` 为 4 字节，`blt.s` 为 1 字节）。

可接受的操作数类型包含在 [*二元比较或分支操作*](#OpTable4) 中。如果 _target_ 指令有一个或多个前缀代码，控制只能转移到这些前缀中的第一个。此指令不能执行进入和退出 **try**，**catch**，**filter** 和 **finally** 块的控制转移。这种转移受到严格限制，应使用 `leave` 指令代替。

> *正确性*：

正确的 CIL 应遵守上述所有控制转移规则，并保证堆栈顶部的两个元素对应于 [*二元比较或分支操作*](#OpTable4) 中显示的类型。

> *可验证性*：

可验证代码要求每个到达 _target_ 指令的可能路径的堆栈、局部变量和参数的类型一致性。

>---
### blt.un.\<length\> ：无符号 / 无序的小于分支

 | Format         | Assembly Format     | Description                                           |
 | :------------- | :------------------ | :---------------------------------------------------- |
 | 44 _\<int32\>_ | `blt.un` _target_   | 如果小于（无符号或无序），则分支到 _target_。         |
 | 37 _\<int8\>_  | `blt.un.s` _target_ | 如果小于（无符号或无序），则分支到 _target_，短格式。 |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;

> *描述*：

如果 _value1_ 小于 _value2_，当比较无符号（对于整数值）或无序（对于浮点值）时，`blt.un` 指令将控制权转移到 _target_。效果与执行 `clt.un` 指令后跟 `brtrue` _target_ 相同。_target_ 表示为从当前指令后的指令开始的有符号偏移（`blt.un` 为 4 字节，`blt.un.s` 为 1 字节）。

可接受的操作数类型包含在 [*二元比较或分支操作*](#OpTable4) 中。如果 _target_ 指令有一个或多个前缀代码，控制只能转移到这些前缀中的第一个。此指令不能执行进入和退出 **try**，**catch**，**filter** 和 **finally** 块的控制转移。这种转移受到严格限制，应使用 `leave` 指令代替。

> *正确性*：

正确的 CIL 应遵守上述所有控制转移规则，并保证堆栈顶部的两个元素对应于 [*二元比较或分支操作*](#OpTable4) 中显示的类型。

> *可验证性*：

可验证代码要求每个到达 _target_ 指令的可能路径的堆栈、局部变量和参数的类型一致性。

>---
### bne.un.\<length\> ：不等于或无序分支

 | Format         | Assembly Format     | Description                                   |
 | :------------- | :------------------ | :-------------------------------------------- |
 | 40 _\<int32\>_ | `bne.un` _target_   | 如果不等于或无序，则分支到 _target_。         |
 | 33 _\<int8\>_  | `bne.un.s` _target_ | 如果不等于或无序，则分支到 _target_，短格式。 |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;

> *描述*：

如果 _value1_ 不等于 _value2_，当比较无符号（对于整数值）或无序（对于浮点值）时，`bne.un` 指令将控制权转移到 _target_。效果与执行 `ceq` 指令后跟 `brfalse` _target_ 相同。_target_ 表示为从当前指令后的指令开始的有符号偏移（`bne.un` 为 4 字节，`bne.un.s` 为 1 字节）。

可接受的操作数类型包含在 [*二元比较或分支操作*](#OpTable4) 中。如果 _target_ 指令有一个或多个前缀代码，控制只能转移到这些前缀中的第一个。此指令不能执行进入和退出 **try**，**catch**，**filter** 和 **finally** 块的控制转移。这种转移受到严格限制，应使用 `leave` 指令代替。

> *正确性*：

正确的 CIL 应遵守上述所有控制转移规则，并保证堆栈顶部的两个元素对应于 [*二元比较或分支操作*](#OpTable4) 中显示的类型。

> *可验证性*：

可验证代码要求每个到达 _target_ 指令的可能路径的堆栈、局部变量和参数的类型一致性。

>---
### br.\<length\> ：无条件分支

 | Format         | Assembly Format | Description               |
 | :------------- | :-------------- | :------------------------ |
 | 38 _\<int32\>_ | `br` _target_   | 分支到 _target_。         |
 | 2B _\<int8\>_  | `br.s` _target_ | 分支到 _target_，短格式。 |

> *堆栈转换*：

&hellip;, &rarr; &hellip;

> *描述*：

`br` 指令无条件地将控制权转移到 _target_。_target_ 表示为从当前指令后的指令开始的有符号偏移（`br` 为 4 字节，`br.s` 为 1 字节）。

如果 _target_ 指令有一个或多个前缀代码，控制只能转移到这些前缀中的第一个。此指令不能执行进入和退出 **try**，**catch**，**filter** 和 **finally** 块的控制转移。这种转移受到严格限制，应使用 `leave` 指令代替。

虽然当求值堆栈为空时，可以使用 `leave` 指令代替 `br` 指令，但这样做可能会增加从 CIL-to-native-code 编译所需的资源，并 / 或导致生成的本地代码质量较差。因此，当两者都有效时，CIL 生成器应优先使用 `br` 指令。

> *正确性*：

正确的 CIL 应遵守上述所有控制转移规则。

> *可验证性*：

可验证代码要求每个到达 _target_ 指令的可能路径的堆栈、局部变量和参数的类型一致性。

>---
### break ：断点指令

 | Format | Assembly Format | Description              |
 | :----- | :-------------- | :----------------------- |
 | 01     | `break`         | 通知调试器已经到达断点。 |

> *堆栈转换*：

&hellip;, &rarr; &hellip;

> *描述*：

`break` 指令用于调试支持。它向 CLI 发出信号，通知调试器已经触发了一个断点。它对解释器状态没有其他影响。

`break` 指令具有最小可能的指令大小，因此可以在对周围代码的干扰最小的情况下用断点修补代码。

`break` 指令可能会被调试器捕获，或什么也不做，或引发安全异常：具体行为由实现定义。

> *可验证性*：

`break` 指令始终是可验证的。

>---
### brfalse.\<length\> ：分支到假、空或零

 | Format         | Assembly Format      | Description                                                      |
 | :------------- | :------------------- | :--------------------------------------------------------------- |
 | 39 _\<int32\>_ | `brfalse` _target_   | 如果 _value_ 为零（假），则分支到 _target_。                     |
 | 2C _\<int8\>_  | `brfalse.s` _target_ | 如果 _value_ 为零（假），则分支到 _target_，短格式。             |
 | 39 _\<int32\>_ | `brnull` _target_    | 如果值为 null，则分支到 _target_（`brfalse` 的别名）。           |
 | 2C _\<int8\>_  | `brnull.s` _target_  | 如果值为 null，则分支到 _target_（`brfalse.s` 的别名），短格式。 |
 | 39 _\<int32\>_ | `brzero` _target_    | 如果 _value_ 为零，则分支到 _target_（`brfalse` 的别名）。       |
 | 2C _\<int8\>_  | `brzero.s` _target_  | 如果值为零，则分支到 _target_（`brfalse.s` 的别名），短格式。    |

> *堆栈转换*：

&hellip;, _value_ &rarr; &hellip;

> *描述*：

如果 _value_（类型为 `int32`，`int64`，对象引用，托管指针，非托管指针或 `native int`）为零（假），`brfalse` 指令将控制权转移到 _target_。如果 _value_ 为非零（真），执行将在下一条指令处继续。

_target_ 表示为从当前指令后的指令开始的有符号偏移（`brfalse` 为 4 字节，`brfalse.s` 为 1 字节）。

如果 _target_ 指令有一个或多个前缀代码，控制只能转移到这些前缀中的第一个。此指令不能执行进入和退出 **try**，**catch**，**filter** 和 **finally** 块的控制转移。这种转移受到严格限制，应使用 `leave` 指令代替。

> *正确性*：

正确的 CIL 应遵守上述所有控制转移规则，并保证堆栈上至少有一个元素。

> *可验证性*：

可验证代码要求每个到达 _target_ 指令的可能路径的堆栈、局部变量和参数的类型一致性。

>---
### brtrue.\<length\> ：分支到非假或非空

 | Format        | Assembly Format     | Description                                                                   |
 | :------------ | :------------------ | :---------------------------------------------------------------------------- |
 | 3A _\<int32>_ | `brtrue` _target_   | 如果 _value_ 为非零（真），则分支到 _target_。                                |
 | 2D _\<int8>_  | `brtrue.s` _target_ | 如果 _value_ 为非零（真），则分支到 _target_，短格式。                        |
 | 3A _\<int32>_ | `brinst` _target_   | 如果 _value_ 是非空对象引用，则分支到 _target_（`brtrue` 的别名）。           |
 | 2D _\<int8>_  | `brinst.s` _target_ | 如果 _value_ 是非空对象引用，则分支到 _target_，短格式（`brtrue.s` 的别名）。 |

> *堆栈转换*：

&hellip;, _value_ &rarr; &hellip;

> *描述*：

如果 _value_（类型为 `native int`）为非零（真），`brtrue` 指令将控制权转移到 _target_。如果 _value_ 为零（假），执行将在下一条指令处继续。

如果 _value_ 是对象引用（类型 `O`），那么 `brinst`（`brtrue` 的别名）在它表示一个对象的实例时（即，不是空对象引用，参见 `ldnull`）转移控制。

_target_ 表示为从当前指令后的指令开始的有符号偏移（`brtrue` 为 4 字节，`brtrue.s` 为 1 字节）。

如果 _target_ 指令有一个或多个前缀代码，控制只能转移到这些前缀中的第一个。此指令不能执行进入和退出 **try**，**catch**，**filter** 和 **finally** 块的控制转移。这种转移受到严格限制，应使用 `leave` 指令代替。

> *正确性*：

正确的 CIL 应遵守上述所有控制转移规则，并保证堆栈上至少有一个元素。

> *可验证性*：

可验证代码要求每个到达 _target_ 指令的可能路径的堆栈、局部变量和参数的类型一致性。

>---
### call ：调用方法

 | Format     | Assembly Format | Description                  |
 | :--------- | :-------------- | :--------------------------- |
 | 28 _\<T\>_ | `call` _method_ | 调用由 _method_ 描述的方法。 |

> *堆栈转换*：

&hellip;, _arg0_, _arg1_ &hellip; _argN_ &rarr; &hellip;, _retVal_ (不总是返回)

> *描述*：

`call` 指令调用由描述符 _method_ 指示的方法。_method_ 是一个元数据 *token*（*MethodRef*，*MethodDef* 或 *MethodSpec*），它指示要调用的方法，以及已放置在堆栈上以传递给该方法的参数的数量、类型和顺序，以及要使用的调用约定。`call` 指令可以紧随在 `tail.` 前缀之后，以指定在转移控制之前应释放当前方法状态。

元数据 _token_ 携带了足够的信息来确定调用是对静态方法、实例方法、虚方法还是全局函数。在所有这些情况下，目标地址完全由元数据 *token* 确定。与此相反是，`callvirt` 指令用于调用虚方法，其中目标地址还取决于在 `callvirt` 之前推送的实例引用的确切类型。

CLI 根据 §[[↗]](./01_CLI%20基本概念和体系结构.md/#computed-destinations)（计算目标）中指定的规则解析要调用的方法，除非目标是根据元数据 *token* 指定的类计算的。这实现了 "调用基类" 行为。

参数按从左到右的顺序放置在堆栈上。也就是说，首先计算并将第一个参数放置在堆栈上，然后是第二个参数，依此类推。有三个重要的特殊情况：
 1. 对实例（或虚拟，参见下文）方法的调用应首先推送该实例引用（*this* 指针）。元数据中携带的签名可能不包含参数列表中的 *this* 指针项，但调用约定始终指示是否需要一个，以及其签名是显式的还是推断的。对值类型的方法的调用，*this* 指针是一个托管指针，而不是实例引用。
 2. 使用 `call`（而不是 `callvirt`）调用虚方法是有效的；这表示方法应根据方法指定的类进行解析，而不是根据被调用的对象动态指定。例如，这用于编译对 "超类上的方法"（即，静态已知的父类）的调用。
 3. 可以使用 `call` 或 `callvirt` 指令调用委托的 `Invoke` 方法。

参数传递就像通过隐式 `starg` 指令传递，参见 [_隐式参数强制转换_](#OpTable9)。`call` 在调用方法之前从求值堆栈中弹出 *this* 指针（如果有）和参数。如果方法有返回值，它将在方法完成时推送到堆栈上。在被调用方，_arg0_ 参数 / *this* 指针作为参数 0 访问，_arg1_ 作为参数 1 访问，依此类推。

> *异常*：

如果系统安全性不授予调用方访问被调用方法的权限，可以抛出 `System.SecurityException`。安全检查可以在 CIL-to-native-code 编译时进行，而不是在运行时。

当试图无效地访问非公共方法时，可以抛出 `System.MethodAccessException`。

当试图动态访问不存在的方法时，可以抛出 `System.MissingMethodException`。

> *正确性*：

正确的 CIL 确保如果需要，堆栈包含一个 *this* 指针，以及为被调用的方法提供正确数量和类型的参数。与验证过的 CIL 不同，正确的 CIL 还允许将 `native int` 作为 **byref** (`&`) 传递；在这种情况下，存储后的值将由垃圾收集进行跟踪。

> *可验证性*：

对于 `call` 指令的典型使用，验证检查：
 1. _method_ 是否引用有效的 *MethodRef*，*MethodDef* 或 *MethodSpec* *token*；
 2. 如果 _method_ 需要一个 *this* 指针，如其方法签名所指定，那么堆栈上有一个，并且其验证类型是 *verifier-assignable-to* [[↗]](#Verification-type-compatibility) 方法签名的*this*签名；
 3. 堆栈上的参数类型是 *verifier-assignable-to* [[↗]](#Verification-type-compatibility) 方法签名的参数签名；
 4. 方法可以从调用点访问；并且
 5. 方法不是抽象的（即，它有一个实现）。

如果调用返回一个值，那么验证也会跟踪返回值的类型作为被调用方法返回类型的中间类型。

`call` 指令也可以用来调用对象的基类构造函数，或者通过调用适当的构造函数初始化值类型位置，这两者都被验证视为特殊情况。由 `tail.` 注释的 `call` 也是一个特殊情况。

如果目标方法是全局的（在任何类型之外定义），那么该方法应该是静态的。

当使用 `call` 操作码在一个非装箱值类型的实例上调用一个非 **final** 虚方法时，验证检查被调用方法的实例引用是 `ldarg.s 0`，`ldarg 0` 或`ldarg.0`的结果，并且调用方的主体不包含 `starg.s 0`，`starg 0` 或 `ldarga.s 0`，`ldarga 0`。

这意味着在子类方法使用相同的 *this* 对象引用调用其超类的情况下，非虚拟地调用非 **final** 虚方法只能进行验证，其中 "相同" 易于验证。这意味着重写实现有效地 "隐藏" 了超类的实现，并且可以假设重写实现不能被类层次结构之外的代码绕过。对于非密封的类层次结构，恶意代码可以尝试扩展类层次结构，试图绕过类的重写实现。然而，这只能在恶意类型的对象上完成，而不能在具有重写的类上完成，这减轻了大部分的安全问题。

>---
### calli ：间接方法调用

 | Format     | Assembly Format         | Description                                             |
 | :--------- | :---------------------- | :------------------------------------------------------ |
 | 29 _\<T\>_ | `calli` _callsitedescr_ | 使用由 _callsitedescr_ 描述的参数调用堆栈上指示的方法。 |

> *堆栈转换*：

&hellip;, _arg0_, _arg1_ &hellip; _argN_, _ftn_ &rarr; &hellip;, _retVal_ (不总是返回)

> *描述*：

`calli` 指令使用参数 _arg0_ &hellip; _argN_ 调用 _ftn_（指向方法入口点的指针）。这些参数的类型由签名 _callsitedescr_ 描述。`calli` 指令可以紧随在 `tail.` 前缀之后，以指定在转移控制权之前应释放当前的方法状态。如果调用将控制权转移到比原始方法更高信任级别的方法，堆栈帧将不会被释放；相反，执行将静默地继续，就好像没有提供 `tail.` 前缀。"更高信任" 的被调用方被定义为其权限授予集是调用方的授予集的严格超集。

_ftn_ 参数必须是一个方法指针，指向一个可以使用由 _callsitedescr_ 描述的参数合法调用的方法（一个独立签名的元数据 *token*）。这样的指针可以使用 `ldftn` 或 `ldvirtftn` 指令创建，或者可能已经从本地代码传入。

独立签名指定了正在传递的参数的数量和类型，以及调用约定。调用约定不会动态检查，因此，如果目标实际上并未使用指定的调用约定，那么使用 `calli` 指令的代码将无法正确工作。

参数按从左到右的顺序放置在堆栈上。也就是说，首先计算并将第一个参数放置在堆栈上，然后是第二个参数，依此类推。实例或虚方法的参数构建代码序列应首先推送该实例引用（*this* 指针，不得为 `null`）。对于对值类型的方法的调用，*this* 指针是一个托管指针，而不是实例引用。

参数传递就像通过隐式 `starg` 指令传递，参见 [_隐式参数强制转换_](#OpTable9)。

`calli` 在调用方法之前从求值堆栈中弹出 *this* 指针（如果有）和参数。如果方法有返回值，那么在方法完成时将其推送到堆栈上。在被调用方，_arg0_ 参数 / *this* 指针作为参数 0 访问，_arg1_ 作为参数 1，依此类推。

> *异常*：

如果系统安全性不授予调用方访问被调用方法的权限，`System.SecurityException`可以被抛出。安全检查可以在  CIL-to-native-code 编译时进行，而不是在运行时。

> *正确性*：

正确的 CIL 要求函数指针包含一个方法的地址，其签名与 _callsitedescr_ 指定的签名 *方法签名兼容*，并且参数正确对应于目标函数的 *this* 指针（如果需要）和参数的类型。为了签名匹配，*`HASTHIS`* 和 *`EXPLICITTHIS`* 标志被忽略；在两个签名中的所有其他项必须相同。与验证过的 CIL 不同，正确的 CIL 还允许将 `native int` 作为 **byref** (`&`) 传递；在这种情况下，存储后的值将由垃圾收集进行跟踪。

在正确的 CIL 中，如果设置了 *`HASTHIS`* 并且没有设置 *`EXPLICITTHIS`*，则 _callsitedescr_ 中不包含实例函数的 *this* 指针的所需类型；但是为了正确，提供的 *this* 参数的类型必须适合被调用的函数。

> *可验证性*：

验证检查：

 1. _ftn_ 的跟踪类型是方法签名（例如，_ftn_ 是由 `ldftn`，`ldvirtfn` 生成的，或者从具有函数类型的变量加载的）；
 2. 如果 _ftn_ 的跟踪方法签名指定了一个实例方法，那么堆栈上有一个 *this* 指针的值，并且其验证类型是 *验证可赋值给* 方法签名的 *this* 指针；并且
 3. 参数类型是 *验证可赋值给* _ftn_ 的跟踪方法签名参数的类型。

如果调用返回一个值，那么验证还会跟踪返回值的类型作为 _ftn_ 的跟踪方法签名的返回类型的中间类型。

在通过 `ldvirtftn` 生成的方法指针调用的情况下，该方法具有静态不确定的 *this* 指针类型（因此没有验证），`calli` 指令不会验证。

验证基于 _ftn_ 的跟踪类型，而不是 _callsitedescr_，因为前者可能在后者不具备的情况下携带 *this* 的类型。然而，验证需要正确性，所以 _ftn_ 的跟踪类型必须与 _sitedescr_ *方法签名兼容*，后者并未被简单地忽略。

>---
### ceq ：比较相等

 | Format | Assembly Format | Description                                                           |
 | :----- | :-------------- | :-------------------------------------------------------------------- |
 | FE 01  | `ceq`           | 如果 _value1_ 等于 _value2_，则推送 1（类型为 `int32`），否则推送 0。 |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;, _result_

> *描述*：

`ceq` 指令比较 _value1_ 和 _value2_。如果 _value1_ 等于 _value2_，则将 1（类型为 `int32`）推送到堆栈上。否则，将 0（类型为 `int32`）推送到堆栈上。

对于浮点数，如果数字无序（即一个或两个参数都是 **NaN**），`ceq` 将返回 0。无穷大的值等于它们自身。

可接受的操作数类型包含在 [*二元比较或分支操作*](#OpTable4) 中。

> *正确性*：

正确的 CIL 在堆栈上提供了两个值，其类型与  [*二元比较或分支操作*](#OpTable4) 中指定的类型匹配。

>---
### cgt ：比较大于

 | Format | Assembly Format | Description                                                        |
 | :----- | :-------------- | :----------------------------------------------------------------- |
 | FE 02  | `cgt`           | 如果 _value1_ > _value2_，则推送 1（类型为 `int32`），否则推送 0。 |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;, _result_

> *描述*：

`cgt` 指令比较 _value1_ 和 _value2_。如果 _value1_ 严格大于 _value2_，则将 1（类型为 `int32`）推送到堆栈上。否则，将 0（类型为 `int32`）推送到堆栈上。

对于浮点数，如果数字无序（即，如果一个或两个参数是 **NaN**），`cgt` 返回 0。与 IEC 60559:1989 一样，无穷大的值与正常的数字有序（例如，+infinity > 5.0 > -infinity）。

可接受的操作数类型包含在 [*二元比较或分支操作*](#OpTable4) 中。

> *正确性*：

正确的 CIL 在堆栈上提供了两个值，其类型与  [*二元比较或分支操作*](#OpTable4) 中指定的类型匹配。

>---
### cgt.un ：比较大于，无符号 / 无序

 | Format | Assembly Format | Description                                                                    |
 | :----- | :-------------- | :----------------------------------------------------------------------------- |
 | FE 03  | `cgt.un`        | 如果 _value1_ > _value2_，无符号或无序，推送 1（类型为 `int32`），否则推送 0。 |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;, _result_

> *描述*：

`cgt.un` 指令比较 _value1_ 和 _value2_。如果满足以下条件之一，将 1（类型为 `int32`）推送到堆栈上：

 * 对于浮点数，_value1_ 严格大于 _value2_，或者 _value1_ 与 _value2_ 无序。
 * 对于整数值，当 _value1_ 被视为无符号数字时，_value1_ 严格大于 _value2_。

否则，将 0（类型为 `int32`）推送到堆栈上。

根据 IEC 60559:1989，无穷大的值与正常的数字有序（例如，+infinity > 5.0 > -infinity）。可接受的操作数类型包含在 [*二元比较或分支操作*](#OpTable4) 中。

> *正确性*：

正确的 CIL 在堆栈上提供了两个值，其类型与  [*二元比较或分支操作*](#OpTable4) 中指定的类型匹配。

>---
### ckfinite ：检查有限实数

 | Format | Assembly Format | Description                                                |
 | :----- | :-------------- | :--------------------------------------------------------- |
 | C3     | `ckfinite`      | 如果 _value_ 不是有限数，抛出 `ArithmeticException` 异常。 |

> *堆栈转换*：

&hellip;, _value_  &hellip;, _value_

> *描述*：

如果 _value_（一个浮点数）是 "not a number" 值（**NaN**）或 +/- 无穷大值，`ckfinite` 指令会抛出 `ArithmeticException` 异常。如果没有抛出异常，`ckfinite` 会将值留在堆栈上。如果 _value_ 不是浮点数，执行行为未指定。

> *异常*：

如果 _value_ 是 **NaN** 或无穷大，将抛出 `System.ArithmeticException` 异常。

> *正确性*：

正确的 CIL 保证 _value_ 是一个浮点数。

>---
### clt ：比较小于

 | Format | Assembly Format | Description                                                      |
 | :----- | :-------------- | :--------------------------------------------------------------- |
 | FE 04  | `clt`           | 如果 _value1_ < _value2_，推送 1（类型为 `int32`），否则推送 0。 |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;, _result_

> *描述*：

`clt` 指令比较 _value1_ 和 _value2_。如果 _value1_ 严格小于 _value2_，则将 1（类型为 `int32`）推送到堆栈上。否则，将 0（类型为 `int32`）推送到堆栈上。

对于浮点数，如果数字无序（即，一个或两个参数都是 **NaN**），`clt` 将返回 0。根据 IEC 60559:1989，无穷大的值与正常的数字有序（例如，+infinity > 5.0 > -infinity）。可接受的操作数类型包含在 [*二元比较或分支操作*](#OpTable4) 中。

> *正确性*：

正确的 CIL 在堆栈上提供了两个值，其类型与  [*二元比较或分支操作*](#OpTable4) 中指定的类型匹配。

>---
### clt.un ：比较小于，无符号 / 无序

 | Format | Assembly Format | Description                                                                    |
 | :----- | :-------------- | :----------------------------------------------------------------------------- |
 | FE 05  | `clt.un`        | 如果 _value1_ < _value2_，无符号或无序，推送 1（类型为 `int32`），否则推送 0。 |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;, _result_

> *描述*：

`clt.un` 指令比较 _value1_ 和 _value2_。如果满足以下条件之一，将 1（类型为 `int32`）推送到堆栈上：
 * 对于浮点数，_value1_ 严格小于 _value2_，或者 _value1_ 与 _value2_ 无序。
 * 对于整数值，当 _value1_ 被视为无符号数字时，_value1_ 严格小于 _value2_。

否则，将 0（类型为 `int32`）推送到堆栈上。

根据 IEC 60559:1989，无穷大的值与正常的数字有序（例如，+infinity > 5.0 > -infinity）。可接受的操作数类型包含在 [*二元比较或分支操作*](#OpTable4) 中。

> *正确性*：

正确的 CIL 在堆栈上提供了两个值，其类型与  [*二元比较或分支操作*](#OpTable4) 中指定的类型匹配。

>---
### conv.\<to type\> ：数据转换
<a id="conv-to-type"></a>

 | Format | Assembly Format | Description                                               |
 | :----- | :-------------- | :-------------------------------------------------------- |
 | 67     | `conv.i1`       | 转换为 `int8`，在堆栈上推送 `int32`。                     |
 | 68     | `conv.i2`       | 转换为 `int16`，在堆栈上推送 `int32`。                    |
 | 69     | `conv.i4`       | 转换为 `int32`，在堆栈上推送 `int32`。                    |
 | 6A     | `conv.i8`       | 转换为 `int64`，在堆栈上推送 `int64`。                    |
 | 6B     | `conv.r4`       | 转换为 `float32`，在堆栈上推送 `F`。                      |
 | 6C     | `conv.r8`       | 转换为 `float64`，在堆栈上推送 `F`。                      |
 | D2     | `conv.u1`       | 转换为 `unsigned int8`，在堆栈上推送 `int32`。            |
 | D1     | `conv.u2`       | 转换为 `unsigned int16`，在堆栈上推送 `int32`。           |
 | 6D     | `conv.u4`       | 转换为 `unsigned int32`，在堆栈上推送 `int32`。           |
 | 6E     | `conv.u8`       | 转换为 `unsigned int64`，在堆栈上推送 `int64`。           |
 | D3     | `conv.i`        | 转换为 `native int`，在堆栈上推送 `native int`。          |
 | E0     | `conv.u`        | 转换为 `native unsigned int`，在堆栈上推送 `native int`。 |
 | 76     | `conv.r.un`     | 将无符号整数转换为浮点数，将 `F` 推送到堆栈。             |

> *堆栈转换*：

&hellip;, _value_ &rarr; &hellip;, _result_

> *描述*：

将堆栈顶部的值转换为操作码中指定的类型，并将该转换后的值留在堆栈顶部。堆栈上的验证类型与目标类型的 §[*验证类型*](#verification-types) 中指定的一致。请注意，当它们被加载到求值堆栈时，小于 4 字节的整数值会扩展为 `int32`（而不是 `native int`），并且浮点值会转换为 `F` 类型。

从浮点数转换为整数值会将数字截断为零。当从 `float64` 转换为 `float32` 时，可能会丢失精度。如果值太大，无法适应 `float32`，则返回 IEC 60559:1989 正无穷大（如果值为正）或 IEC 60559:1989 负无穷大（如果值为负）。

如果在将一个整数类型转换为另一个整数类型时发生溢出，高位将被静默地截断。如果结果小于 `int32`，则该值将进行符号扩展以填充槽。如果在将浮点类型转换为整数时发生溢出，或者将浮点值转换为整数的浮点值是 **NaN**，则返回的值是未指定的。`conv.r.un` 操作从堆栈中取出一个整数，将其解释为无符号，并用 `F` 类型的浮点数替换它以表示该整数。

可接受的操作数类型及其相应的结果数据类型包含在 [*转换操作*](#OpTable8) 中。

> *异常*：

永远不会抛出异常。参见 `conv.ovf`，了解在结果类型无法正确表示结果值时将抛出异常的指令。

> *正确性*：

正确的 CIL 在堆栈上至少有一个值，其类型在 [*转换操作*](#OpTable8) 中指定。

> *可验证性*：

表 [*转换操作*](#OpTable8) 指定了在已验证的代码中可接受的类型的受限集合。

>---
### conv.ovf.\<to type\> ：带溢出检测的数据转换

 | Format | Assembly Format | Description                                                                   |
 | :----- | :-------------- | :---------------------------------------------------------------------------- |
 | B3     | `conv.ovf.i1`   | 转换为 `int8`（在堆栈上为 `int32`），并在溢出时抛出异常。                     |
 | B5     | `conv.ovf.i2`   | 转换为 `int16`（在堆栈上为 `int32`），并在溢出时抛出异常。                    |
 | B7     | `conv.ovf.i4`   | 转换为 `int32`（在堆栈上为 `int32`），并在溢出时抛出异常。                    |
 | B9     | `conv.ovf.i8`   | 转换为 `int64`（在堆栈上为 `int64`），并在溢出时抛出异常。                    |
 | B4     | `conv.ovf.u1`   | 转换为 `unsigned int8`（在堆栈上为 `int32`），并在溢出时抛出异常。            |
 | B6     | `conv.ovf.u2`   | 转换为 `unsigned int16`（在堆栈上为 `int32`），并在溢出时抛出异常。           |
 | B8     | `conv.ovf.u4`   | 转换为 `unsigned int32`（在堆栈上为 `int32`），并在溢出时抛出异常             |
 | BA     | `conv.ovf.u8`   | 转换为 `unsigned int64`（在堆栈上为 `int64`），并在溢出时抛出异常。           |
 | D4     | `conv.ovf.i`    | 转换为 `native int`（在堆栈上为 `native int`），并在溢出时抛出异常。          |
 | D5     | `conv.ovf.u`    | 转换为 `native unsigned int`（在堆栈上为 `native int`），并在溢出时抛出异常。 |

> *堆栈转换*：

&hellip;, _value_ &rarr; &hellip;, _result_

> *描述*：

将堆栈顶部的值转换为操作码中指定的类型，并将该转换后的值留在堆栈顶部。如果结果无法用目标类型表示，则抛出异常。

从浮点数转换为整数值会将数字截断为零。请注意，当它们被加载到评估堆栈时，小于 4 字节的整数值会扩展为 `int32`（而不是 `native int`）。

可接受的操作数类型及其相应的结果数据类型包含在 [*转换操作*](#OpTable8) 中。

> *异常*：

如果结果无法用结果类型表示，将抛出 `System.OverflowException` 异常。

> *正确性*：

正确的 CIL 在堆栈上至少有一个值，其类型在 [*转换操作*](#OpTable8) 中指定。

> *可验证性*：

表 [*转换操作*](#OpTable8) 指定了在已验证的代码中可接受的类型的受限集合。

>---
### conv.ovf.\<to type\>.un ：带溢出检测的无符号数据转换

 | Format | Assembly Format  | Description                                                                   |
 | :----- | :--------------- | :---------------------------------------------------------------------------- |
 | 82     | `conv.ovf.i1.un` | 转换为 `int8`（在堆栈上为 `int32`），并在溢出时抛出异常。                     |
 | 83     | `conv.ovf.i2.un` | 转换为 `int16`（在堆栈上为 `int32`），并在溢出时抛出异常。                    |
 | 84     | `conv.ovf.i4.un` | 转换为 `int32`（在堆栈上为 `int32`），并在溢出时抛出异常。                    |
 | 85     | `conv.ovf.i8.un` | 转换为 `int64`（在堆栈上为 `int64`），并在溢出时抛出异常。                    |
 | 86     | `conv.ovf.u1.un` | 转换为 `unsigned int8`（在堆栈上为 `int32`），并在溢出时抛出异常。            |
 | 87     | `conv.ovf.u2.un` | 转换为 `unsigned int16`（在堆栈上为 `int32`），并在溢出时抛出异常。           |
 | 88     | `conv.ovf.u4.un` | 转换为 `unsigned int32`（在堆栈上为 `int32`），并在溢出时抛出异常。           |
 | 89     | `conv.ovf.u8.un` | 转换为 `unsigned int64`（在堆栈上为 `int64`），并在溢出时抛出异常。           |
 | 8A     | `conv.ovf.i.un`  | 转换为 `native int`（在堆栈上为 `native int`），并在溢出时抛出异常。          |
 | 8B     | `conv.ovf.u.un`  | 转换为 `native unsigned int`（在堆栈上为 `native int`），并在溢出时抛出异常。 |

> *堆栈转换*：

&hellip;, _value_ &rarr; &hellip;, _result_

> *描述*：

将堆栈顶部的值转换为操作码中指定的类型，并将该转换后的值留在堆栈顶部。如果值无法表示，则抛出异常。在转换之前，堆栈顶部的项被视为无符号值。

从浮点数转换为整数值会将数字截断为零。请注意，当它们被加载到求值堆栈时，小于 4 字节的整数值会扩展为 `int32`（而不是 `native int`）。

可接受的操作数类型及其相应的结果数据类型包含在 [*转换操作*](#OpTable8) 中。

> *异常*：

如果结果无法用结果类型表示，将抛出 `System.OverflowException` 异常。

> *正确性*：

正确的 CIL 在堆栈上至少有一个值，其类型在 [*转换操作*](#OpTable8) 中指定。

> *可验证性*：

表 [*转换操作*](#OpTable8) 指定了在已验证的代码中可接受的类型的受限集合。

>---
### cpblk ：从内存复制数据到内存

 | Format | Assembly Format | Description            |
 | :----- | :-------------- | :--------------------- |
 | FE 17  | `cpblk`         | 从内存复制数据到内存。 |

> *堆栈转换*：

&hellip;, _destaddr_, _srcaddr_, _size_ &rarr; &hellip;

> *描述*：

`cpblk` 指令从地址 _srcaddr_（类型为 `native int` 或 `&`）复制 _size_（类型为 `unsigned int32`）字节到地址 _destaddr_（类型为 `native int` 或 `&`）。如果源和目标区域重叠，`cpblk` 的行为未指定。

`cpblk` 假定 _destaddr_ 和 _srcaddr_ 都对齐到机器的自然大小（但请参阅 `unaligned.` 前缀指令）。`cpblk` 指令的操作可以通过紧接在前的 `volatile.` 或 `unaligned.` 前缀指令进行更改。

`cpblk` 旨在复制结构（而不是任意字节运行）。所有这些结构，由 CLI 分配，都自然对齐到当前平台。因此，生成 `cpblk` 指令的编译器无需知道代码最终是否会在 32 位或 64 位平台上执行。

> *异常*：

如果检测到无效地址，可以抛出 `System.NullReferenceException` 异常。

> *正确性*：

CIL 确保了上述条件。

> *可验证性*：

`cpblk` 指令永远不可验证。

>---
### div ：除法运算

 | Format | Assembly Format | Description                        |
 | :----- | :-------------- | :--------------------------------- |
 | 5B     | `div`           | 除法运算两个值，返回商或浮点结果。 |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;, _result_

> *描述*：

_result_ = _value1_ `div` _value2_ 满足以下条件：

 * \|_result_\| = \|_value1_\| / \|_value2_\|，并且
 * 如果 sign(_value1_) = sign(_value2_)，则 sign(_result_) = +，或者  
   如果 sign(_value1_) ~= sign(_value2_)，则 sign(_result_) = -

```cil
 +14 div +3 = 4
 +14 div -3 = -4
 -14 div +3 = -4
 -14 div -3 = 4
```

`div` 指令计算 _result_ 并将其推送到堆栈。整数除法向零截断。

浮点除法按照 IEC 60559:1989。特别地，有限数除以 0 产生正确符号的无穷大值，并且
 * 0 / 0 = NaN
 * infinity / infinity = **NaN**
 * X / infinity = 0

可接受的操作数类型及其相应的结果数据类型包含在 [*二元数值运算*](#OpTable2) 中。

> *异常*：

如果结果无法用结果类型表示，整数运算会抛出 `System.ArithmeticException` 异常。如果 _value1_ 是最小可表示的整数值，且 _value2_ 是 -1，就会发生这种情况。

如果 _value2_ 是零，整数运算会抛出 `DivideByZeroException` 异常。

浮点运算永远不会抛出异常，它们会产生 **NaN** 或无穷大

> *正确性和可验证性*：

参见 [*二元数值运算*](#OpTable2)。

>---
### div.un ：除法运算整数值，无符号

 | Format | Assembly Format | Description                      |
 | :----- | :-------------- | :------------------------------- |
 | 5C     | `div.un`        | 除法运算两个值，无符号，返回商。 |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;, _result_

> *描述*：

`div.un` 指令计算 _value1_ 除以 _value2_，两者都被视为无符号整数，并将结果推送到堆栈。

```cil
 +5 `div.un` +3 = 1
 +5 `div.un` -3 = 0
 -5 `div.un` +3 = 14316557630 // 或 0x55555553
 -5 `div.un` -3 = 0
```

可接受的操作数类型及其相应的结果数据类型包含在 [*整数运算*](#OpTable5) 中。

> *异常*：

如果 _value2_ 是零，将抛出 `System.DivideByZeroException` 异常。

> *正确性和可验证性*：

参见 [*整数运算*](#OpTable5)。

>---
### dup ：复制堆栈顶部的值

| Format | Assembly Format | Description        |
| :----- | :-------------- | :----------------- |
| 25     | `dup`           | 复制堆栈顶部的值。 |

> *堆栈转换*：

&hellip;, _value_ &rarr; &hellip;, _value_, _value_

> *描述*：

`dup` 指令复制堆栈顶部的元素。

>---
### endfilter ：结束异常处理过滤器子句

| Format | Assembly Format | Description              |
| :----- | :-------------- | :----------------------- |
| FE 11  | `endfilter`     | 结束异常处理过滤器子句。 |

> *堆栈转换*：

&hellip;, _value_ &rarr; &hellip;

> *描述*：

用于从异常的 **filter** 子句返回的 _Exception Handling_ 子句以讨论异常。从 **filter** 子句返回 _value_（应为 `int32` 类型，并且是特定值集中的一个）。它应该是：
 * `exception_continue_search`（0）继续搜索异常处理程序
 * `exception_execute_handler`（1）开始执行异常处理的第二阶段，其中 **finally** 块运行，直到找到与此 **filter** 子句关联的处理程序。然后执行处理程序。

使用任何其他整数值的结果是未指定的。

过滤器的入口点，如方法的异常表所示，应该是 **filter** 的代码块中（从词法上）的第一条指令。`endfilter` 应该是过滤器的代码块中（从词法上）的最后一条指令（因此，对于任何单个过滤器块，只能有一个 `endfilter`）。执行 `endfilter` 指令后，控制逻辑上流回到 CLI 异常处理机制。

除了通过异常机制，不能将控制转移到 **filter** 块中。除了使用 `throw` 指令或执行最后的 `endfilter` 指令，不能将控制从 **filter** 块中转移出去。特别地，在 **filter** 块中执行 `ret` 或 `leave` 指令是无效的。在 **filter** 块中嵌入 **try** 块是无效的。如果在 **filter** 块内部抛出异常，它将被拦截，返回 `exception_continue_search` 的值。

> *正确性*：

正确的 CIL 保证了上述控制转移限制。

> *可验证性*：

堆栈应包含恰好一个元素（类型为 `int32`）。

>---
### endfinally ：结束异常块的 finally 或 fault 子句

| Format | Assembly Format | Description                     |
| :----- | :-------------- | :------------------------------ |
| DC     | `endfault`      | 结束异常块的 **fault** 子句。   |
| DC     | `endfinally`    | 结束异常块的 **finally** 子句。 |

> *堆栈转换*：

&hellip; &rarr; &hellip;

> *描述*：

从异常块的 **finally** 或 **fault** 子句返回。

标志 **finally** 或 **fault** 子句的结束，以便堆栈展开可以继续，直到调用异常处理程序。`endfinally` 或 `endfault` 指令将控制权转回 CLI 异常机制。然后，如果通过 `leave` 指令退出了受保护的块，它将搜索链中的下一个 **finally** 子句。如果通过异常退出了受保护的块，CLI 将搜索下一个 **finally** 或 **fault**，或者进入在异常处理的第一遍中选择的异常处理程序。

`endfinally` 指令只能在 **finally** 块中出现（从词法上）。与 `endfilter` 指令不同，没有要求块以 `endfinally` 指令结束，并且块中可以有尽可能多的 `endfinally` 指令。这些相同的限制适用于 `endfault` 指令和 **fault** 块，*mutatis mutandis*。

除了通过异常机制，不能将控制转移到 **finally**（或 **fault**）块中。除了使用 `throw` 指令或执行 `endfinally`（或 `endfault`）指令，不能将控制从 **finally**（或 **fault**）块中转移出去。特别地，在 **finally**（或 **fault**）块中 "掉出" 或执行 `ret` 或 `leave` 指令是无效的。

注意，`endfault` 和 `endfinally` 指令是别名 —— 它们对应相同的操作码。

`endfinally` 作为副作用清空了评估堆栈。

> *正确性*：

正确的 CIL 保证了上述控制转移限制。

>---
### initblk ：将一块内存初始化为一个值

| Format | Assembly Format | Description                              |
| :----- | :-------------- | :--------------------------------------- |
| FE 18  | `initblk`       | 将一块内存的所有字节设置为给定的字节值。 |

> *堆栈转换*：

&hellip;, _addr_, _value_, _size_ &rarr; &hellip;

> *描述*：

`initblk` 指令将从 _addr_（类型为 `native int` 或 `&`）开始的 _size_（类型为 `unsigned int32`）字节设置为 _value_（类型为 `unsigned int8`）。`initblk` 假定 _addr_ 对齐到机器的自然大小（但请参阅 `unaligned.` 前缀指令）。

`initblk` 旨在初始化结构（而不是任意字节运行）。所有这些结构，由 CLI 分配，都自然对齐到当前平台。因此，生成 `initblk` 指令的编译器无需知道代码最终是否会在 32 位或 64 位平台上执行。

`initblk` 指令的操作可以通过紧接在前的 `volatile.` 或 `unaligned.` 前缀指令进行更改。

> *异常*：

如果检测到无效地址，可以抛出 `System.NullReferenceException` 异常。

> *正确性*：

正确的 CIL 代码确保了上述限制。

> *可验证性*：

`initblk` 指令永远不可验证。

>---
### jmp ：跳转到方法

| Format     | Assembly Format | Description                      |
| :--------- | :-------------- | :------------------------------- |
| 27 _\<T\>_ | `jmp` _method_  | 退出当前方法并跳转到指定的方法。 |

> *堆栈转换*：

&hellip; &rarr; &hellip;

> *描述*：

将控制权转移到由 _method_ 指定的方法，该方法是元数据 *token*（*MethodRef* 或 *MethodDef*）。当前的参数被传递给目标方法。

当执行此指令时，求值堆栈应为空。目标地址处的调用约定、参数数量和类型应与当前方法匹配。

`jmp` 指令不能用于将控制权转移出 **try**、**filter**、**catch**、**fault** 或 **finally** 块；或者从同步区域转移出。如果这样做，结果是未定义的。

> *正确性*：

正确的 CIL 代码遵守上述控制流限制。

> *可验证性*：

`jmp` 指令永远不可验证。

>---
### ldarg.\<length\> ：将参数加载到堆栈

| Format                     | Assembly Format | Description                               |
| :------------------------- | :-------------- | :---------------------------------------- |
| FE 09 _\<unsigned int16\>_ | `ldarg` _num_   | 将编号为 _num_ 的参数加载到堆栈。         |
| 0E _\<unsigned int8\>_     | `ldarg.s` _num_ | 将编号为 _num_ 的参数加载到堆栈，短格式。 |
| 02                         | `ldarg.0`       | 将参数 0 加载到堆栈。                     |
| 03                         | `ldarg.1`       | 将参数 1 加载到堆栈。                     |
| 04                         | `ldarg.2`       | 将参数 2 加载到堆栈。                     |
| 05                         | `ldarg.3`       | 将参数 3 加载到堆栈。                     |

> *堆栈转换*：

&hellip; &rarr; &hellip;, _value_

> *描述*：

`ldarg` _num_ 指令将 _num_'th 传入参数推送到求值堆栈，其中参数从 0 开始编号。堆栈上的值的类型由验证作为参数类型的 *中间类型* 进行跟踪，该参数类型由当前方法的签名指定。

`ldarg.0`、`ldarg.1`、`ldarg.2` 和 `ldarg.3` 指令是加载前 4 个参数中的任何一个的高效编码。`ldarg.s` 指令是加载参数编号 4 ~ 255 的高效编码。

对于采用可变长度参数列表的过程，`ldarg` 指令只能用于初始固定参数，而不能用于签名的可变部分。参见 `arglist` 指令。

如果需要，当参数加载到堆栈时，参数会转换为其中间类型的表示形式 [[↗]](#numeric-data-types)。

即，保存小于 4 字节的整数值、布尔值或字符的参数通过适当的符号或零扩展转换为 4 字节。浮点值转换为其本地大小（类型 `F`）。

> *正确性*：

正确的 CIL 保证 _num_ 是有效的参数索引。

> *可验证性*：

验证 [[↗]](#Verifiability) 跟踪堆栈上加载的值的类型，作为方法声明的参数类型的 *中间类型*。

>---
### ldarga.\<length\> ：加载参数地址

| Format                     | Assembly Format     | Description                        |
| :------------------------- | :------------------ | :--------------------------------- |
| FE 0A _\<unsigned int16\>_ | `ldarga` _argNum_   | 获取参数 _argNum_ 的地址。         |
| 0F _\<unsigned int8\>_     | `ldarga.s` _argNum_ | 获取参数 _argNum_ 的地址，短格式。 |

> *堆栈转换*：

&hellip;, &rarr; &hellip;, 参数编号 _argNum_ 的地址

> *描述*：

`ldarga` 指令获取 _argNum_'th 参数的地址（类型为 `&`，即托管指针），其中参数从 0 开始编号。地址将始终对齐到目标机器的自然边界（参见 `cpblk` 和 `initblk`）。短格式（`ldarga.s`）应用于参数编号 0 ~ 255。结果是一个托管指针（类型 `&`）。

对于采用可变长度参数列表的过程，`ldarga` 指令只能用于初始固定参数，而不能用于签名的可变部分。

`ldarga` 用于 **byref** 参数传递。在其他情况下，应使用 `ldarg` 和 `starg`。

> *正确性*：

正确的 CIL 确保 _argNum_ 是有效的参数索引。

> *可验证性*：

验证 [[↗]](#Verifiability) 跟踪堆栈上加载的值的类型，作为方法声明的参数类型的 *验证类型* 的托管指针。

>---
### ldc.\<type\> ：加载数值常量

| Format           | Assembly Format  | Description                                                           |
| :--------------- | :--------------- | :-------------------------------------------------------------------- |
| 20 _\<int32\>_   | `ldc.i4` _num_   | 将类型为 `int32` 的 _num_ 推送到堆栈作为 `int32`。                    |
| 21 _\<int64\>_   | `ldc.i8` _num_   | 将类型为 `int64` 的 _num_ 推送到堆栈作为 `int64`。                    |
| 22 _\<float32\>_ | `ldc.r4` _num_   | 将类型为 `float32` 的 _num_ 推送到堆栈作为 `F`。                      |
| 23 _\<float64\>_ | `ldc.r8` _num_   | 将类型为 `float64` 的 _num_ 推送到堆栈作为 `F`。                      |
| 16               | `ldc.i4.0`       | 将 0 推送到堆栈作为 `int32`。                                         |
| 17               | `ldc.i4.1`       | 将 1 推送到堆栈作为 `int32`。                                         |
| 18               | `ldc.i4.2`       | 将 2 推送到堆栈作为 `int32`。                                         |
| 19               | `ldc.i4.3`       | 将 3 推送到堆栈作为 `int32`。                                         |
| 1A               | `ldc.i4.4`       | 将 4 推送到堆栈作为 `int32`。                                         |
| 1B               | `ldc.i4.5`       | 将 5 推送到堆栈作为 `int32`。                                         |
| 1C               | `ldc.i4.6`       | 将 6 推送到堆栈作为 `int32`。                                         |
| 1D               | `ldc.i4.7`       | 将 7 推送到堆栈作为 `int32`。                                         |
| 1E               | `ldc.i4.8`       | 将 8 推送到堆栈作为 `int32`。                                         |
| 15               | `ldc.i4.m1`      | 将 -1 推送到堆栈作为 `int32`。                                        |
| 15               | `ldc.i4.M1`      | 将类型为 `int32` 的 -1 推送到堆栈作为 `int32`（`ldc.i4.m1` 的别名）。 |
| 1F _\<int8\>_    | `ldc.i4.s` _num_ | 将 _num_ 推送到堆栈作为 `int32`，短格式。                             |

> *堆栈转换*：

&hellip; &rarr; &hellip;, _num_

> *描述*：

`ldc` _num_ 指令将数字 _num_ 或某个常数推送到堆栈。对于整数 -128 ~ 127，有特殊的短编码（对于 -1 ~ 8，有特别短的编码）。所有短编码在堆栈上推送 4 字节整数。长编码用于 8 字节整数和 4 字节和 8 字节浮点数，以及不适合短格式的 4 字节值。

有三种方式将 8 字节整数常量推送到堆栈
 1. 对于需要用超过 32 位表示的常量，使用 `ldc.i8` 指令。
 2. 对于需要 9 ~ 32 位的常量，使用 `ldc.i4` 指令，然后是 `conv.i8`。
 3. 对于可以用 8 位或更少位表示的常量，使用短格式指令，然后是 `conv.i8`。

没有办法表示比 64 位 IEC 60559:1989 数字具有更大范围或更高精度的浮点常量，因为这些表示在架构之间不可移植。

> *可验证性*：

`ldc` 指令始终可验证。

>---
### ldftn : 加载方法指针

| Format        | Assembly Format  | Description                                        |
| :------------ | :--------------- | :------------------------------------------------- |
| FE 06 _\<T\>_ | `ldftn` _method_ | 将一个指向由 _method_ 引用的方法的指针推送到堆栈。 |

> *堆栈转换*：

&hellip; &rarr; &hellip;, _ftn_

> *描述*：

`ldftn` 指令将一个方法指针推送到实现由 _method_ 描述的方法的本地代码（元数据 *token*，是 *MethodDef* 或 *MethodRef*，或者推送到 _method_ 的其他实现特定描述到堆栈）。如果它引用了托管方法（或从托管代码转换到非托管代码的存根），则可以使用 `calli` 指令调用推送的值。它也可以用于构造委托，存储在变量中等。

CLI 根据 [[↗]](./01_CLI%20基本概念和体系结构.md/#computed-destinations)（计算目标）中指定的规则解析方法指针，除了目标是根据 _method_ 指定的类计算的。

返回的值指向使用 _method_ 指定的调用约定的本地代码。因此，方法指针可以传递给非托管本地代码（例如，作为回调例程）。请注意，此指令计算的地址可以是为此目的专门生成的 *thunk*（例如，当方法的本地版本不可用时，重新进入 CIL 解释器）。

实现此指令有许多选项。从概念上讲，此指令将方法指定的地址的表示形式放在虚拟机的评估堆栈上。就本机代码而言，这可以是一个地址（如指定的），包含地址的数据结构，或者任何可以用来计算地址的值，具体取决于底层机器的架构、本机调用约定以及 VES 的实现技术（JIT、解释器、线程代码等）。

> *异常*：

当尝试非法访问非公共方法时，可以抛出 `System.MethodAccessException` 异常。

> *正确性*：

正确的 CIL 要求方法是有效的 *MethodDef* 或 *Methodref* *token*。

> *可验证性*：

验证跟踪值的方法签名，其中包括参数的数量和类型，*this* 指针的类型（对于实例方法），以及返回类型和调用约定。另请参见 `newobj` 指令。

>---
### ldind.\<type\> ：间接加载值到堆栈

| Format | Assembly Format | Description                                                                      |
| :----- | :-------------- | :------------------------------------------------------------------------------- |
| 46     | `ldind.i1`      | 将类型为 `int8` 的值作为 `int32` 间接加载到堆栈。                                |
| 48     | `ldind.i2`      | 将类型为 `int16` 的值作为 `int32` 间接加载到堆栈。                               |
| 4A     | `ldind.i4`      | 将类型为 `int32` 的值作为 `int32` 间接加载到堆栈。                               |
| 4C     | `ldind.i8`      | 将类型为 `int64` 的值作为 `int64` 间接加载到堆栈。                               |
| 47     | `ldind.u1`      | 将类型为 `unsigned int8` 的值作为 `int32` 间接加载到堆栈。                       |
| 49     | `ldind.u2`      | 将类型为 `unsigned int16` 的值作为 `int32` 间接加载到堆栈。                      |
| 4B     | `ldind.u4`      | 将类型为 `unsigned int32` 的值作为 `int32` 间接加载到堆栈。                      |
| 4E     | `ldind.r4`      | 将类型为 `float32` 的值作为 `F` 间接加载到堆栈。                                 |
| 4C     | `ldind.u8`      | 将类型为 `unsigned int64` 的值作为 `int64` 间接加载到堆栈（`ldind.i8` 的别名）。 |
| 4F     | `ldind.r8`      | 将类型为 `float64` 的值作为 `F` 间接加载到堆栈。                                 |
| 4D     | `ldind.i`       | 将类型为 `native int` 的值作为 `native int` 间接加载到堆栈                       |
| 50     | `ldind.ref`     | 将类型为对象引用的值作为 `O` 间接加载到堆栈。                                    |

> *堆栈转换*：

&hellip;, _addr_ &rarr; &hellip;, _value_

> *描述*：

`ldind.<type>` 指令从地址 _addr_（非托管指针，`native int`，或托管指针，`&`）间接加载一个值到堆栈。源值由指令后缀指示。`ldind.ref` 指令是一个 `ldobj` 指令的快捷方式，该指令指定由 _addr_ 指向的类型，所有其他 `ldind` 指令都是 `l`dobj 指令的快捷方式，该指令指定相应的内置值类。

如果需要，当值加载到堆栈时，值会转换为指令中 _\<type\>_ 的*中间类型* 的表示形式。即，整数值小于 4 字节，布尔值，或字符通过适当的符号或零扩展转换为 4 字节。浮点值转换为 `F` 类型。

正确的 CIL 确保 `ldind` 指令的使用方式与指针的类型一致。

由 _addr_ 指定的地址应该是 _\<type\>_ 的自然对齐位置，否则可能会发生 `NullReferenceException` 异常（但请参见 `unaligned.` 前缀指令）。所有返回地址的 CIL 指令（例如，`ldloca` 和 `ldarga`）的结果都是安全对齐的。对于大于 1 字节的数据类型，字节顺序取决于目标 CPU。依赖字节顺序的代码可能无法在所有平台上运行。

`ldind` 指令的操作可以通过紧接在前的 `volatile.` 或 `unaligned.` 前缀指令进行更改。

需要小整数类型的有符号和无符号形式，以便 CLI 可以知道是进行符号扩展还是零扩展。`ldind.u8` 和 `ldind.u4` 变体是为了方便提供的；`ldind.u8` 是 `ldind.i8` 的别名；`ldind.u4` 和 `ldind.i4` 有不同的操作码，但它们的效果是相同的。

> *异常*：

如果检测到无效地址，可以抛出 `System.NullReferenceException` 异常。

> *正确性*：

正确的 CIL 只能以与指针类型一致的方式使用 `ldind` 指令。对于 `ldind.ref`，由 _addr_ 指向的类型不能是泛型参数。可以使用泛型参数类型的 `ldobj` 指令。

> *可验证性*：

对于 `ldind.ref`，_addr_ 应该是托管指针，`T&`，`T` 应该是引用类型，并且验证跟踪结果值的类型作为 `T` 的*验证类型*。

对于其他指令变体，_addr_ 应该是托管指针，`T&`，并且 `T` 应该是 *可赋值给* 指令中的 \<type\>。验证将结果值的类型跟踪为 \<type\> 的中间类型。

>---
### ldloc ：将局部变量加载到堆栈

| Format                     | Assembly Format  | Description                                    |
| :------------------------- | :--------------- | :--------------------------------------------- |
| FE 0C _\<unsigned int16\>_ | `ldloc` _indx_   | 将索引为 _indx_ 的局部变量加载到堆栈。         |
| 11 _\<unsigned int8\>_     | `ldloc.s` _indx_ | 将索引为 _indx_ 的局部变量加载到堆栈，短格式。 |
| 06                         | `ldloc.0`        | 将局部变量 0 加载到堆栈。                      |
| 07                         | `ldloc.1`        | 将局部变量 1 加载到堆栈。                      |
| 08                         | `ldloc.2`        | 将局部变量 2 加载到堆栈。                      |
| 09                         | `ldloc.3`        | 将局部变量 3 加载到堆栈。                      |

> *堆栈转换*：

&hellip; &rarr; &hellip;, _value_

> *描述*：

`ldloc` _indx_ 指令将局部变量编号 _indx_ 的内容推送到评估堆栈，其中局部变量从 0 开始编号。只有当方法上的 **localsinit** 为真时，局部变量才在进入方法前初始化为 0。`ldloc.0`、`ldloc.1`、`ldloc.2` 和 `ldloc.3` 指令为访问前 4 个局部变量提供了有效的编码。`ldloc.s` 指令为访问局部变量 4 ~ 255 提供了有效的编码。

堆栈上的值的类型由验证作为局部变量类型的中间类型进行跟踪，该类型在方法头中指定。

如果需要，当局部变量加载到堆栈时，局部变量会转换为其中间类型的表示形式。即，局部变量小于 4 字节，布尔值或字符通过适当的符号或零扩展转换为 4 字节。浮点值转换为其本机大小（类型 `F`）。

> *异常*：

如果此方法的 **localsinit** 位未设置，并且包含此方法的程序集未被授予 `System.Security.Permissions.SecurityPermission.SkipVerification`（并且 CIL 不执行自动确定分配分析），则会抛出 `System.VerificationException` 异常。

> *正确性*：

正确的 CIL 确保 _indx_ 是有效的局部索引。对于 `ldloc` _indx_ 指令，_indx_ 应在 0 ~ 65534（包含）的范围内（具体来说，65535 是无效的）。

排除 65535 的原因是实用的：可能的实现将使用一个 2 字节的整数来跟踪局部的索引，以及给定方法的局部总数。如果一个索引为 65535 是有效的，那么它将需要一个更宽的整数来跟踪这样一个方法的局部数量。

> *可验证性*：

对于可验证的代码，此指令应保证它不是加载一个未初始化的值 — 无论是通过为方法设置 **localsinit** 位来显式初始化，还是通过之前的指令（其中 CLI 执行确定分配分析）。

验证跟踪堆栈上加载的值的类型，作为局部变量的中间类型。

>---
### ldloca.\<length\> ：加载局部变量地址

| Format                     | Assembly Format   | Description                                  |
| :------------------------- | :---------------- | :------------------------------------------- |
| FE 0D _\<unsigned int16\>_ | `ldloca` _indx_   | 加载索引为 _indx_ 的局部变量的地址。         |
| 12 _\<unsigned int8\>_     | `ldloca.s` _indx_ | 加载索引为 _indx_ 的局部变量的地址，短格式。 |

> *堆栈转换*：

&hellip; &rarr; &hellip;, _address_

> *描述*：

`ldloca` 指令将局部变量编号 _indx_ 的地址推送到堆栈，其中局部变量从 0 开始编号。推送到堆栈的值已经正确对齐，可用于 `ldind` 和 `stind` 等指令。结果是一个托管指针（类型 `&`）。`ldloca.s` 指令为使用局部变量 0 ~ 255 提供了有效的编码。`ldloca` 主体的局部变量应按照 `ldind` 指令中描述的方式对齐，因为 `ldloca` 获得的地址可以用作 `ldind` 的参数。

> *异常*：

如果此方法的 **localsinit** 位未设置，并且包含此方法的程序集未被授予 `System.Security.Permissions.SecurityPermission.SkipVerification`（并且 CIL 不执行自动确定分配分析），则会抛出 `System.VerificationException` 异常。

> *正确性*：

正确的 CIL 确保 _indx_ 是有效的局部索引。

对于 `ldloca` _indx_ 指令，_indx_ 应在 0 ~ 65534（包含）的范围内（具体来说，65535 是无效的）。

排除 65535 的原因是实用的：可能的实现将使用一个 2 字节的整数来跟踪局部的索引，以及给定方法的局部总数。如果一个索引为 65535 是有效的，那么它将需要一个更宽的整数来跟踪这样一个方法的局部数量。

> *可验证性*：

验证跟踪堆栈上加载的值的类型，作为局部变量的验证类型的托管指针。对于可验证的代码，此指令应保证它不是加载一个未初始化的值的地址 — 无论是通过为方法设置 **localsinit** 位来显式初始化，还是通过之前的指令（其中 CLI 执行确定分配分析）。

>---
### ldnull ：加载空指针

| Format | Assembly Format | Description              |
| :----- | :-------------- | :----------------------- |
| 14     | `ldnull`        | 在堆栈上推送一个空引用。 |

> *堆栈转换*：

&hellip; &rarr; &hellip;, null value

> *描述*：

`ldnull` 在堆栈上推送一个空引用（类型 `O`）。这用于在位置变为活动之前或变为死亡时初始化位置。

可能会认为 `ldnull` 是冗余的：为什么不使用 `ldc.i4.0` 或 `ldc.i8.0` 呢？答案是 `ldnull` 提供了一个大小不定的空 — 类似于 `ldc.i` 指令，该指令不存在。然而，即使 CIL 包含了 `ldc.i` 指令，保留 `ldnull` 指令仍然会使验证算法受益，因为它使类型跟踪更容易。

> *可验证性*：

`ldnull` 指令始终可验证，并生成空类型的值，该值是 *可分配给* 任何其他引用类型。

>---
### leave.\<length\> ：退出代码的受保护区域

| Format         | Assembly Format    | Description                    |
| :------------- | :----------------- | :----------------------------- |
| DD _\<int32\>_ | `leave` _target_   | 退出代码的受保护区域。         |
| DE _\<int8\>_  | `leave.s` _target_ | 退出代码的受保护区域，短格式。 |

> *堆栈转换*：

&hellip;, &rarr;

> *描述*：

`leave` 指令无条件地将控制权转移到 _target_。_target_ 表示为从当前指令后的指令开始的有符号偏移（`leave` 为 4 字节，`leave.s` 为 1 字节）。

`leave` 指令类似于 `br` 指令，但前者可以用于退出 **try**、**filter** 或 **catch** 块，而普通的分支指令只能在这样的块中用于在其内部传输控制。`leave` 指令清空求值堆栈，并确保执行适当的周围 **finally** 块。

不允许使用 `leave` 指令退出 **finally** 块。为了简化异常处理程序的代码生成，可以在 **catch** 块内使用 `leave` 指令将控制权转移到关联 **try** 块内的任何指令。

`leave` 指令可以用于退出多个嵌套的块。

如果一个指令有一个或多个前缀代码，控制只能转移到这些前缀中的第一个。

> *正确性*：

正确的 CIL 要求计算的目标位于当前方法内。

> *可验证性*：

参见 §[[↗]](#Verifiability) 以获取详细信息。

>---
### localloc ：在局部动态内存池中分配空间

| Format | Assembly Format | Description            |
| :----- | :-------------- | :--------------------- |
| FE 0F  | `localloc`      | 从局部内存池分配空间。 |

> *堆栈转换*：

_size_ &rarr; _address_

> *描述*：

`localloc` 指令从局部动态内存池分配 _size_（类型为 `native unsigned int` 或 `U4`）字节，并返回第一个分配字节的地址（非托管指针，类型为 `native int`）。如果方法上的 **localsinit** 标志为真，则返回的内存块初始化为 0；否则，该内存块的初始值是未指定的。内存区域是新分配的。当当前方法返回时，局部内存池可供重用。

_address_ 已对齐，以便可以使用 `stind` 指令将任何内置数据类型存储在那里，并使用 `ldind` 指令加载。

`localloc` 指令不能出现在异常块中：**filter**、**catch**、**finally** 或 **fault**。

`localloc` 用于创建局部聚合，其大小将在运行时计算。它可以用于 C 的内置 `alloca` 方法。

> *异常*：

如果没有足够的内存来服务请求，将抛出 `System.StackOverflowException` 异常。

> *正确性*：

正确的 CIL 要求评估堆栈为空，除了 _size_ 项

> *可验证性*：

此指令永远不可验证。

>---
### mul ：乘法运算

| Format | Assembly Format | Description |
| :----- | :-------------- | :---------- |
| 5A     | `mul`           | 乘法运算。  |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;, _result_

> *描述*：

`mul` 指令将 _value1_ 与 _value2_ 相乘，并将结果推送到堆栈。整数运算在溢出时静默地截断高位位（参见 `mul.ovf`）。

对于浮点类型，0 &times; infinity = **NaN**。

可接受的操作数类型及其相应的结果数据类型包含在 [*二元数值操作*](#OpTable2) 中。

> *正确性和可验证性*：

参见 [*二元数值操作*](#OpTable2)。

>---
### mul.ovf.\<type\> ：带溢出检查的乘法运算

| Format | Assembly Format | Description                                    |
| :----- | :-------------- | :--------------------------------------------- |
| D8     | `mul.ovf`       | 乘以有符号整数值。有符号结果应适合相同的大小。 |
| D9     | `mul.ovf.un`    | 乘以无符号整数值。无符号结果应适合相同的大小。 |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;, _result_

> *描述*：

`mul.ovf` 指令将整数 _value1_ 和 _value2_ 相乘，并将结果推送到堆栈。如果结果不适合结果类型，将抛出异常。

可接受的操作数类型及其相应的结果数据类型包含在 [*溢出算数运算*](#OpTable7) 中。

> *异常*：

如果结果不能表示为结果类型，将抛出 `System.OverflowException` 异常。

> *正确性和可验证性*：

参见 [*溢出算数运算*](#OpTable7)。

>---
### neg ：取反

| Format | Assembly Format | Description |
| :----- | :-------------- | :---------- |
| 65     | `neg`           | 取反。      |

> *堆栈转换*：

&hellip;, _value_ &rarr; &hellip;, _result_

> *描述*：

`neg` 指令取反 _value_ 并将结果推送到堆栈顶部。返回类型与操作数类型相同。

整数值的取反是标准的二进制补码取反。特别地，取反最负的数（没有正的对应数）会得到最负的数。要检测此溢出，使用 `sub.ovf` 指令代替（即，从 0 减去）。

取反浮点数不能溢出；取反 **NaN** 返回 **NaN**。可接受的操作数类型及其相应的结果数据类型包含在 [*一元数值操作*](#OpTable3) 中。

> *正确性和可验证性*：

 参见 [*一元数值操作*](#OpTable3)。

>---
### nop ：无操作

| Format | Assembly Format | Description |
| :----- | :-------------- | :---------- |
| 00     | `nop`           | 无操作。    |

> *堆栈转换*：

&hellip;, &rarr; &hellip;,

> *描述*：

`nop` 指令无操作。如果字节码被修补，它用于填充空间。

> *可验证性*：
 
`nop` 指令始终可验证。

>---
### not ：按位取反

| Format | Assembly Format | Description |
| :----- | :-------------- | :---------- |
| 66     | `not`           | 按位取反。  |

> *堆栈转换*：

&hellip;, _value_ &rarr; &hellip;, _result_

> *描述*：

`not` 指令计算堆栈顶部的整数值的按位取反，并将结果留在堆栈顶部。返回类型与操作数类型相同。

可接受的操作数类型及其相应的结果数据类型包含在 [*整数操作*](#OpTable5) 中。

> *正确性和可验证性*：

参见 [*整数操作*](#OpTable5)。

>---
### or ：按位或

| Format | Assembly Format | Description                        |
| :----- | :-------------- | :--------------------------------- |
| 60     | `or`            | 两个整数值的按位或，返回一个整数。 |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;, _result_

> *描述*：

`or` 指令计算堆栈顶部两个值的按位或，并将结果留在堆栈上。

可接受的操作数类型及其相应的结果数据类型包含在 [*整数操作*](#OpTable5) 中。

> *正确性和可验证性*：

参见 [*整数操作*](#OpTable5)。

>---
### pop ：移除堆栈的顶部元素

| Format | Assembly Format | Description    |
| :----- | :-------------- | :------------- |
| 26     | `pop`           | 从堆栈弹出值。 |

> *堆栈转换*：

&hellip;, _value_ &rarr; &hellip;

> *描述*：

`pop` 指令从堆栈移除顶部元素。

>---
### rem ：计算余数

| Format | Assembly Format | Description                |
| :----- | :-------------- | :------------------------- |
| 5D     | `rem`           | 一个值以另一个值后的余数。 |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;, _result_

> *描述*：

`rem` 指令将 _value1_ 除以 _value2_ 并将余数 _result_ 推送到堆栈。

可接受的操作数类型及其相应的结果数据类型包含在 [*二元数值操作*](#OpTable2) 中。

对于整数操作数，_result_ = _value1_ `rem` _value2_ 满足以下条件：
  * _result_ = _value1_ - _value2_ &times; (_value1_ `div` _value2_), 和
  * 0 &le; \|_result_\| < \|_value2_\|, 和
  * sign(_result_) = sign(_value1_),

其中 `div` 是向零截断的除法指令。

对于浮点操作数，`rem` 的定义与整数操作数类似，除了，如果 _value2_ 为零或 _value1_ 为无穷大，结果为 **NaN**。如果 _value2_ 为无穷大，_result_ 为 _value1_。此定义与 IEC 60559:1989 标准中的浮点余数的定义不同。该标准规定 _value1_ `div` _value2_ 是最接近的整数，而不是向零截断。`System.Math.IEEERemainder` 提供了 IEC 60559:1989 的行为。

> *异常*：

如果 _value2_ 为零，整数运算抛出 `System.DivideByZeroException` 异常。

如果 _value1_ 是可表示的最小整数值且 _value2_ 是 -1，整数运算可以抛出 `System.ArithmeticException` 异常。

> *示例*：

```cil
  +10 rem +6 = 4  | +10 div +6 = 1  
  +10 rem -6 = 4  | +10 div -6 = -1
  -10 rem +6 = -4 | -10 div +6 = -1
  -10 rem -6 = -4 | -10 div -6 = 1
```

对于 10.0 和 6.0 的各种浮点值，`rem` 给出相同的值；然而，`System.Math.IEEERemainder` 给出以下值。

```cil
  System.Math.IEEERemainder (+10.0, +6.0) = -2 | +10.0 div +6.0 =  1.666...7
  System.Math.IEEERemainder (+10.0, -6.0) = -2 | +10.0 div -6.0 = -1.666...7
  System.Math.IEEERemainder (-10.0, +6.0) =  2 | -10.0 div +6.0 = -1.666...7
  System.Math.IEEERemainder (-10.0, -6.0) =  2 | -10.0 div -6.0 = 1.666...7  
```

> *正确性和可验证性*：

参见 [*二元数值操作*](#OpTable2)。

>---
### rem.un ：计算整数余数，无符号

| Format | Assembly Format | Description                        |
| :----- | :-------------- | :--------------------------------- |
| 5E     | `rem.un`        | 一个无符号值除以另一个值后的余数。 |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;, _result_

> *描述*：

`rem.un` 指令将 _value1_ 除以 _value2_ 并将余数 _result_ 推送到堆栈。`rem.un` 将其参数视为无符号整数，而 `rem` 将它们视为有符号整数。

_result_ = _value1_ `rem.un` _value2_ 满足以下条件：
 * _result_ = _value1_ &ndash; _value2_ &times; (_value1_ `div.un` _value2_), 和
 * 0 &le; _result_ < _value2_,

其中 `div.un` 是无符号除法指令。`rem.un` 对浮点数未指定。可接受的操作数类型及其相应的结果数据类型包含在 [*整数操作*](#OpTable5) 中。

> *异常*：

如果 _value2_ 为零，整数运算抛出 `System.DivideByZeroException` 异常。

> *示例*：

```cil
  +5 rem.un +3 = 2                | +5 div.un +3 = 1                         
  +5 rem.un -3 = 5                | +5 div.un -3 = 0                       
  -5 rem.un +3 = 2                | -5 div.un +3 = 1431655763 或 0x55555553 
  -5 rem.un -3 = -5 或 0xfffffffb | -5 div.un -3 = 0                      
```

> *正确性和可验证性*：

参见 [*整数操作*](#OpTable5)。

>---
### ret ：从方法返回

| Format | Assembly Format | Description              |
| :----- | :-------------- | :----------------------- |
| 2A     | `ret`           | 可能带有值的从方法返回。 |

> *堆栈转换*：

在被调用方求值堆栈上的 _retVal_（可能不存在） &rarr; &hellip;，在调用方求值堆栈上的 _retVal_（可能不存在）

> *描述*：

从当前方法返回。当前方法的返回类型（如果有）决定了要从堆栈顶部获取的值的类型，并将其复制到调用当前方法的方法的堆栈上。当前方法的评求值堆栈应为空，除了要返回的值。

`ret` 指令不能用于从 **try**，**filter**，**catch** 或 **finally** 块中转移控制。从 **try** 或 **catch** 内部，使用 `leave` 指令，目标是在所有包围的异常块之外的 `ret` 指令。因为 **filter** 和 **finally** 块在逻辑上是异常处理的一部分，而不是嵌入其代码的方法，因此正确生成的 CIL 不会从 **filter** 或 **finally** 中执行方法返回。

> *正确性*：

正确的 CIL 遵守上述控制约束。

> *可验证性*：

验证要求 _retVal_ 的类型是 *验证可赋值给* 当前方法的声明返回类型。由于操作是堆栈到堆栈，所以不会发生表示更改。

>---
### shl ；左移整数

| Format | Assembly Format | Description                          |
| :----- | :-------------- | :----------------------------------- |
| 62     | `shl`           | 将整数左移（移入零），返回一个整数。 |

> *堆栈转换*：

&hellip;, _value_, _shiftAmount_ &rarr; &hellip;, _result_

> *描述*：

`shl` 指令将 _value_（`int32`，`int64` 或 `native int`）按照 _shiftAmount_ 指定的位数左移。_shiftAmount_ 的类型为 `int32` 或 `native int`。如果 _shiftAmount_ 大于或等于 _value_ 的宽度，返回值未指定。参见 [*移位操作*](#OpTable6) 以获取允许哪些操作数类型及其相应的结果类型的详细信息。

> *正确性和可验证性*：

参见 [*整数操作*](#OpTable5)。

>---
### shr ：右移整数

| Format | Assembly Format | Description                            |
| :----- | :-------------- | :------------------------------------- |
| 63     | `shr`           | 将整数右移（移入符号），返回一个整数。 |

> *堆栈转换*：

&hellip;, _value_, _shiftAmount_ &rarr; &hellip;, _result_

> *描述*：

`shr` 指令将 _value_（`int32`，`int64` 或 `native int`）按照 _shiftAmount_ 指定的位数右移。_shiftAmount_ 的类型为 `int32` 或 `native int`。如果 _shiftAmount_ 大于或等于 _value_ 的宽度，返回值未指定。`shr` 在每次移位时复制高位，保留原始值的符号在结果中。参见 [*移位操作*](#OpTable6) 以获取允许哪些操作数类型及其相应的结果类型的详细信息。

> *正确性和可验证性*：

参见 [*整数操作*](#OpTable5)。

>---
### shr.un ：无符号右移整数

| Format | Assembly Format | Description                          |
| :----- | :-------------- | :----------------------------------- |
| 64     | `shr.un`        | 将整数右移（移入零），返回一个整数。 |

> *堆栈转换*：

&hellip;, _value_, _shiftAmount_ &rarr; &hellip;, _result_

> *描述*：

`shr.un` 指令将 _value_（`int32`，`int64` 或 `native int`）按照 _shiftAmount_ 指定的位数右移。_shiftAmount_ 的类型为 `int32` 或 `native int`。如果 _shiftAmount_ 大于或等于 _value_ 的宽度，返回值未指定。`shr.un` 在每次移位时插入一个零位。参见 [*移位操作*](#OpTable6) 以获取允许哪些操作数类型及其相应的结果类型的详细信息。

> *正确性和可验证性*：

参见 [*整数操作*](#OpTable5)。

>---
### starg.\<length\> ：在参数槽中存储值

| Format                     | Assembly Format | Description                               |
| :------------------------- | :-------------- | :---------------------------------------- |
| FE 0B _\<unsigned int16\>_ | `starg` _num_   | 将值存储到编号为 _num_ 的参数中。         |
| 10 _\<unsigned int8\>_     | `starg.s` _num_ | 将值存储到编号为 _num_ 的参数中，短格式。 |

> *堆栈转换*：

&hellip;, _value_ &rarr; &hellip;,

> *描述*：

`starg` _num_ 指令从堆栈中弹出一个值，并将其放入参数槽 _num_ 中。值的类型应与参数的类型匹配，如当前方法的签名所指定。`starg.s` 指令为前 256 个参数提供了一种高效的编码。

对于采用可变参数列表的过程，`starg` 指令只能用于初始固定参数，而不能用于签名的可变部分。存储到持有小于 4 字节值且其中间类型为 `int32` 的参数中时，值在从堆栈移动到参数时会被截断。浮点值从其本地大小（类型 `F`）四舍五入到与参数关联的大小。

> *正确性*：

正确的 CIL 要求 _num_ 是一个有效的参数槽。除了验证的 CIL 允许的存储外，正确的 CIL 还允许将 `native int` 存储为 **byref** (`&`)；在这种情况下，存储后的值将由垃圾收集进行跟踪。

> *可验证性*：

验证检查值的类型是否为 *验证可赋值给*参数的类型，如当前方法的签名所指定。

>---
### stind.\<type\> ：间接从堆栈存储值

| Format | Assembly Format | Description                                                 |
| :----- | :-------------- | :---------------------------------------------------------- |
| 52     | `stind.i1`      | 将类型为 `int8` 的值存储到 _address_ 处的内存中             |
| 53     | `stind.i2`      | 将类型为 `int16` 的值存储到 _address_ 处的内存中            |
| 54     | `stind.i4`      | 将类型为 `int32` 的值存储到 _address_ 处的内存中            |
| 55     | `stind.i8`      | 将类型为 `int64` 的值存储到 _address_ 处的内存中            |
| 56     | `stind.r4`      | 将类型为 `float32` 的值存储到 _address_ 处的内存中          |
| 57     | `stind.r8`      | 将类型为 `float64` 的值存储到 _address_ 处的内存中          |
| DF     | `stind.i`       | 将类型为 `native int` 的值存储到 _address_ 处的内存中       |
| 51     | `stind.ref`     | 将类型为对象引用（类型 `O`）的值存储到 _address_ 处的内存中 |

> *堆栈转换*：

&hellip;, _addr_, _val_ &rarr; &hellip;

> *描述*：

`stind` 指令将值 _val_ 存储在地址 _addr_ 处（一个非托管指针，类型为 `native int`，或托管指针，类型为 `&`）。由 _addr_ 指定的地址应与 _val_ 的自然大小对齐，否则可能会发生 `NullReferenceException` 异常（但请参见 `unaligned.` 前缀指令）。所有返回地址的 CIL 指令（例如，`ldloca` 和 `ldarga`）的结果都是安全对齐的。对于大于 1 字节的数据类型，字节顺序取决于目标 CPU。依赖于字节顺序的代码可能无法在所有平台上运行。

存储到小于 4 字节的位置会在值从堆栈移动到内存时截断值。浮点值从其本地大小（类型 `F`）四舍五入到与指令关联的大小。

`stind.ref` 指令是一个 `stobj` 指令的快捷方式，该指令指定了由 _addr_ 指向的类型，所有其他的 `stind` 指令都是 `stobj` 指令的快捷方式，该指令指定了相应的内置值类。

类型安全的操作要求 `stind` 指令的使用方式与指针的类型一致。`stind` 指令的操作可以通过紧接在前的 `volatile.` 或 `unaligned.` 前缀指令进行更改。

> *异常*：

如果 _addr_ 对于指令后缀暗示的参数类型没有自然对齐，将抛出 `System.NullReferenceException` 异常。

> *正确性*：

正确的 CIL 确保 _addr_ 是指向 `T` 的指针，且 _val_ 的类型是 *验证可赋值给* `T`。对于 `stind.ref`，由 _addr_ 指向的类型不能是泛型参数。`stobj` 指令可以与泛型参数类型一起使用。

> *可验证性*：

对于可验证的代码，_addr_ 应为托管指针，`T&`，且 _val_ 的类型应为 *验证可赋值给* `T`。

>---
### stloc ：从堆栈弹出值到局部变量

| Format                     | Assembly Format  | Description                               |
| :------------------------- | :--------------- | :---------------------------------------- |
| FE 0E _\<unsigned int16\>_ | `stloc` _indx_   | 将值从堆栈弹出到局部变量 _indx_。         |
| 13 _\<unsigned int8\>_     | `stloc.s` _indx_ | 将值从堆栈弹出到局部变量 _indx_，短格式。 |
| 0A                         | `stloc.0`        | 将值从堆栈弹出到局部变量 0。              |
| 0B                         | `stloc.1`        | 将值从堆栈弹出到局部变量 1。              |
| 0C                         | `stloc.2`        | 将值从堆栈弹出到局部变量 2。              |
| 0D                         | `stloc.3`        | 将值从堆栈弹出到局部变量 3。              |

> *堆栈转换*：

&hellip;, _value_ &rarr; &hellip;

> *描述*：

`stloc` _indx_ 指令将评估堆栈顶部的值弹出，并将其移动到局部变量编号 _indx_，其中局部变量从 0 开始编号。值的类型应与当前方法的局部签名中指定的局部变量的类型匹配。`stloc.0`，`stloc.1`，`stloc.2` 和 `stloc.3` 指令为前 4 个局部变量提供了一种高效的编码；`stloc.s` 指令为局部变量 4 ~ 255 提供了一种高效的编码。

存储到小于 4 字节的局部变量中会在值从堆栈移动到局部变量时截断值。浮点值从其本机大小（类型 `F`）四舍五入到与参数关联的大小。

> *正确性*：

正确的 CIL 要求 _indx_ 是一个有效的局部索引。对于 `stloc` _indx_ 指令，_indx_ 应在 0 ~ 65534（包含）的范围内（具体来说，65535 是无效的）。

排除 65535 的原因是实用的：可能的实现将使用一个 2 字节的整数来跟踪局部的索引以及给定方法的局部总数。如果一个索引为 65535 的值被认为是有效的，那么将需要一个更宽的整数来跟踪这样一个方法的局部数量。

> *可验证性*：

验证还检查值的类型是否为 *验证可赋值给* 局部的类型，如当前方法的局部签名所指定。

>---
### sub ：减去数值

| Format | Assembly Format | Description                                 |
| :----- | :-------------- | :------------------------------------------ |
| 59     | `sub`           | 从 _value1_ 中减去 _value2_，返回一个新值。 |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;, _result_

> *描述*：

`sub` 指令从 _value1_ 中减去 _value2_ 并将结果推入堆栈。对于整数操作，不会检测溢出（参见 `sub.ovf`）；对于浮点操作数，`sub` 在正溢出时返回 `+inf`，在负溢出时返回 `-inf`，在浮点下溢时返回零。

可以接受的操作数类型及其相应的结果数据类型在 [*二元数值操作*](#OpTable2) 中封装。

> *正确性和可验证性*：

参见 [*二元数值操作*](#OpTable2)。

>---
### sub.ovf.\<type\> ：检查溢出的减法

| Format | Assembly Format | Description                                                                               |
| :----- | :-------------- | :---------------------------------------------------------------------------------------- |
| DA     | `sub.ovf`       | 从一个 native int 中减去另一个 native int。有符号结果应适合相同的大小。                   |
| DB     | `sub.ovf.un`    | 从一个 native unsigned int 中减去另一个 native unsigned int。无符号结果应适合相同的大小。 |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;, _result_

> *描述*：

`sub.ovf` 指令从 _value1_ 中减去 _value2_ 并将结果推入堆栈。值的类型和返回类型由指令指定。如果结果不适合结果类型，将抛出异常。

可以接受的操作数类型及其相应的结果数据类型在 [*溢出算术操作*](#OpTable7) 中封装。

> *异常*：

如果结果不能用结果类型表示，将抛出 `System.OverflowException` 异常。

> *正确性和可验证性*：

参见 [*溢出算术操作*](#OpTable7)。

>---
### switch ：基于值的表切换

| Format                                                   | Assembly Format                       | Description               |
| :------------------------------------------------------- | :------------------------------------ | :------------------------ |
| 45 _\<unsigned int32\>_ _\<int32\>_ &hellip; _\<int32\>_ | `switch` ( _t1_, _t2_ &hellip; _tN_ ) | 跳转到 _n_ 个值中的一个。 |

> *堆栈转换*：

&hellip;, _value_ &rarr; &hellip;,

> *描述*：

`switch` 指令实现了一个跳转表。指令的格式是一个 `unsigned int32`，表示目标的数量 _N_，后面跟着 _N_ 个 `int32` 值，指定跳转目标：这些目标表示为从此 `switch` 指令后的指令开始的偏移（正或负）。

`switch` 指令将值从堆栈弹出，并将其作为无符号整数与 _n_ 进行比较。如果值小于 _n_，则执行转移到 _value_'th 目标，其中目标从 0 开始编号（即，值为 0 时取第一个目标，值为 1 时取第二个目标，依此类推）。如果 _value_ 不小于 _n_，则执行在下一条指令处继续（落空）。

如果目标指令有一个或多个前缀代码，控制只能转移到这些前缀中的第一个。此指令不能执行进入和退出 **try**，**catch**，**filter** 和 **finally** 块的控制转移。这种转移受到严格限制，应使用 `leave` 指令代替。

> *异常*：

> *正确性*：

正确的 CIL 遵守上述控制转移约束。

> *可验证性*：

验证要求堆栈、局部变量和参数的类型一致性，以便通过所有可能的方式到达所有目标指令。

>---
### xor ：按位异或

| Format | Assembly Format | Description                      |
| :----- | :-------------- | :------------------------------- |
| 61     | `xor`           | 整数值的按位异或，返回一个整数。 |

> *堆栈转换*：

&hellip;, _value1_, _value2_ &rarr; &hellip;, _result_

> *描述*：

`xor` 指令计算 _value1_ 和 _value2_ 的按位异或，并将结果留在堆栈上。可以接受的操作数类型及其相应的结果数据类型在 [*整数操作*](#OpTable5) 中封装。

> *正确性和可验证性*：

参见 [*整数操作*](#OpTable5)。

---
## 对象模型指令

基础指令集中描述的指令与正在执行的对象模型无关。这些指令与真实 CPU 上的指令非常相似。对象模型指令比基础指令更不内置，因为它们可以由基础指令和对底层操作系统的调用构建。

对象模型指令提供了一种常见的、高效的实现方式，用于许多（但绝不是所有）高级语言使用的一组服务。它们在操作中嵌入了由 CTS 定义的一组约定。这包括（但不限于）：
 * 对象内的字段布局
 * 后期绑定方法调用的布局（虚表）
 * 内存分配和回收
 * 异常处理
 * Boxing 和 Unboxing 以在引用类型对象和值类型之间转换。

>---
### box ：将可装箱值转换为其装箱形式

| Format     | Assembly Format | Description                |
| :--------- | :-------------- | :------------------------- |
| 8C _\<T\>_ | `box` _typeTok_ | 将可装箱值转换为其装箱形式 |

> *堆栈转换*：

&hellip;, _val_ &rarr; &hellip;, _obj_

> *描述*：

如果 _typeTok_ 是值类型，`box` 指令将 val 转换为其装箱形式。当 _typeTok_ 是非空类型，这是通过创建一个新对象并将 _val_ 中的数据复制到新分配的对象中完成的。如果它是可空类型，这是通过检查 _val_ 的 `HasValue` 属性完成的；如果它是 `false`，则将空引用推入堆栈；否则，将装箱 _val_ 的 `Value` 属性的结果推入堆栈。

如果 _typeTok_ 是引用类型，`box` 指令将 _val_ 不变地返回为 _obj_。

如果 _typeTok_ 是泛型参数，`box` 指令的行为取决于运行时的实际类型。如果这种类型是值类型，那么它将像上面那样被装箱，如果它是引用类型，那么 _val_ 不会改变。然而，对于泛型参数，无论运行时的实际类型是值类型还是引用类型，验证跟踪的类型总是 "*boxed*" _typeTok_。

_typeTok_ 是一个元数据 *token*（*TypeDef*，*TypeRef* 或 *TypeSpec*），表示 _val_ 的类型。_typeTok_ 可以表示值类型、引用类型或泛型参数。

> *异常*：

如果没有足够的内存来满足请求，将抛出 `System.OutOfMemoryException` 异常。如果找不到 _typeTok_，将抛出 `System.TypeLoadException` 异常。这通常在编译 CIL-to-native-code 时而不是在运行时检测到。

> *正确性*：

_typeTok_ 应该是一个有效的 `typedef`，`typeref` 或 `typespec` 元数据标记。类型操作数 _typeTok_ 应表示一个可装箱类型。

> *可验证性*：

堆栈顶部应该是 *验证可赋值给* _typeTok_ 表示的类型。当 _typeTok_ 表示非空值类型或泛型参数时，结果类型是 "*boxed*" _typeTok_；当 _typeTok_ 是 `Nullable<T>` 时，结果类型是 "boxed" `T`。当 _typeTok_ 是引用类型时，结果类型是 _typeTok_。类型操作数 _typeTok_ 不应该是 byref-like 类型。

>---
### callvirt ：调用与对象在运行时关联的方法

| Format     | Assembly Format     | Description            |
| :--------- | :------------------ | :--------------------- |
| 6F _\<T\>_ | `callvirt` _method_ | 调用与对象关联的方法。 |

> *堆栈转换*：

&hellip;, _obj_, _arg1_, &hellip; _argN_ &rarr; &hellip;, _returnVal_ (不总是返回)

> *描述*：

`callvirt` 指令在对象上调用一个后期绑定的方法。也就是说，选择的方法基于 _obj_ 的确切类型，而不是 _method_ 元数据标记中可见的编译时类。`callvirt` 可以用来调用虚拟方法和实例方法。`callvirt` 指令可以紧接在 `tail.` 前缀后面来指定在转移控制之前应释放当前的堆栈帧。如果调用将控制权转移到比原始方法更高信任的方法，堆栈帧将不会被释放。定义为 "更高信任" 的被调用方是其权限授予集是调用方的授予集的严格超集的那个

_method_ 是一个元数据 *token*（*MethodDef*，*MethodRef* 或 *MethodSpec*），提供了要调用的方法的名称、类和签名。更详细地说，`callvirt` 可以被认为如下。与 _obj_ 关联的是它是其实例的类。CLI 根据 [[↗]](./01_CLI%20基本概念和体系结构.md/#computed-destinations)（计算目标）中指定的规则解析要调用的方法。

`callvirt` 在调用方法之前将对象和参数从评估堆栈中弹出。如果方法有返回值，它将在方法完成时被推入堆栈。在被调用方，_obj_ 参数作为参数 0 访问，_arg1_ 作为参数 1，依此类推。

参数按从左到右的顺序放置在堆栈上。也就是说，首先计算第一个参数并将其放置在堆栈上，然后是第二个参数，等等。**this** 指针（对于 `callvirt` 总是需要的）应首先被推入。元数据中携带的签名不包含参数列表中的 **this** 指针的条目，但调用约定总是指示是否需要一个，以及它的签名是显式的还是推断的。对于对值类型的方法的调用，**this** 指针可能是一个托管指针，而不是实例引用（§[I.8.6.1.5]()）。

参数传递就像通过隐式 `starg` 指令传递。也可以使用 `call` 指令调用虚拟方法。

> *异常*：

当试图无效地访问非公共方法时，可以抛出 `System.MethodAccessException` 异常。

如果在 _obj_ 的类或任何其基类中找不到指定名称和签名的非静态方法，将抛出 `System.MissingMethodException` 异常。这通常在 CIL-to-native-code 时而不是在运行时检测到。

如果 _obj_ 为 `null`，将抛出 `System.NullReferenceException` 异常。

如果系统安全性不授予调用方访问被调用方法的权限，将抛出 `System.SecurityException` 异常。安全检查可以在编译 CIL-to-native-code 时而不是在运行时发生。

> *正确性*：

正确的 CIL 确保目标方法存在，并且堆栈上的值与被调用方法的参数的类型相对应。除了验证的 CIL 允许的参数类型外，正确的 CIL 还允许将 `native int` 作为 **byref** (`&`) 传递；在这种情况下，存储后的值将由垃圾收集进行跟踪。

> *可验证性*： 

在其典型用法中，如果满足以下条件，`callvirt` 是可验证的：
 1. 满足上述限制；
 2. _obj_ 的验证类型是 *验证可赋值给* 方法签名的 **this** 签名；
 3. 堆栈上的参数的类型是 *验证可赋值给* 方法签名的参数签名；并且
 4. 方法可以从调用点访问。

如果存在 _returnVal_，则其类型被跟踪为被调用方法的签名返回类型的中间类型。

由 `tail.` 注释的 `callvirt` 有额外的考虑因素。参见 §[[↗]](#Verifiability)。

>---
### castclass ：将对象转换为类

| Format     | Assembly Format       | Description                 |
| :--------- | :-------------------- | :-------------------------- |
| 74 _\<T\>_ | `castclass` _typeTok_ | 将 _obj_ 转换为 _typeTok_。 |

> *堆栈转换*：

&hellip;, _obj_ &rarr; &hellip;, _obj2_

> *描述*：

_typeTok_ 是一个元数据 *token*（*TypeRef*，*TypeDef* 或 *TypeSpec*），表示所需的类。如果 _typeTok_ 是非空值类型或泛型参数类型，它被解释为 "boxed" _typeTok_。如果 _typeTok_ 是可空类型 `Nullable<T>`，它被解释为 "boxed" `T`。

`castclass` 指令确定 _obj_（类型为 `O`）是否是类型 _typeTok_ 的实例，称为 "casting"。如果 _obj_ 的实际类型（而不是验证器跟踪的类型）是 *验证可赋值给* 类型 _typeTok_，则转换成功，并且 _obj_（作为 _obj2_）在验证其类型为 _typeTok_ 时返回不变。

与隐式强制转换（§[[↗]](#OpTable9)）和 `conv` 转换（§[[↗]](#conv-to-type)）不同，`castclass` 转换永远不会改变对象的实际类型并保留对象标识。

如果转换失败，则抛出 `InvalidCastException` 异常。如果 _obj_ 为 null，`castclass` 成功并返回 null。这种行为在语义上与 `isinst` 不同，其中如果 _obj_ 为 `null`，`isinst` 失败并返回 `null`。

> *异常*：

如果 _obj_ 无法转换为 _typeTok_，将抛出 `System.InvalidCastException` 异常。

如果找不到 _typeTok_，将抛出 `System.TypeLoadException` 异常。这通常在 CIL-to-native-code 时而不是在运行时检测到。

> *正确性*：

正确的 CIL 确保 _typeTok_ 是一个有效的 *TypeRef*，*TypeDef* 或 *TypeSpec* *token*，并且 _obj_ 总是 `null` 或对象引用。

> *可验证性*：

验证将 _obj2_ 的类型跟踪为 _typeTok_。

>---
### cpobj ：将一个地址的值复制到另一个地址

| Format     | Assembly Format   | Description                      |
| :--------- | :---------------- | :------------------------------- |
| 70 _\<T\>_ | `cpobj` _typeTok_ | 将值类型从 _src_ 复制到 _dest_。 |

> *堆栈转换*：

&hellip;, _dest_, _src_ &rarr; &hellip;,

> *描述*：

`cpobj` 指令将由 _src_（一个非托管指针，`native int`，或一个托管指针，`&`）指定的地址处的值复制到由 _dest_（也是一个指针）指定的地址处。_typeTok_ 可以是 *TypeDef*，*TypeRef* 或 *TypeSpec*。如果 _src_ 引用的位置的类型不是 *可赋值给* _dest_ 引用的位置的类型，行为是未指定的。如果 _typeTok_ 是引用类型，`cpobj` 指令具有与 `ldind.ref` 后跟 `stind.ref` 相同的效果。

> *异常*：

如果检测到无效地址，可能会抛出 `System.NullReferenceException` 异常。

如果找不到 _typeTok_，将抛出 `System.TypeLoadException` 异常。这通常在 CIL 转换为本机代码时而不是在运行时检测到。

> *正确性*：

_typeTok_ 应该是一个有效的 `typedef`，`typeref` 或 `typespec` 元数据标记。

> *可验证性*：

目标（_dest_）和源（_src_）值的跟踪类型都应该是到我们分别表示为 _destType_ 和 _srcType_ 的值的托管指针（`&`）。最后，_srcType_ 应该是 *可赋值给* _typeTok_，并且 _typeTok_ 应该是 *可赋值给* _destType_。在枚举的情况下，其类型是枚举的基础类型或基类型。

>--=
### initobj ：初始化地址处的值

| Format        | Assembly Format     | Description                |
| :------------ | :------------------ | :------------------------- |
| FE 15 _\<T\>_ | `initobj` _typeTok_ | 初始化地址 _dest_ 处的值。 |

> *堆栈转换*：

&hellip;, _dest_ &rarr; &hellip;,

> *描述*：

`initobj` 指令使用默认值初始化一个地址。_typeTok_ 是一个元数据 *token*（*TypeDef*，*TypeRef* 或 *TypeSpec*）。_dest_ 是一个非托管指针（`native int`），或一个托管指针（`&`）。如果 _typeTok_ 是值类型，`initobj` 指令将 _dest_ 的每个字段初始化为 `null` 或适当的内置类型的零。如果 _typeTok_ 是值类型，那么在此指令执行后，实例已准备好调用构造函数方法。如果 _typeTok_ 是引用类型，`initobj` 指令具有与 `ldnull` 后跟 `stind.ref` 相同的效果。

与 `newobj` 不同，`initobj` 指令不调用任何构造函数方法。

> *正确性*：

_typeTok_ 应该是一个有效的 *TypeDef*，*TypeRef* 或 *TypeSpec* 元数据 *token*。

> *可验证性*：

堆栈顶部的目标值的类型应该是到某种类型 _destType_ 的托管指针，且 _typeTok_ 应该是 *assignable-to* _destType_。如果 _typeTok_ 是非引用类型，子类型的定义意味着 _destType_ 和 _typeTok_ 应该相等。

>---
### isinst ：测试一个对象是否是类或接口的实例

| Format     | Assembly Format    | Description                                                        |
| :--------- | :----------------- | :----------------------------------------------------------------- |
| 75 _\<T\>_ | `isinst` _typeTok_ | 测试 _obj_ 是否是 _typeTok_ 的实例，返回 null 或该类或接口的实例。 |

> *堆栈转换*：

&hellip;, _obj_ &rarr; &hellip;, _result_

> *描述*：

_typeTok_ 是一个元数据 *token*（*TypeDef*，*TypeRef* 或 *TypeSpec*），表示所需的类。如果 _typeTok_ 是非空值类型或泛型参数类型，它被解释为 "boxed" _typeTok_。如果 _typeTok_ 是可空类型，`Nullable<T>`，它被解释为 "boxed" `T`。

`isinst` 指令测试 _obj_（类型为 `O`）是否是类型 _typeTok_ 的实例。如果 _obj_ 的实际类型（而不是验证器跟踪的类型）是 *验证可赋值给* 类型 _typeTok_，则 `isinst` 成功，并且 _obj_（作为 _result_）在验证其类型为 _typeTok_ 时返回不变。与隐式强制转换和 `conv` 转换不同，`isinst` 永远不会改变对象的实际类型并保留对象标识。

如果 _obj_ 是 null，或者 _obj_ 不是 *验证可赋值给* 类型 _typeTok_，`isinst` 失败并返回 null。

> *异常*：

如果找不到 _typeTok_，将抛出 `System.TypeLoadException` 异常。这通常在 CIL-to-native-code 时而不是在运行时检测到。

> *正确性*：

正确的 CIL 确保 _typeTok_ 是一个有效的 *TypeDef*，*TypeRef* 或 *TypeSpec* *token*，并且 _obj_ 总是 null 或对象引用。

> *可验证性*：

验证将 _result_ 的类型跟踪为 _typeTok_。

>---
### ldelem ：从数组中加载元素

| Format     | Assembly Format    | Description                    |
| :--------- | :----------------- | :----------------------------- |
| A3 _\<T\>_ | `ldelem` _typeTok_ | 将索引处的元素加载到堆栈顶部。 |

> *堆栈转换*：

&hellip;, _array_, _index_ &rarr; &hellip;, _value_

> *描述*：

`ldelem` 指令加载零基一维数组 _array_ 中索引 _index_（类型为 `native int` 或 `int32`）处的元素的值，并将其放置在堆栈顶部。返回值的类型由指令中的类型标记 _typeTok_ 指示。如果需要，当元素加载到堆栈上时，元素会转换为其 *中间类型* 的表示形式。

即小于 4 字节的元素、布尔值或字符通过适当的符号或零扩展转换为 4 字节。浮点值转换为其本地大小（类型 `F`）。

> *异常*：

如果 _index_ 大于数组的边界，将抛出 `System.IndexOutOfRangeException` 异常。

如果 _array_ 为 null，将抛出 `System.NullReferenceException` 异常。

> *正确性*：

_typeTok_ 应该是一个有效的 *TypeDef*，*TypeRef* 或 *TypeSpec* *token*

_array_ 应该是 `null` 或一个单维、零基数组。

> *可验证性*：

验证要求：
 * _array_ 的跟踪类型是 `T[]`，对于某个 `T`；
 * `T` 是 *数组元素可赋值给* _typeTok_；并且
 * _index_ 的类型是 `int32` 或 `native int`。

验证将结果 _value_ 的类型跟踪为 _typeTok_。

>---
### ldelem.\<type\> ：从数组中加载元素

| Format | Assembly Format | Description                                                                                       |
| :----- | :-------------- | :------------------------------------------------------------------------------------------------ |
| 90     | `ldelem.i1`     | 将类型为 `int8` 的元素在 _index_ 处加载到堆栈顶部，作为 `int32`。                                 |
| 92     | `ldelem.i2`     | 将类型为 `int16` 的元素在 _index_ 处加载到堆栈顶部，作为 `int32`。                                |
| 94     | `ldelem.i4`     | 将类型为 `int32` 的元素在 _index_ 处加载到堆栈顶部，作为 `int32`。                                |
| 96     | `ldelem.i8`     | 将类型为 `int64` 的元素在 _index_ 处加载到堆栈顶部，作为 `int64`。                                |
| 91     | `ldelem.u1`     | 将类型为 `unsigned int8` 的元素在 _index_ 处加载到堆栈顶部，作为 `int32`。                        |
| 93     | `ldelem.u2`     | 将类型为 `unsigned int16` 的元素在 _index_ 处加载到堆栈顶部，作为 `int32`。                       |
| 95     | `ldelem.u4`     | 将类型为 `unsigned int32` 的元素在 _index_ 处加载到堆栈顶部，作为 `int32`。                       |
| 96     | `ldelem.u8`     | 将类型为 `unsigned int64` 的元素在 _index_ 处加载到堆栈顶部，作为 `int64`（`ldelem.i8` 的别名）。 |
| 98     | `ldelem.r4`     | 将类型为 `float32` 的元素在 _index_ 处加载到堆栈顶部，作为 `F`。                                  |
| 99     | `ldelem.r8`     | 将类型为 `float64` 的元素在 _index_ 处加载到堆栈顶部，作为 `F`。                                  |
| 97     | `ldelem.i`      | 将类型为 `native int` 的元素在 _index_ 处加载到堆栈顶部，作为 `native int`。                      |
| 9A     | `ldelem.ref`    | 将 _index_ 处的元素加载到堆栈顶部，作为 `O`。`O` 的类型与推入 CIL 堆栈的数组的元素类型相同。      |

> *堆栈转换*：

&hellip;, _array_, _index_ &rarr; &hellip;, _value_

> *描述*：

`ldelem.<type>` 指令加载零基一维数组 _array_ 中索引 _index_（类型为 `int32` 或 `native int`）处的元素的值，并将其放置在堆栈顶部。对于 `ldelem.ref`，返回 _value_ 的类型是 _array_ 的元素类型，对于其他指令变体，它是指令中指示的 _\<type\>_。

所有变体都等同于带有适当 _typeTok_ 的 `ldelem` 指令。

对于不是零基的一维数组和多维数组，数组类提供了一个 `Get` 方法。

如果需要，当元素加载到堆栈上时，元素会转换为其中间类型的表示形式。即小于 4 字节的元素、布尔值或字符通过适当的符号或零扩展转换为 4 字节。浮点值转换为其本机大小（类型 `F`）。

> *异常*：

如果 _array_ 为 null，将抛出 `System.NullReferenceException` 异常。

如果 _index_ 为负数，或大于 _array_ 的边界，将抛出 `System.IndexOutOfRangeException` 异常。

> *正确性*：

正确的 CIL 代码要求 _array_ 是 null 或一个零基、一维数组，其声明的元素类型是 *数组元素可赋值给* 此特定指令后缀的类型。

> *可验证性*：

验证要求：

 * _array_ 的跟踪类型是 `T[]`，对于某个 `T`；
 * 对于 `ldelem.ref`，`T` 是引用类型，对于其他指令变体，`T` 是 *数组元素可赋值给* 指令中的类型；并且
 * _index_ 的类型是 `int32` 或 `native int`。

验证将结果 _value_ 的类型跟踪为 `ldelem.ref` 的 `T`，或者其他变体中的指令的 _\<type\>_。

>---
### ldelema ：加载数组元素的地址

| Format     | Assembly Format     | Description                          |
| :--------- | :------------------ | :----------------------------------- |
| 8F _\<T\>_ | `ldelema` _typeTok_ | 将索引处的元素的地址加载到堆栈顶部。 |

> *堆栈转换*：

&hellip;, _array_, _index_ &rarr; &hellip;, _address_

> *描述*：

`ldelema` 指令加载零基一维数组 _array_（元素类型为 *验证可赋值给 * _typeTok_）中索引 _index_（类型为 `int32` 或 `native int`）处的元素的地址，并将其放置在堆栈顶部。数组是对象，因此由类型 `O` 的值表示。返回地址是一个托管指针（类型 `&`）。

对于不是零基的一维数组和多维数组，数组类提供了一个 `Address` 方法。

如果此指令前缀为 `readonly.`，它将生成一个可控易变托管指针。

> *异常*：

如果 _array_ 为 null，将抛出 `System.NullReferenceException` 异常。

如果 _index_ 为负数，或大于 _array_ 的边界，将抛出 `System.IndexOutOfRangeException` 异常。

如果 _array_ 不包含所需类型的元素，将抛出 `System.ArrayTypeMismatchException` 异常。

> *正确性*：

正确的 CIL 确保类是指向类的 *TypeDef*，*TypeRef* 或 *TypeSpec* *token*，并且 _array_ 确实总是 `null` 或一个零基、一维数组，其声明的元素类型是 *验证可赋值给* _typeTok_。

> *可验证性*：

验证要求：
 * _array_ 的跟踪类型是 `T[]`，对于某个 `T`，或 `Null` 类型（§[III.1.8.1.2](iii.1.8.1.2-verification-type-system.md)）；
 * 到 `T` 的托管指针是 *指针元素可赋值给* 到 _typeTok_ 的托管指针；并且
 * _index_ 的类型是 `int32` 或 `native int`。

验证将结果 _address_ 的类型跟踪为到 _typeTok_ 验证类型的托管指针。

>---
### ldfld ：加载对象的字段
<a id="ldfld"></a>

| Format     | Assembly Format | Description                                       |
| :--------- | :-------------- | :------------------------------------------------ |
| 7B _\<T\>_ | `ldfld` _field_ | 将对象（或值类型）_obj_ 的 _field_ 的值推入堆栈。 |

> *堆栈转换*：

&hellip;, _obj_ &rarr; &hellip;, _value_

> *描述*：

`ldfld` 指令将 _obj_ 的字段的值推入堆栈。_obj_ 应该是一个对象（类型 `O`），一个托管指针（类型 `&`），一个非托管指针（类型 `native int`），或一个值类型的实例。在可验证代码中不允许使用非托管指针。_field_ 是一个元数据 *token*（*FieldRef* 或 *FieldDef*），应该引用一个字段成员。返回类型与 _field_ 相关联。`ldfld` 将对象引用从堆栈弹出，并将字段的值推入其位置。字段可以是实例字段（在这种情况下，_obj_ 不应为 null）或静态字段。

`ldfld` 指令可以由 `unaligned.` 和 `volatile.` 前缀中的一个或两个前缀。如果需要，字段值在加载到堆栈时会转换为其 *中间类型* 的表示形式。 即小于 4 字节的字段值、布尔值或字符通过适当的符号或零扩展转换为 4 字节。浮点值转换为其本机大小（类型 `F`）。

> *异常*：

如果 _field_ 不可访问，将抛出 `System.FieldAccessException` 异常。

如果在元数据中找不到 _field_，将抛出 `System.MissingFieldException` 异常。这通常在 CIL-to-native-code 时检查，而不是在运行时。

如果 _obj_ 为 `null` 并且字段不是静态的，将抛出 `System.NullReferenceException` 异常。

> *正确性*：

正确的 CIL 确保 _field_ 是一个有效的引用字段的  *token*，并且 _obj_ 的类型与 _field_ 的 Class 兼容。

> *可验证性*：

对于可验证的代码，_obj_ 不应该是一个非托管指针。_obj_ 的跟踪类型应该具有，或者是一个到具有静态或实例字段的类型的托管指针。

不可验证地访问重叠的对象引用字段。

只有当与其重叠的每个字段也可访问时，字段才可访问。

验证将堆栈上的 _value_ 的类型跟踪为 _field_ 类型的 *中间类型*。

>---
### ldflda ：加载字段地址

| Format     | Assembly Format  | Description                              |
| :--------- | :--------------- | :--------------------------------------- |
| 7C _\<T\>_ | `ldflda` _field_ | 将对象 _obj_ 的 _field_ 的地址推入堆栈。 |

> *堆栈转换*：

&hellip;, _obj_ &rarr; &hellip;, _address_

> *描述*：

`ldflda` 指令将 _obj_ 的一个字段的地址推入堆栈。_obj_ 是一个对象（类型 `O`），一个托管指针（类型 `&`），或一个非托管指针（类型 `native int`）。在可验证的代码中不允许使用非托管指针。由 `ldflda` 返回的值是一个托管指针（类型 `&`），除非 _obj_ 是一个非托管指针，在这种情况下它是一个非托管指针（类型 `native int`）。

_field_ 是一个元数据 *token*（*FieldRef* 或 *FieldDef*），应该引用一个字段成员。字段可以是实例字段（在这种情况下，_obj_ 不应为 `null`）或静态字段。

> *异常*：

如果 _field_ 不可访问，将抛出 `System.FieldAccessException` 异常。

如果 _obj_ 不在其正在访问的应用程序域内，将抛出 `System.InvalidOperationException` 异常。无法加载不在访问应用程序域内的字段的地址。

如果在元数据中找不到 _field_，将抛出 `System.MissingFieldException` 异常。这通常在 CIL-to-native-code 时检查，而不是在运行时。

如果 _obj_ 为 `null` 并且字段不是静态的，将抛出 `System.NullReferenceException` 异常。

> *正确性*：

正确的 CIL 确保 _field_ 是一个有效的 *FieldRef* *token*，并且 _obj_ 的类型与 _field_ 的 Class 兼容。

> *可验证性*：

对于可验证的代码，_obj_ 不应该是一个非托管指针。

_obj_ 的跟踪类型应该具有，或者是一个到具有静态或实例字段的类型的托管指针。

对于可验证的代码，_field_ 不能是 **initonly**。

不可验证地访问重叠的对象引用 _field_。

只有当与其重叠的每个字段也可访问时，字段才可访问。

验证将堆栈上的值的类型跟踪为到 _field_ 的 *验证类型* 的托管指针。

> *备注*：

使用 `ldflda` 计算静态、**initonly** 字段的地址，然后使用结果指针在类初始化器的主体之外修改该值可能会导致不可预测的行为。

>---
### ldlen ：加载数组的长度

| Format | Assembly Format | Description                                            |
| :----- | :-------------- | :----------------------------------------------------- |
| 8E     | `ldlen`         | 将数组的长度（类型为 `native unsigned int`）推入堆栈。 |

> *堆栈转换*：

&hellip;, _array_ &rarr; &hellip;, length

> *描述*：

`ldlen` 指令将 _array_（一个零基一维数组）的元素数量推入堆栈。数组是对象，因此由类型 `O` 的值表示。返回值是 `native unsigned int`。

> *异常*：

如果 _array_ 为 `null`，将抛出 `System.NullReferenceException` 异常。

> *正确性*：

正确的 CIL 确保 `array` 确实总是 `null` 或一个零基、一维数组。

>---
### ldobj ：将地址处的值复制到堆栈

 | Format      | Assembly Format   | Description                           |
 | :---------- | :---------------- | :------------------------------------ |
 | 71 _\<\T\>_ | `ldobj` _typeTok_ | 将存储在地址 _src_ 处的值复制到堆栈。 |

> *堆栈转换*：

&hellip;, _src_ &rarr; &hellip;, _val_

> *描述*：

`ldobj` 指令将一个值复制到求值堆栈。_typeTok_ 是一个元数据 *token*（*TypeDef*，*TypeRef* 或 *TypeSpec*）。_src_ 是一个非托管指针（`native int`），或一个托管指针（`&`）。如果 _typeTok_ 不是泛型参数并且是引用类型或内置值类，则 `ldind` 指令为 `ldobj` 指令提供了简写。

`ldobj` 指令可以用来将值类型作为参数传递。

如果需要，当加载到堆栈时，值会转换为 _typeTok_ 的 *中间类型* 的表示形式。即小于 4 字节的整数值、布尔值或字符通过适当的符号或零扩展转换为 4 字节。浮点值转换为 `F` 类型。

`ldobj` 指令的操作可以通过紧接在前面的 `volatile.` 或 `unaligned.` 前缀指令进行更改。

> *异常*：

如果检测到无效地址，可能会抛出 `System.NullReferenceException` 异常。

如果找不到 _typeTok_，将抛出 `System.TypeLoadException` 异常。这通常在 CIL 转换为本机代码时而不是在运行时检测到。
> *正确性*：

_typeTok_ 应该是一个有效的 *TypeDef*，*TypeRef* 或 *TypeSpec* 元数据 *token*。

与 `ldind` 指令不同，`ldobj` 指令可以与泛型参数类型一起使用。

> *可验证性*：

堆栈顶部的源值的跟踪类型应该是到某种类型 _srcType_ 的托管指针，且 _srcType_ 应该是 *可赋值给* 类型 _typeTok_。

验证将结果 _val_ 的类型跟踪为 _typeTok_ 的 *中间类型*。

>---
### ldsfld ：加载类的静态字段

 | Format     | Assembly Format  | Description               |
 | :--------- | :--------------- | :------------------------ |
 | 7E _\<T\>_ | `ldsfld` _field_ | 将 _field_ 的值推入堆栈。 |

> *堆栈转换*：

&hellip;, &rarr; &hellip;, _value_

> *描述*：

`ldsfld` 指令将静态字段（在类的所有实例中共享）的值推入堆栈。_field_ 是一个元数据 *token*（*FieldRef* 或 *FieldDef*），引用一个静态字段成员。返回类型与 _field_ 相关联。

`ldsfld` 指令可以有 `volatile.` 前缀。如果需要，字段值在加载到堆栈时会转换为其 *中间类型* 的表示形式。即小于 4 字节的字段值、布尔值或字符通过适当的符号或零扩展转换为 4 字节。浮点值转换为其本机大小（类型 `F`）。

> *异常*：

如果 _field_ 不可访问，将抛出 `System.FieldAccessException` 异常。

如果在元数据中找不到 _field_，将抛出 `System.MissingFieldException` 异常。这通常在 CIL-to-native-code 时检查，而不是在运行时。

> *正确性*：

正确的 CIL 确保 _field_ 是一个有效的引用静态字段成员的元数据 *token*。

> *可验证性*：

验证将堆栈上的值的类型跟踪为字段类型的 *中间类型*。

>---
### ldsflda ：加载静态字段地址

 | Format     | Assembly Format   | Description                         |
 | :--------- | :---------------- | :---------------------------------- |
 | 7F _\<T\>_ | `ldsflda` _field_ | 将静态字段 _field_ 的地址推入堆栈。 |

> *堆栈转换*：

&hellip;, &rarr; &hellip;, _address_

> *描述*：

`ldsflda` 指令将静态字段的地址（如果 _field_ 引用的类型的内存是托管的，则为托管指针，类型为 `&`；否则为非托管指针，类型为 `native int`）推入堆栈。`field` 是一个元数据 *token*（*FieldRef* 或 *Fielddef*），引用一个静态字段成员。_field_ 可以是具有分配 RVA 的静态全局变量，在这种情况下，其内存是非托管的；其中 RVA 代表相对虚拟地址，即字段从其包含的 PE 文件加载到内存的基地址的偏移。

> *异常*：

如果 _field_ 不可访问，将抛出 `System.FieldAccessException` 异常。

如果在元数据中找不到 _field_，将抛出 `System.MissingFieldException` 异常。这通常在 CIL-to-native-code 时检查，而不是在运行时。

> *正确性*：

如果 _field_ 引用的类型的内存是托管的，正确的 CIL 确保 _field_ 是一个有效的引用静态字段成员的元数据 *token*。

> *可验证性*：

对于可验证的代码，_field_ 不能是 init-only。

如果 _field_ 引用的类型的内存是托管的，验证将堆栈上加载的值的类型跟踪为到 _field_ 的 *中间类型* 的托管指针。如果 _field_ 引用的类型的内存是非托管的，验证将堆栈上加载的值的类型跟踪为非托管指针。

> *备注*:

使用 `ldsflda` 计算静态、**initonly** 字段的地址，然后使用结果指针在类初始化器的主体之外修改该值可能会导致不可预测的行为。

>---
### ldstr ：加载字面字符串

| Format     | Assembly Format  | Description                            |
| :--------- | :--------------- | :------------------------------------- |
| 72 _\<T\>_ | `ldstr` _string_ | 将字面 _string_ 的字符串对象推入堆栈。 |

> *堆栈转换*：

&hellip;, &rarr; &hellip;, `string`

> *描述*：

`ldstr` 指令将一个新的字符串对象（表示存储在元数据中的字面量 _string_，这是一个字符串字面量）推入堆栈。

默认情况下，CLI 保证两个 `ldstr` 指令引用的两个元数据标记具有相同的字符序列，返回完全相同的字符串对象（这个过程称为 "字符串内联"）。这种行为可以使用 `System.Runtime.CompilerServices.CompilationRelaxationsAttribute` 和 `System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning` 进行控制。

> *正确性*：

正确的 CIL 要求 _string_ 是一个有效的字符串字面量元数据 *token*。

>---
### ldtoken ：加载元数据 *token* 的运行时表示

 | Format     | Assembly Format   | Description                           |
 | :--------- | :---------------- | :------------------------------------ |
 | D0 _\<T\>_ | `ldtoken` _token_ | 将元数据 *token* 转换为其运行时表示。 |

> *堆栈转换*：

&hellip; &rarr; &hellip;, `RuntimeHandle`

> *描述*：

`ldtoken` 指令将指定的元数据标记的 `RuntimeHandle` 推入堆栈。标记应为以下之一：
 * *MethodDef*，*MethodRef* 或 *MethodSpec*：推入 `RuntimeMethodHandle`
 * *TypeDef*，*TypeRef* 或 *TypeSpec*：推入 `RuntimeTypeHandle`
 * *FieldDef* 或 *FieldRef*：推入 `RuntimeFieldHandle`

堆栈上推入的值可以在系统类库的反射方法中使用。

> *正确性*：

正确的 CIL 要求 _token_ 描述了上述类型的有效元数据 *token*。

>---
### ldvirtftn ：加载虚方法指针

| Format        | Assembly Format      | Description                        |
| :------------ | :------------------- | :--------------------------------- |
| FE 07 _\<T\>_ | `ldvirtftn` _method_ | 将虚方法 *method* 的地址推入堆栈。 |

> *堆栈转换*：

&hellip; _object_ &rarr; &hellip;, _ftn_

> *描述*：

`ldvirtftn` 指令将一个方法指针推入堆栈，该方法指针指向实现与 _object_ 关联并由方法引用 _method_（元数据 *token*，*MethodDef*，*MethodRef* 或 *MethodSpec*）描述的虚方法的本地代码，或者推入与 _object_ 关联的方法的其他实现特定描述。如果推入的值引用托管方法（或从托管代码转换到非托管代码的存根），则可以使用 `calli` 指令调用。它也可以用于构造委托，存储在变量中等。

返回的值指向使用 _method_ 指定的调用约定的本地代码。因此，如果该例程期望相应的调用约定，那么方法指针可以传递给非托管本地代码（例如，作为回调例程）。此指令计算的地址可以是专门为此目的生成的 *thunk*（例如，当方法的本地版本不可用时，重新进入 CLI）。

实现此指令有许多选项。从概念上讲，此指令将指定方法的地址的表示形式放在虚拟机的求值堆栈上。就本机代码而言，这可以是一个地址（如指定的），包含地址的数据结构，或者可以用于计算地址的任何值，具体取决于底层机器的架构，本机调用约定，以及 VES 的实现技术（JIT，解释器，线程代码等）。

> *异常*：

当试图无效地访问非公共方法时，可能会抛出 `System.MethodAccessException` 异常。

如果 _object_ 为 `null`，将抛出 `System.NullReferenceException` 异常。

> *正确性*：

正确的 CIL 确保 _method_ 是一个有效的 *MethodDef*，*MethodRef* 或 *MethodSpec* *token*。还要确保 _method_ 引用了为 _object_ 定义的非静态方法。

> *可验证性*：

验证要求 _object_ 的跟踪类型与 _method_ 结合确定最终虚方法。如果确定的方法不是最终的，那么其 **this** 指针的确切类型无法静态确定。

对于上述要求有一个定义的例外，如 `newobj` 所述。验证跟踪值的方法签名，其中包括参数的数量和类型，**this** 指针的类型，以及返回类型和调用约定。

另请参见 `newobj` 指令。

>---
### mkrefany ：在堆栈上推送一个类型引用

| Format     | Assembly Format    | Description                                    |
| :--------- | :----------------- | :--------------------------------------------- |
| C6 _\<T\>_ | `mkrefany` _class_ | 将类型为 _class_ 的 _ptr_ 的类型引用推入堆栈。 |

> *堆栈转换*：

&hellip;, _ptr_ &rarr; &hellip;, _typedRef_

> *描述*：

`mkrefany` 指令支持传递动态类型引用。_ptr_ 应该是一个指针（类型 `&`，或 `native int`），它保存了一块数据的地址。_class_ 是描述 _ptr_ 类型的类标记（*TypeRef*，*TypeDef* 或 *TypeSpec*）。`mkrefany` 在堆栈上推入一个类型引用，即 _ptr_ 和 _class_ 的不透明描述符。此指令使得可以将动态类型引用作为参数传递。调用方可以使用 `refanytype` 和 `refanyval` 指令分别检索参数的类型（_class_）和地址（_ptr_）。

> *异常*：

如果找不到 _class_，将抛出 `System.TypeLoadException` 异常。这通常在 CIL-to-native-code 时检查，而不是在运行时。

> *正确性*：

正确的 CIL 确保 _class_ 是一个描述某种类型的有效 *TypeRef*，*TypeDef* 或 *TypeSpec* *token*，并且 _ptr_ 是一个指向确切该类型的指针。

> *可验证性*：

验证还要求 _ptr_ 是一个托管指针。如果无法推断出 _ptr_ 是一个指向 _class_ 实例的指针，验证将失败。

>---
### newarr ：创建一个零基一维数组

 | Format     | Assembly Format  | Description                           |
 | :--------- | :--------------- | :------------------------------------ |
 | 8D _\<T\>_ | `newarr` _etype_ | 创建一个元素类型为 _etype_ 的新数组。 |

> *堆栈转换*：

&hellip;, _numElems_ &rarr; &hellip;, _array_

> *描述*：

`newarr` 指令将一个引用推入堆栈，该引用引用一个新的零基一维数组，其元素的类型为 _etype_，一个元数据 *token*（*TypeRef*，*TypeDef* 或 *TypeSpec*）。_numElems_（类型为 `native int` 或 `int32`）指定数组中的元素数量。有效的数组索引是 0 &le; index < _numElems_。数组的元素可以是任何类型，包括值类型。

使用引用适当值类型（`System.Int32` 等）的元数据标记创建零基一维数字数组。数组的元素初始化为适当类型的 0。

非零基的一维数组和多维数组是使用 `newobj` 而不是 `newarr` 创建的。更常见的是，它们是使用基础框架中的 `System.Array` 类的方法创建的。

> *异常*：

如果没有足够的内存来满足请求，将抛出 `System.OutOfMemoryException` 异常。

如果 _numElems_ 是 < 0，将抛出 `System.OverflowException` 异常。

> *正确性*：

正确的 CIL 确保 _etype_ 是一个有效的 *TypeRef*，*TypeDef* 或 *TypeSpec* *token*。

> *可验证性*：

_numElems_ 应为 `native int` 或 `int32` 类型。

>---
### newobj ：创建新对象
<a id="newobj"></a>

| Format     | Assembly Format | Description                                   |
| :--------- | :-------------- | :-------------------------------------------- |
| 73 _\<T\>_ | `newobj` _ctor_ | 分配一个未初始化的对象或值类型并调用 _ctor_。 |

> *堆栈转换*：

&hellip;, _arg1_, &hellip; _argN_ &rarr; &hellip;, _obj_

> *描述*：

`newobj` 指令创建一个新对象或一个值类型的新实例。_ctor_ 是一个元数据标记（一个标记为构造函数的 *MethodRef* 或 *MethodDef*），它指示要调用的构造函数的名称、类和签名。如果找不到与指定的名称、类和签名完全匹配的构造函数，将抛出 `MissingMethodException` 异常。

`newobj` 指令分配与 _ctor_ 关联的类的一个新实例，并将新实例中的所有字段初始化为适当类型的 0 或适当的 `null`。然后，它使用给定的参数以及新创建的实例调用构造函数。在调用构造函数后，现在已初始化的对象引用被推入堆栈。

从构造函数的角度看，未初始化的对象是参数 0，传递给 `newobj` 的其他参数按顺序排列。

所有零基一维数组都是使用 `newarr` 而不是 `newobj` 创建的。另一方面，所有其他数组（维数超过一维，或者一维但不是零基）都是使用 `newobj` 创建的。

值类型通常不是使用 `newobj` 创建的。它们通常作为参数或局部变量分配，使用 `newarr`（对于零基一维数组），或作为对象的字段。一旦分配，它们就使用 `initobj` 初始化。然而，`newobj` 指令可以用来在堆栈上创建一个值类型的新实例，然后可以将其作为参数传递，存储在局部变量中等。

> *异常*：

如果 ctor 的类是抽象的，将抛出 `System.InvalidOperationException` 异常。

如果 _ctor_ 不可访问，将抛出 `System.MethodAccessException` 异常。

如果没有足够的内存来满足请求，将抛出 `System.OutOfMemoryException` 异常。

如果找不到具有指定名称、类和签名的构造函数方法，将抛出 `System.MissingMethodException` 异常。这通常在 CIL-to-native-code 时检查，而不是在运行时。

> *正确性*：

正确的 CIL 确保 _ctor_ 是一个有效的 *MethodRef* 或 *MethodDef* *token*，并且堆栈上的参数是 *可赋值给* 构造函数的参数。

> *可验证性*：

验证取决于是否正在创建委托或其他对象。有三种情况，按顺序排列：

 1. 如果 `newobj` 指令是 `dup`；`ldvirtftn`；`newobj` 指令序列的一部分，并且 _ctor_ 元数据 *token* 引用一个委托类型，那么正在创建一个虚函数的委托；
 2. 如果 `newobj` 指令是 `ldftn`；`newobj` 指令序列的一部分，并且 _ctor_ 元数据 *token* 引用一个委托类型，那么正在创建一个静态或非虚实例函数的委托；
 3. 否则，如果 _ctor_ 元数据 *token* 不引用委托类型，那么正在创建其他一些对象。

没有其他情况是可验证的。以下是三种情况的不同验证规则。

> *虚拟调度委托创建的可验证性*:

当 `newobj` 指令是以下指令序列的一部分时：

 ```cil
 dup
 ldvirtftn <function>
 newobj <ctor>
 ```

指令序列，然后验证检查：
 1. 在 `dup` 指令之前的堆栈上有一个类型为 *T* 的 _target_；
 2. function 是类型 *T* 上的虚方法的 *MethodRef* 或 *MethodDef* 或 *MethodSpec* 元数据 *token*；
 3. _ctor_ 是标记为委托类型 _deltype_ 的构造函数的  *MethodRef* 或 *MethodDef* 元数据 *token*；
 4. _ctor_ 可从 `newobj` 点访问；
 5. function 的签名是 *委托可赋值给* _deltype_ 的签名（即 _deltype_ 的 `Invoke` 方法的签名）；
 6. _target_ 的验证类型是 *验证可赋值给* _function_ 的 **this** 签名；并且
 7. 序列中没有分支指令定位到 `ldvirtftn` 或 `newobj` 指令。

验证将 _obj_ 的类型跟踪为 _deltype_。

> *静态和实例方法的接口调度委托创建的可验证性*：

当 `newobj` 指令是以下指令序列的一部分时：

 ```cil
  ldftn <function>
  newobj <ctor>
  ```
指令序列，然后验证检查：

 1. _function_ 是静态或非虚实例方法的 *MethodRef* 或 *MethodDef* 或 *MethodSpec* 元数据 *token*；
 2. 在 `ldftn` 指令之前的堆栈上有一个 _target_，并且 _target_ 的验证类型是：
     1. 如果 _function_ 引用实例方法，则 *验证可赋值给* _function_ 的 **this** 签名，或者
     2. 如果 _function_ 引用静态方法，则为 `null`（即 `ldnull` 的结果）
 3. _ctor_ 是标记为委托类型 _deltype_ 的构造函数的 *MethodRef* 或 *MethodDef* 元数据 *token*；
 4. _ctor_ 可从 `newobj` 点访问；
 5. _function_ 的签名是 *委托可赋值给* _deltype_ 的签名（即 _deltype_ 的 `Invoke` 方法的签名）；并且
 6. 当 _function_ 是非 **final** 虚方法，且堆栈上的 _target_ 不是装箱的值类型时，验证检查 _target_ 是 `ldarg.s 0`，`ldarg 0` 或 `ldarg.0` 的结果，且创建者的主体不包含 `starg.s 0`，`starg 0` 或 `ldarga.s 0`，`ldarga 0`。这反映了 `call` 指令的要求和理由。并且
 7. 序列中没有分支指令定位到 `newobj` 指令。

验证将 _obj_ 的类型跟踪为 _deltype_。

> *非委托对象的创建的可验证性*：

验证检查：
 1. _ctor_ 是标记为非委托类型 *T* 的构造函数的 *MethodRef* 或 *MethodDef* 元数据 *token*；
 2. _ctor_ 可从 `newobj` 点访问；并且
 3. 堆栈上的参数；_arg1_，&hellip; _argN_；的类型是 *验证可赋值给* _ctor_ 签名的参数签名。
 
 验证将 _obj_ 的类型跟踪为 _T_。

>---
### refanytype ：从类型引用中加载类型

| Format | Assembly Format | Description                      |
| :----- | :-------------- | :------------------------------- |
| FE 1D  | `refanytype`    | 推送存储在类型引用中的类型标记。 |

> *堆栈转换*：

&hellip;, _TypedRef_ &rarr; &hellip;, _type_

> *描述*：

检索嵌入在 _TypedRef_ 中的类型标记。参见 `mkrefany` 指令。

> *异常*：

正确的 CIL 确保 _TypedRef_ 是一个有效的类型引用（由先前的 `mkrefany` 调用创建）。

> *可验证性*：

`refanytype` 指令始终可验证。

>---
### refanyval ：从类型引用中加载地址

 | Format     | Assembly Format    | Description                  |
 | :--------- | :----------------- | :--------------------------- |
 | C2 _\<T\>_ | `refanyval` _type_ | 推送存储在类型引用中的地址。 |

> *堆栈转换*：

&hellip;, _TypedRef_ &rarr; &hellip;, _address_

> *描述*：

检索嵌入在 _TypedRef_ 中的地址（类型为 `&`）。_TypedRef_ 中的引用类型应与 _type_ 指定的类型匹配（元数据 *token*，*TypeDef*，*TypeRef* 或 *TypeSpec*）。参见 `mkrefany` 指令。

> *异常*：

如果 _type_ 与存储在 _TypedRef_ 中的类型不完全相同（即，提供给构造 _TypedRef_ 的 `mkrefany` 指令的类），将抛出 `System.InvalidCastException` 异常。

如果找不到 _type_，将抛出 `System.TypeLoadException` 异常。

> *正确性*：

正确的 CIL 确保 _TypedRef_ 是一个有效的类型引用（由先前的 `mkrefany` 调用创建）。

> *可验证性*：

`refanyval` 指令始终可验证。

>---
### rethrow ：重新抛出当前异常

 | Format | Assembly Format | Description        |
 | :----- | :-------------- | :----------------- |
 | FE 1A  | `rethrow`       | 重新抛出当前异常。 |

> *堆栈转换*：

&hellip;, &rarr; &hellip;,

> *描述*：

`rethrow` 指令只允许在 **catch** 处理程序的主体内使用。它抛出与此处理程序捕获的相同的异常。重新抛出不会改变对象中的堆栈跟踪。

> *异常*：

抛出原始异常。

> *正确性*：

正确的 CIL 只在 **catch** 处理程序的主体内使用此指令（不包括嵌入在该 **catch** 处理程序中的任何异常处理程序）。如果在其他地方发生重新抛出，将抛出一个异常，但是准确的异常是未定义的

>---
### sizeof ：加载类型的字节大小

 | Format        | Assembly Format    | Description                                    |
 | :------------ | :----------------- | :--------------------------------------------- |
 | FE 1C _\<T\>_ | `sizeof` _typeTok_ | 以 `unsigned int32` 的形式推送类型的字节大小。 |

> *堆栈转换*：

&hellip;, &rarr; &hellip;, _size_ (4 字节，无符号)

> *描述*：

返回类型的字节大小。_typeTok_ 可以是泛型参数，引用类型或值类型。

对于引用类型，返回的大小是相应类型的引用值的大小，而不是引用值引用的对象中存储的数据的大小。

值类型的定义可以在生成 CIL 时和加载执行时之间改变。因此，当生成 CIL 时，类型的大小并不总是已知的。`sizeof` 指令允许 CIL 代码在运行时确定大小，而无需调用框架类库。计算可以完全在运行时或在编译 CIL-to-native-code 时进行。`sizeof` 返回此类型的数组中每个元素将占用的总大小 — 包括实现选择添加的任何填充。具体来说，数组元素相距 `sizeof` 字节。

> *正确性*：

_typeTok_ 应为 *TypeDef*，*TypeRef* 或 *TypeSpec* 元数据 *token*。

> *可验证性*：

`sizeof` 始终可验证。

>---
### stelem ：将元素存储到数组中

| Format     | Assembly Format    | Description                             |
| :--------- | :----------------- | :-------------------------------------- |
| A4 _\<T\>_ | `stelem` _typeTok_ | 用堆栈上的值替换数组中 _index_ 处的元素 |

> *堆栈转换*：

&hellip;, _array_, _index_, _value_, &rarr; &hellip;

> *描述*：

`stelem` 指令用 _value_ 替换一维数组 _array_ 中零基索引 _index_（类型为 `native int` 或 `int32`）处的元素的值。数组是对象，因此由类型 `O` 的值表示。值的类型必须与指令中的 _typeTok_ *数组元素兼容*。

存储到保存小于 4 字节值的数组中，其中间类型为 `int32`，会在值从堆栈移动到数组时截断该值。浮点值从其本地大小（类型 `F`）四舍五入到与数组关联的大小。

对于非零基的一维数组和多维数组，数组类提供了一个 `StoreElement` 方法。

> *异常*：

如果 _array_ 为 null，将抛出 `System.NullReferenceException` 异常。

如果 _index_ 大于 _array_ 的边界，将抛出 `System.IndexOutOfRangeException` 异常。

如果 _array_ 不包含所需类型的元素，将抛出 `System.ArrayTypeMismatchException` 异常。

> *正确性*：

_typeTok_ 应为有效的 `typedef`，`typeref` 或 `typespec` 元数据标记。

_array_ 应为 null 或单维数组。

> *可验证性*：

验证要求：
 * _array_ 的跟踪类型是 `T[]`，对于某个 `T`；
 * _value_ 的跟踪类型是 *数组元素兼容* 的 _typeTok_；
 * _typeTok_ 是 *数组元素兼容* 的 `T`；并且
 * _index_ 的类型是 `int32` 或 `native int`。

>---
### stelem.\<type\> ：将元素存储到数组中

| Format | Assembly Format | Description                                                   |
| :----- | :-------------- | :------------------------------------------------------------ |
| 9C     | `stelem.i1`     | 用堆栈上的 `int8` _value_ 替换数组中 _index_ 处的元素。       |
| 9D     | `stelem.i2`     | 用堆栈上的 `int16` _value_ 替换数组中 _index_ 处的元素。      |
| 9E     | `stelem.i4`     | 用堆栈上的 `int32` _value_ 替换数组中 _index_ 处的元素。      |
| 9F     | `stelem.i8`     | 用堆栈上的 `int64` _value_ 替换数组中 _index_ 处的元素。      |
| A0     | `stelem.r4`     | 用堆栈上的 `float32` _value_ 替换数组中 _index_ 处的元素。    |
| A1     | `stelem.r8`     | 用堆栈上的 `float64` _value_ 替换数组中 _index_ 处的元素。    |
| 9B     | `stelem.i`      | 用堆栈上的 `native int` _value_ 替换数组中 _index_ 处的元素。 |
| A2     | `stelem.ref`    | 用堆栈上的 ref _value_ 替换数组中 _index_ 处的元素。          |

> *堆栈转换*：

&hellip;, _array_, _index_, _value_ &rarr; &hellip;,

> *描述*：

`stelem.`_\<type\>_ 指令用 _value_ 替换一维数组 _array_ 中零基索引 _index_（类型为 `int32` 或 `native int`）处的元素的值。数组是对象，因此由类型 `O` 的值表示。

存储到保存小于 4 字节值的数组中，其中中间类型为 `int32`，会在值从堆栈移动到数组时截断该值。浮点值从其本地大小（类型 `F`）四舍五入到与数组关联的大小。

除 `stelem.ref` 外，所有变体都等同于带有适当 _typeTok_ 的 `stelem` 指令。

请注意，`stelem.ref` 在将值分配给数组元素之前，隐式地将值转换为 _array_ 的元素类型。即使对于已验证的代码，这种转换也可能失败。因此，`stelem.ref` 指令可以抛出 `ArrayTypeMismatchException` 异常。这种行为与 `stelem` 不同。

对于非零基的一维数组和多维数组，数组类提供了一个 `StoreElement` 方法。

> *异常*：

如果 _array_ 为 null，将抛出 `System.NullReferenceException` 异常。

如果 _index_ 为负数，或大于 _array_ 的边界，将抛出 `System.IndexOutOfRangeException` 异常。

如果 _array_ 不包含所需类型的元素，将抛出 `System.ArrayTypeMismatchException` 异常。

> *正确性*：

正确的 CIL 要求 _array_ 是一个零基一维数组，且指令中的类型是 *数组元素兼容* 其声明的元素类型。

> *可验证性*：

验证要求：
 * _array_ 的跟踪类型是 `T[]`，对于某个 `T`；
 * 对于 `stelem.ref`，_value_ 的跟踪类型是引用类型，并且是 *(数组元素)兼容* 的 `T`；
 * 对于其他指令变体，_value_ 的跟踪类型是 *数组元素兼容* 指令中的类型，且指令中的类型是 *数组元素兼容* 的 `T`；并且
 * _index_ 的类型是 `int32` 或 `native int`。

>---
### stfld ：将值存储到对象的字段中

| Format     | Assembly Format | Description                                 |
| :--------- | :-------------- | :------------------------------------------ |
| 7D _\<T\>_ | `stfld` _field_ | 用 _value_ 替换对象 _obj_ 的 _field_ 的值。 |

> *堆栈转换*：

&hellip;, _obj_, _value_ &rarr; &hellip;,

> *描述*：

`stfld` 指令用 _value_ 替换 _obj_（一个 `O`）或通过指针（类型为 `native int` 或 `&`）的 _field_ 的值。_field_ 是一个元数据标记（一个 *FieldRef* 或 *FieldDef*），它引用一个字段成员引用。`stfld` 弹出值和对象引用，并更新对象。

存储到保存小于 4 字节值的字段中，会在值从堆栈移动到局部变量时截断该值。浮点值从其本地大小（类型 `F`）四舍五入到与参数关联的大小。

`stfld` 指令可以有 `unaligned.` 和 `volatile.` 的一个或两个前缀。

> *异常*：

如果 _field_ 不可访问，将抛出 `System.FieldAccessException` 异常。

如果 _obj_ 为 null 并且字段不是静态的，将抛出 `System.NullReferenceException` 异常。

如果在元数据中找不到 _field_，将抛出 `System.MissingFieldException` 异常。这通常在 CIL-to-native-code 时检查，而不是在运行时。

> *正确性*：

正确的 CIL 确保 _field_ 是一个有效的引用字段的 *token*，并且 _obj_ 和 _value_ 将始终具有适合执行的赋值的类型，受到隐式转换的约束。

> *可验证性*：

对于可验证的代码，_obj_ 不应是一个非托管指针。

在类初始化器的主体之外使用 `stfld` 更改静态的、只读字段的值可能会导致不可预测的行为。然而，它不能破坏内存完整性或类型安全，因此它不是由验证来测试的。

_obj_ 的跟踪类型应具有，或者是一个具有静态或实例 _field_ 的类型的托管指针。

不可验证地访问重叠的对象引用字段。只有当每个与其重叠的字段都可访问时，字段才可访问。

验证还检查 _value_ 的类型是否是 *验证可赋值给* 字段的类型。

>---
### stobj ：将值存储到地址中

| Format     | Assembly Format   | Description                           |
| :--------- | :---------------- | :------------------------------------ |
| 81 _\<T\>_ | `stobj` _typeTok_ | 将类型为 _typeTok_ 的值存储到地址中。 |

> *堆栈转换*：

&hellip;, _dest_, _src_ &rarr; &hellip;,

> *描述*：

`stobj` 指令将值 _src_ 复制到地址 _dest_。如果 _typeTok_ 不是泛型参数并且是引用类型或内置值类，则 `stind` 指令为 `stobj` 指令提供了简写。

存储到内存中的值小于 4 字节的值会在值从堆栈移动到内存时截断该值。浮点值从其本地大小（类型 `F`）四舍五入到与 _typeTok_ 关联的大小。

`stobj` 指令的操作可以通过紧接在前面的 `volatile.` 或 `unaligned.` 前缀指令进行更改。

> *异常*：

如果检测到无效地址，可能会抛出 `System.NullReferenceException` 异常。

如果找不到 _typeTok_，将抛出 `System.TypeLoadException` 异常。这通常在 CIL-to-native-code 时检测，而不是在运行时。

> *正确性*：

正确的 CIL 确保 _dest_ 是指向 `T` 的指针，且 _src_ 的类型是 *验证可赋值给* `T`。

_typeTok_ 应为有效的 *TypeDef*，*TypeRef* 或 *TypeSpec* 元数据 *token*。

与 `stind` 指令不同，`stobj` 指令可以与泛型参数类型一起使用。

> *可验证性*：

让堆栈顶部的值的跟踪类型为某种类型 _srcType_。当 _srcType_ 是引用类型时，值应被初始化。在前面的堆栈槽中的目标地址 _dest_ 的跟踪类型应为某种类型 _destType_ 的托管指针（类型为 _destType_&）。最后，_srcType_ 应为 *验证可赋值给* _typeTok_。

>---
### stsfld ：存储类的静态字段
<a id="stfld"></a>

 | Format     | Assembly Format  | Description                  |
 | :--------- | :--------------- | :--------------------------- |
 | 80 _\<T\>_ | `stsfld` _field_ | 用 _val_ 替换 _field_ 的值。 |

> *堆栈转换*：

&hellip;, _val_ &rarr; &hellip;,

> *描述*：

`stsfld` 指令用堆栈上的值替换静态字段的值。_field_ 是一个元数据 *token*（*FieldRef* 或 *FieldDef*），应引用一个静态字段成员。`stsfld` 弹出堆栈上的值并用该值更新静态字段。

存储到保存小于 4 字节值的字段中，会在值从堆栈移动到局部变量时截断该值。浮点值从其本地大小（类型 `F`）四舍五入到与参数关联的大小。

`stsfld` 指令可以有 `volatile.` 前缀。

> *异常*：

如果 _field_ 不可访问，将抛出 `System.FieldAccessException` 异常。

如果在元数据中找不到 _field_，将抛出 `System.MissingFieldException` 异常。这通常在 CIL-to-native-code 时检查，而不是在运行时。

> *正确性*：

正确的 CIL 确保 _field_ 是一个有效的引用静态字段的标记，且 _value_ 将始终具有适合执行的赋值的类型，受到隐式转换的约束。

> *可验证性*：

验证检查 _val_ 的类型是否是 *验证可赋值给* 字段的类型。

在类初始化器的主体之外使用 `stsfld` 更改静态的、只读字段的值可能会导致不可预测的行为。然而，它不能破坏内存完整性或类型安全，因此它不是由验证来测试的。

>---
### throw ：抛出异常

| Format | Assembly Format | Description |
| :----- | :-------------- | :---------- |
| 7A     | `throw`         | 抛出异常。  |

> *堆栈转换*：

&hellip;, _object_ &rarr; &hellip;,

> *描述*：

`throw` 指令抛出堆栈上的异常 _object_（类型 `O`）并清空堆栈。虽然 CLI 允许抛出任何对象，但 CLS 描述了一个特定的异常类，应用于语言互操作性。

> *异常*：

如果 _obj_ 为 `null`，则抛出 `System.NullReferenceException` 异常。

> *正确性*：

正确的 CIL 确保 _object_ 始终是 `null` 或对象引用（即，类型为 `O`）。

>---
### unbox ：将装箱的值类型转换为其原始形式
<a id="unbox"></a>

 | Format     | Assembly Format     | Description                                 |
 | :--------- | :------------------ | :------------------------------------------ |
 | 79 _\<T\>_ | `unbox` _valuetype_ | 从 _obj_ 中提取值类型，这是其装箱表示形式。 |

> *堆栈转换*：

&hellip;, _obj_ &rarr; &hellip;, _valueTypePtr_

> *描述*：

在 CLI 中，值类型有两种不同的表示形式：
 * 当值类型嵌入在另一个对象中时使用的 “原始” 形式。
 * “装箱”形式，其中值类型中的数据被包装（装箱）到一个对象中，因此它可以作为一个独立的实体存在。

`unbox` 指令将 _obj_（类型为 `O`），值类型的装箱表示形式，转换为 _valueTypePtr_（可控易变托管指针），类型 `&`），其未装箱形式。_valuetype_ 是一个元数据 *token*（*TypeRef*，*TypeDef* 或 *TypeSpec*）。_obj_ 中包含的 _valuetype_ 的类型必须是 *验证可赋值给* _valuetype_。

与 `box` 不同，`box` 需要复制值类型以在对象中使用，`unbox` 不需要从对象中复制值类型。通常，它只是计算已经存在于装箱对象内部的值类型的地址。

通常，`unbox` 只是计算已经存在于装箱对象内部的值类型的地址。当拆箱可空值类型时，这种方法是不可能的。因为 `Nullable<T>` 值在 `box` 操作期间转换为装箱的 `T`，因此实现通常必须在堆上制造一个新的 `Nullable<T>` 并计算到新分配的对象的地址。

> *异常*：

如果 _obj_ 不是装箱的值类型，_valuetype_ 是 `Nullable<T>` 并且 _obj_ 不是装箱的 `T`，或者 _obj_ 中包含的值的类型不是 *验证可赋值给* _valuetype_，则抛出 `System.InvalidCastException` 异常。

如果 _obj_ 为 null 并且 _valuetype_ 是非可空值类型，则抛出 `System.NullReferenceException` 异常。

如果找不到类，则抛出 `System.TypeLoadException` 异常。这通常在 CIL-to-native-code 时检测，而不是在运行时。）

> *正确性*：

正确的 CIL 确保 _valueType_ 是某个可装箱值类型的 *TypeRef*，*TypeDef* 或 *TypeSpec* 元数据 *token*，且 _obj_ 始终是对象引用（即，类型为 `O`）。如果 _valuetype_ 是类型 `Nullable<T>`，则装箱实例应为类型 `T`。

> *可验证性*：

验证要求 _obj_ 中包含的 _valuetype_ 的类型必须是 *验证可赋值给* _valuetype_

>---
### unbox.any ：将装箱类型转换为值

| Format     | Assembly Format       | Description                               |
| :--------- | :-------------------- | :---------------------------------------- |
| A5 _\<T\>_ | `unbox.any` _typeTok_ | 从 _obj_ 中提取值类型，这是其装箱表示形式 |

> *堆栈转换*：

&hellip;, _obj_ &rarr; &hellip;, _value_ 或 _obj_

> *描述*：

当应用于值类型的装箱形式时，`unbox.any` 指令提取 _obj_（类型为 `O`）中包含的值。（它等同于 `unbox` 后跟 `ldobj`。）当应用于引用类型时，`unbox.any` 指令与 `castclass` _typeTok_ 具有相同的效果。

如果 _typeTok_ 是 _GenericParam_，则运行时行为由该参数的实际实例化确定。

> *异常*：

如果 _obj_ 不是装箱的值类型或引用类型，_typeTok_ 是 `Nullable<T>` 并且 _obj_ 不是装箱的 `T`，或者 _obj_ 中包含的值的类型不是 *验证可赋值给* _typeTok_，则抛出 `System.InvalidCastException` 异常。

如果 _obj_ 为 `null` 并且 _typeTok_ 是非可空值类型，则抛出 `System.NullReferenceException` 异常。

> *正确性*：

_obj_ 应为引用类型，_typeTok_ 应为可装箱类型。

> *可验证性*：

验证跟踪 _value_ 或 _obj_ 的类型作为 _typeTok_ 的中间类型。

> *理由*:

有两个原因需要同时具有 `unbox.any` 和 `unbox` 指令：
 1. 与 `unbox` 指令不同，对于值类型，`unbox.any` 在堆栈上留下一个值，而不是值的地址。
 2. `unbox` 的类型操作数有一个限制：它只能表示值类型和泛型值类型的实例化。

---
##





## end
----


接下来你会翻译我说的每句英文为中文
