

## 22. 元数据物理布局
<a id="metadata-physical-layout"></a>

元数据的物理磁盘表示是对逻辑表示的直接反映，逻辑表示在 §[II.22](ii.22-metadata-logical-format-tables.md) 和 §[II.23](ii.23-metadata-logical-format-other-structures.md) 中描述。也就是说，数据存储在表示元数据表和堆的流中。主要的复杂性在于，逻辑表示从索引到表和列所需的字节数中抽象出来，而物理表示必须通过定义如何将逻辑元数据堆和表映射到它们的物理表示来明确处理这个问题。

除非另有说明，所有的二进制值都以小端格式存储。

### 22.1. 固定字段

完整的CLI组件 (元数据和CIL指令) 存储在当前可移植可执行 (PE) 文件格式的一个子集中 (§[II.25](ii.25-file-format-extensions-to-pe.md))。由于这种遗产，元数据的物理表示中的一些字段具有固定值。在写入这些字段时，最好将它们设置为指示的值，读取时应忽略它们。

### 22.2. File headers

#### 22.2.1. 元数据根

物理元数据的根开始于一个魔术签名，接着是几个字节的版本和其他杂项信息，然后是一个计数和一个流头数组，每个流都有一个。实际的编码表和堆存储在流中，这些流紧接着这个头数组。

 | 偏移     | 大小    | 字段              | 描述                                                                                                                                                             |
 | -------- | ------- | ----------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
 | 0        | 4       | **Signature**     | 物理元数据的魔术签名：0x424A5342。                                                                                                                               |
 | 4        | 2       | **MajorVersion**  | 主版本，1 (读取时忽略)                                                                                                                                           |
 | 6        | 2       | **MinorVersion**  | 次版本，1 (读取时忽略)                                                                                                                                           |
 | 8        | 4       | **Reserved**      | 保留，始终为0 (§[II.24.1](ii.24.1-fixed-fields.md))。                                                                                                            |
 | 12       | 4       | **Length**        | 分配用来保存版本字符串 (包括空终止符) 的字节数，称之为 *x*。<p>称字符串 (包括终止符) 的长度为 *m* (我们要求 *m* &le; 255) ；长度 *x* 是 *m* 向上舍入到四的倍数。 |
 | 16       | *m*     | **Version**       | 长度为 *m* 的 UTF8 编码的空终止版本字符串 (见上文)                                                                                                               |
 | 16+*m*   | *x*-*m* | &nbsp;            | 填充到下一个4字节边界。                                                                                                                                          |
 | 16+*x*   | 2       | **Flags**         | 保留，始终为0 (§[II.24.1](ii.24.1-fixed-fields.md))。                                                                                                            |
 | 16+*x*+2 | 2       | **Streams**       | 流的数量，比如说 *n*。                                                                                                                                           |
 | 16+*x*+4 | &nbsp;  | **StreamHeaders** | *n* 个 `StreamHdr` 结构的数组。                                                                                                                                  |

对于任何打算在 CLI 的任何符合规范的实现上执行的文件，版本字符串应为 "`Standard CLI 2005`"，所有符合规范的 CLI 实现都应接受使用此版本字符串的文件。当文件受限于特定于供应商的 CLI 实现时，应使用其他字符串。此标准的未来版本将指定不同的字符串，但它们应以 "`Standard CLI`" 开始。指定附加功能的其他标准应指定以 "`Standard□`" 开始的特定版本字符串，其中 "`□`" 表示一个空格。提供实现特定扩展的供应商应提供一个不以 "`Standard□`" 开始的版本字符串。 (对于此标准的第一个版本，版本字符串是 "`Standard CLI 2002`"。)

#### 22.2.2. 流头

流头提供了表或堆的名称，位置和长度。请注意，流头结构的长度不是固定的，而取决于其名称字段的长度 (一个可变长度的空终止字符串)。

 | 偏移 | 大小   | 字段       | 描述                                                                                             |
 | ---- | ------ | ---------- | ------------------------------------------------------------------------------------------------ |
 | 0    | 4      | **Offset** | 从元数据根的开始到此流的开始的内存偏移 (§[II.24.2.1](ii.24.2.1-metadata-root.md))                |
 | 4    | 4      | **Size**   | 此流的字节大小，应为4的倍数。                                                                    |
 | 8    | &nbsp; | **Name**   | 流的名称，为ASCII字符的空终止可变长度数组，用`\0`字符填充到下一个4字节边界。名称限制为32个字符。 |

逻辑表和堆都存储在流中。有五种可能的流。一个名为"`#Strings`"的流头，指向存储标识符字符串的字符串堆的物理表示；一个名为"`#US`"的流头，指向用户字符串堆的物理表示；一个名为"`#Blob`"的流头，指向blob堆的物理表示，一个名为"`#GUID`"的流头，指向GUID堆的物理表示；以及一个名为"`#~`"的流头，指向一组表的物理表示。

每种类型的流最多只能出现一次，也就是说，元数据文件不应包含两个"`#US`"流，或五个"`#Blob`"流。如果流是空的，则不需要存在。

下一小节将更详细地描述每种类型的流的结构。

#### 22.2.3. #Strings 堆

由 "`#Strings`" 标头指向的字节流是逻辑字符串堆的物理表示。物理堆可以包含垃圾，也就是说，它可以包含从任何表都无法访问的部分，但是从表可以访问的部分应该包含一个有效的空终止 UTF8 字符串。当 #Strings 堆存在时，第一个条目总是空字符串 (即，`\0`)。

#### 22.2.4. #US 和 #Blob 堆

由"`#US`"或"`#Blob`"头指向的字节流分别是逻辑Userstring和'blob'堆的物理表示。只要从任何表中可达的任何部分包含有效的'blob'，这两个堆都可以包含垃圾。单个blob的长度在前几个字节中编码：

 * 如果'blob'的第一个字节是_0bbbbbbb<sub>2</sub>_，那么'blob'的其余部分包含_bbbbbbb<sub>2</sub>_字节的实际数据。

 * 如果'blob'的前两个字节是_10bbbbbb<sub>2</sub>_和*x*，那么'blob'的其余部分包含(_bbbbbb<sub>2</sub>_ << 8 + *x*)字节的实际数据。

 * 如果'blob'的前四个字节是_110bbbbb<sub>2</sub>_, *x*, *y*, 和 *z*，那么'blob'的其余部分包含(_bbbbb<sub>2</sub>_ << 24 + *x* << 16 + *y* << 8 + *z*)字节的实际数据。

这两个堆中的第一个条目是空的'blob'，由单个字节0x00组成。

 `#US` (用户字符串) 堆中的字符串使用16位Unicode编码。每个字符串的计数是字符串中的字节数 (不是字符)。此外，还有一个额外的终止字节 (因此所有字节计数都是奇数，而不是偶数)。这个最后的字节只有在字符串中的任何UTF16字符的顶字节设置了任何位，或者其低字节是以下任何一个：0x01&ndash;0x08, 0x0E&ndash;0x1F, 0x27, 0x2D, 0x7F时，才持有值1。否则，它持有0。1表示需要超出通常为8位编码集提供的处理的Unicode字符。

#### 22.2.5. #GUID 堆
<a id="guid-heap"></a>

"`#GUID`" 标头指向一系列 128 位的 GUID。在流中可能存储了无法访问的 GUID。

#### 22.2.6. #~ 流
<a id="physical-stream"></a>

"`#~`" 流包含逻辑元数据表的实际物理表示 (参见 §[II.22](ii.22-metadata-logical-format-tables.md))。"`#~`" 流具有以下顶级结构：

 | 偏移量    | 大小   | 字段             | 描述                                                               |
 | --------- | ------ | ---------------- | ------------------------------------------------------------------ |
 | 0         | 4      | **Reserved**     | 保留，始终为0 (参见 §[II.24.1](ii.24.1-fixed-fields.md))。         |
 | 4         | 1      | **MajorVersion** | 表模式的主版本；应为2 (参见 §[II.24.1](ii.24.1-fixed-fields.md))。 |
 | 5         | 1      | **MinorVersion** | 表模式的次版本；应为0 (参见 §[II.24.1](ii.24.1-fixed-fields.md))。 |
 | 6         | 1      | **HeapSizes**    | 堆大小的位向量。                                                   |
 | 7         | 1      | **Reserved**     | 保留，始终为1 (参见 §[II.24.1](ii.24.1-fixed-fields.md))。         |
 | 8         | 8      | **Valid**        | 存在表的位向量，让 *n* 是1的位的数量。                             |
 | 16        | 8      | **Sorted**       | 已排序表的位向量。                                                 |
 | 24        | 4\**n* | **Rows**         | 指示每个存在表的行数的 *n* 个4字节无符号整数的数组。               |
 | 24+4\**n* | &nbsp; | **Tables**       | 物理表的序列。                                                     |

_HeapSizes_ 字段是一个位向量，它编码了各种堆的索引的宽度。如果位0被设置，"`#Strings`" 堆的索引宽度为4字节；如果位1被设置，"`#GUID`" 堆的索引宽度为4字节；如果位2被设置，"`#Blob`" 堆的索引宽度为4字节。相反，如果未设置特定堆的 _HeapSizes_ 位，那么该堆的索引宽度为2字节。

 | 堆大小标志 | 描述                                        |
 | ---------- | ------------------------------------------- |
 | 0x01       | "`#Strings`" 流的大小 &ge; 2<sup>16</sup>。 |
 | 0x02       | "`#GUID`" 流的大小 &ge; 2<sup>16</sup>。    |
 | 0x04       | "`#Blob`" 流的大小 &ge; 2<sup>16</sup>。    |

_Valid_ 字段是一个64位位向量，对于存储在流中的每个表，都有一个特定的位被设置；表到索引的映射在 §[II.22](ii.22-metadata-logical-format-tables.md) 的开始处给出。例如，当 _DeclSecurity_ 表在逻辑元数据中存在时，应在 Valid 向量中设置位 0x0e。在 _Valid_ 中包含不存在的表是无效的，因此所有位于 0x2c 以上的位都应为零。

_Rows_ 数组包含每个存在的表的行数。在将物理元数据解码为逻辑元数据时，_Valid_ 中1的数量表示 _Rows_ 数组中的元素数量。

在编码逻辑表的过程中，一个关键的方面是其模式。每个表的模式在 §[II.22](ii.22-metadata-logical-format-tables.md) 中给出。例如，分配索引 0x02 的表是一个 _TypeDef_ 表，根据其在 §[II.22.37](ii.22.37-typedef-0x02.md) 中的规范，它具有以下列：一个4字节宽的标志，一个指向 String 堆的索引，另一个指向 String 堆的索引，一个指向 _TypeDef_、_TypeRef_ 或 _TypeSpec_ 表的索引，一个指向 _Field_ 表的索引，以及一个指向 _MethodDef_ 表的索引。

具有 *n* 列和 *m* 行的表的物理表示，其模式为 (*C*<sub>0</sub>,&hellip;,*C*<sub>*n*-1</sub>)，由每个行的物理表示的连接组成。具有模式 (*C*<sub>0</sub>,&hellip;,*C*<sub>n-1</sub>) 的行的物理表示是每个元素的物理表示的连接。在类型为 *C* 的列中，行单元 *e* 的物理表示定义如下：

 * 如果 *e* 是一个常量，它使用其列类型 *C* 指定的字节数存储 (即，_PropertyAttributes_ 类型的2位掩码)

 * 如果 *e* 是一个指向 GUID 堆、'blob' 或 String 堆的索引，它使用 _HeapSizes_ 字段定义的字节数存储。

 * 如果 *e* 是一个简单的指向索引为 *i* 的表的索引，如果表 *i* 的行数小于 216，则使用2字节存储，否则使用4字节存储。

* 如果 *e* 是一个编码索引，它指向 *n* 个可能的表 *t*<sub>0</sub>,&hellip;*t*<sub>*n*-1</sub> 中的表 *t*<sub>*i*</sub>，那么它被存储为 *e* << (log *n*) | tag{ *t*<sub>0</sub>,&hellip;*t*<sub>*n*-1</sub> }\[ *t*<sub>*i*</sub> \]，如果表 *t*<sub>0</sub>,&hellip;*t*<sub>*n*-1</sub> 的最大行数小于 2(16 – (log *n*))，则使用2字节存储，否则使用4字节存储。有限映射族 tag{ *t*<sub>0</sub>,&hellip;*t*<sub>*n*-1</sub> } 在下面定义。注意，解码物理行需要这个映射的逆。[例如，_Constant_ 表的 _Parent_ 列索引 _Field_、_Param_ 或 _Property_ 表中的一行。实际的表被编码到数字的低2位，使用值：0 => _Field_，1 => _Param_，2 => _Property_。剩余的位保存了被索引的实际行号。例如，值 0x321，索引 _Param_ 表中的行号 0xC8。]

 | TypeDefOrRef: 2 bits to encode tag | 标签 |
 | ---------------------------------- | ---- |
 | `TypeDef`                          | 0    |
 | `TypeRef`                          | 1    |
 | `TypeSpec`                         | 2    |

 | HasConstant: 2 bits to encode tag | 标签 |
 | --------------------------------- | ---- |
 | `Field`                           | 0    |
 | `Param`                           | 1    |
 | `Property`                        | 2    |

| HasCustomAttribute: 5 bits to encode tag | 标签 |
| ---------------------------------------- | ---- |
| `MethodDef`                              | 0    |
| `Field`                                  | 1    |
| `TypeRef`                                | 2    |
| `TypeDef`                                | 3    |
| `Param`                                  | 4    |
| `InterfaceImpl`                          | 5    |
| `MemberRef`                              | 6    |
| `Module`                                 | 7    |
| `Permission`                             | 8    |
| `Property`                               | 9    |
| `Event`                                  | 10   |
| `StandAloneSig`                          | 11   |
| `ModuleRef`                              | 12   |
| `TypeSpec`                               | 13   |
| `Assembly`                               | 14   |
| `AssemblyRef`                            | 15   |
| `File`                                   | 16   |
| `ExportedType`                           | 17   |
| `ManifestResource`                       | 18   |
| `GenericParam`                           | 19   |
| `GenericParamConstraint`                 | 20   |
| `MethodSpec`                             | 21   |

_[注意：_ _HasCustomAttributes_ 只有对应于用户源程序中的项目的表的值；例如，可以将属性附加到 _TypeDef_ 表和 _Field_ 表，但不能附加到 _ClassLayout_ 表。因此，上面的枚举中缺少一些表类型。结束注释]_

 HasFieldMarshall: 1 bit to encode tag | 标签
 `Field` | 0
 `Param` | 1

 | HasDeclSecurity: 2 bits to encode tag | 标签 |
 | ------------------------------------- | ---- |
 | `TypeDef`                             | 0    |
 | `MethodDef`                           | 1    |
 | `Assembly`                            | 2    |

 | MemberRefParent: 3 bits to encode tag | 标签 |
 | ------------------------------------- | ---- |
 | `TypeDef`                             | 0    |
 | `TypeRef`                             | 1    |
 | `ModuleRef`                           | 2    |
 | `MethodDef`                           | 3    |
 | `TypeSpec`                            | 4    |

 | HasSemantics: 1 bit to encode tag | 标签 |
 | --------------------------------- | ---- |
 | `Event`                           | 0    |
 | `Property`                        | 1    |

 | MethodDefOrRef: 1 bit to encode tag | 标签 |
 | ----------------------------------- | ---- |
 | `MethodDef`                         | 0    |
 | `MemberRef`                         | 1    |

 | MemberForwarded: 1 bit to encode tag | 标签 |
 | ------------------------------------ | ---- |
 | `Field`                              | 0    |
 | `MethodDef`                          | 1    |

 | Implementation: 2 bits to encode tag | 标签 |
 | ------------------------------------ | ---- |
 | `File`                               | 0    |
 | `AssemblyRef`                        | 1    |
 | `ExportedType`                       | 2    |

 | CustomAttributeType: 3 bits to encode tag | 标签 |
 | ----------------------------------------- | ---- |
 | Not used                                  | 0    |
 | Not used                                  | 1    |
 | `MethodDef`                               | 2    |
 | `MemberRef`                               | 3    |
 | Not used                                  | 4    |

 | ResolutionScope: 2 bits to encode tag | 标签 |
 | ------------------------------------- | ---- |
 | `Module`                              | 0    |
 | `ModuleRef`                           | 1    |
 | `AssemblyRef`                         | 2    |
 | `TypeRef`                             | 3    |

 | TypeOrMethodDef: 1 bit to encode tag | 标签 |
 | ------------------------------------ | ---- |
 | `TypeDef`                            | 0    |
 | `MethodDef`                          | 1    |

源: 与必应的对话， 2023/12/25
(1) github.com. https://github.com/stakx/ecma-335/tree/68d5015b146d347b2d76bd67d150af5f3fa68178/docs%2Fii.24.2.6-metadata-stream.md.




## 23. PE文件格式的扩展

> _这只包含信息性文本。_

CLI组件的文件格式是当前可移植可执行 (PE) 文件格式的严格扩展。这种扩展的PE格式使操作系统能够识别运行时图像，适应以CIL或本地代码发出的代码，并将运行时元数据作为发出的代码的组成部分。还有一些关于完整的Windows PE/COFF文件格式子集的规范，详细到工具或编译器可以使用这些规范来发出有效的CLI图像。

PE格式经常使用RVA (相对虚拟地址) 这个术语。RVA是一个项目*一旦加载到内存中*的地址，从中减去了图像文件的基地址 (即，从文件加载的基地址开始的偏移)。一个项目的RVA几乎总是与其在磁盘上的文件位置不同。要计算具有RVA *r*的项目的文件位置，搜索PE文件中的所有部分，找到RVA *s*，长度 *l* 和文件位置 *p* 的部分，其中RVA位于，即 *s* &le; *r* < *s*+*l*。然后，该项目的文件位置由 *p*+(*r*-*s*)给出。

除非另有说明，否则所有二进制值都以小端格式存储。

> _结束信息性文本。_

### 23.1. 运行时文件格式的结构

下图提供了 CLI 文件格式的高级视图。所有运行时图像都包含以下内容：

 * PE 头，其中包含如何在运行时文件中设置字段值的具体指南。

 * 一个 CLI 头，其中包含所有特定于运行时的数据条目。运行时头是只读的，应放置在任何只读部分中。

 * 包含头描述的实际数据的部分，包括导入/导出、数据和代码。

 ![CLI 文件格式的高级视图](ii.25.1-structure-of-the-runtime-file-format-figure-1.png)

使用 PE 头中的 CLI 头目录条目找到 CLI 头 (§[II.25.3.3](ii.25.3.3-cli-header.md))。CLI 头反过来包含了图像其余部分的运行时数据的地址和大小 (对于元数据，参见 §[II.24](ii.24-metadata-physical-layout.md)；对于 CIL，参见 §[II.25.4](ii.25.4-common-intermediate-language-physical-layout.md))。请注意，基于部分的属性 (如只读与执行等)，运行时数据可以与 PE 格式的其他数据合并到 PE 格式的其他区域中。

### 23.2. PE 头

PE 图像以 MS-DOS 头开始，接着是 PE 签名，然后是 PE 文件头，然后是 PE 可选头，最后是 PE 节头。

#### 23.2.1. MS-DOS 头

PE 格式以一个 MS-DOS 存根开始，精确地放置在模块的前面的 128 字节。在 DOS 头的偏移 0x3c 处是一个 4 字节的无符号整数偏移，_lfanew_，指向 PE 签名 (应为 "`PE\0\0`")，紧接着是 PE 文件头。

| &nbsp; | &nbsp; | &nbsp; | &nbsp; | &nbsp;   | &nbsp; | &nbsp; | &nbsp; |
| ------ | ------ | ------ | ------ | -------- | ------ | ------ | ------ |
| 0x4d   | 0x5a   | 0x90   | 0x00   | 0x03     | 0x00   | 0x00   | 0x00   |
| 0x04   | 0x00   | 0x00   | 0x00   | 0xFF     | 0xFF   | 0x00   | 0x00   |
| 0xb8   | 0x00   | 0x00   | 0x00   | 0x00     | 0x00   | 0x00   | 0x00   |
| 0x40   | 0x00   | 0x00   | 0x00   | 0x00     | 0x00   | 0x00   | 0x00   |
| 0x00   | 0x00   | 0x00   | 0x00   | 0x00     | 0x00   | 0x00   | 0x00   |
| 0x00   | 0x00   | 0x00   | 0x00   | 0x00     | 0x00   | 0x00   | 0x00   |
| 0x00   | 0x00   | 0x00   | 0x00   | 0x00     | 0x00   | 0x00   | 0x00   |
| 0x00   | 0x00   | 0x00   | 0x00   | _lfanew_ | &nbsp; | &nbsp; | &nbsp; |
| 0x0e   | 0x1f   | 0xba   | 0x0e   | 0x00     | 0xb4   | 0x09   | 0xcd   |
| 0x21   | 0xb8   | 0x01   | 0x4c   | 0xcd     | 0x21   | 0x54   | 0x68   |
| 0x69   | 0x73   | 0x20   | 0x70   | 0x72     | 0x6f   | 0x67   | 0x72   |
| 0x61   | 0x6d   | 0x20   | 0x63   | 0x61     | 0x6e   | 0x6e   | 0x6f   |
| 0x74   | 0x20   | 0x62   | 0x65   | 0x20     | 0x72   | 0x75   | 0x6e   |
| 0x20   | 0x69   | 0x6e   | 0x20   | 0x44     | 0x4f   | 0x53   | 0x20   |
| 0x6d   | 0x6f   | 0x64   | 0x65   | 0x2e     | 0x0d   | 0x0d   | 0x0a   |
| 0x24   | 0x00   | 0x00   | 0x00   | 0x00     | 0x00   | 0x00   | 0x00   |

#### 23.2.2. PE文件头

在PE签名之后紧接着是PE文件头，包括以下内容：

 | 偏移 | 大小 | 字段                    | 描述                                                                       |
 | ---- | ---- | ----------------------- | -------------------------------------------------------------------------- |
 | 0    | 2    | Machine                 | 总是0x14c。                                                                |
 | 2    | 2    | Number of Sections      | 节的数量；表示紧接在头部之后的节表的大小。                                 |
 | 4    | 4    | Time/Date Stamp         | 文件创建的时间和日期，以1970年1月1日00:00:00以来的秒数表示，或为0。        |
 | 8    | 4    | Pointer to Symbol Table | 总是0 (§[II.24.1](ii.24.1-fixed-fields.md))。                              |
 | 12   | 4    | Number of Symbols       | 总是0 (§[II.24.1](ii.24.1-fixed-fields.md))。                              |
 | 16   | 2    | Optional Header Size    | 可选头的大小，格式在下面描述。                                             |
 | 18   | 2    | Characteristics         | 标志，表示文件的属性，参见§[II.25.2.2.1](ii.25.2.2.1-characteristics.md)。 |

##### 23.2.2.1. 特性

一个仅 CIL 的 DLL 将标志 0x2000 设置为 1，而一个仅 CIL 的 `.exe` 将标志 0x2000 设置为零：

 | 标志                          | 值     | 描述                                                                   |
 | ----------------------------- | ------ | ---------------------------------------------------------------------- |
 | `IMAGE_FILE_RELOCS_STRIPPED`  | 0x0001 | 应为零                                                                 |
 | `IMAGE_FILE_EXECUTABLE_IMAGE` | 0x0002 | 应为一                                                                 |
 | `IMAGE_FILE_32BIT_MACHINE`    | 0x0100 | 当且仅当 `COMIMAGE_FLAGS_32BITREQUIRED` 为一时，应为一 (§[25.3.3.1]()) |
 | `IMAGE_FILE_DLL`              | 0x2000 | 图像文件是一个动态链接库 (DLL)。                                       |

对于上述未提到的标志，标志 0x0010，0x0020，0x0400 和 0x0800 是实现特定的，所有其他的应该为零 (§[II.24.1](ii.24.1-fixed-fields.md))。


#### 23.2.3. PE 可选头

紧接着 PE 头是 PE 可选头。此头包含以下信息：

 | 偏移 | 大小 | 头部分      | 描述                                                                                                                  |
 | ---- | ---- | ----------- | --------------------------------------------------------------------------------------------------------------------- |
 | 0    | 28   | 标准字段    | 这些定义了 PE 文件的一般属性，参见 §[II.25.2.3.1](ii.25.2.3.1-pe-header-standard-fields.md)。                         |
 | 28   | 68   | NT 特定字段 | 这些包括支持 Windows 的特定功能的附加字段，参见 §[II.25.2.3.2](ii.25.2.3.2-pe-header-windows-nt-specific-fields.md)。 |
 | 96   | 128  | 数据目录    | 这些字段是地址/大小对，用于在图像文件中找到的特殊表 (例如，导入表和导出表)。                                          |

##### 23.2.3.1. PE 头标准字段

所有 PE 文件都需要这些字段，并包含以下信息：

 | 偏移 | 大小 | 字段                    | 描述                                                                                              |
 | ---- | ---- | ----------------------- | ------------------------------------------------------------------------------------------------- |
 | 0    | 2    | Magic                   | 始终为 0x10B。                                                                                    |
 | 2    | 1    | LMajor                  | 始终为 6 (§[II.24.1](ii.24.1-fixed-fields.md))。                                                  |
 | 3    | 1    | LMinor                  | 始终为 0 (§[II.24.1](ii.24.1-fixed-fields.md))。                                                  |
 | 4    | 4    | Code Size               | 代码 (文本) 部分的大小，或者如果有多个部分，则为所有代码部分的总和。                              |
 | 8    | 4    | Initialized Data Size   | 初始化数据部分的大小，或者如果有多个数据部分，则为所有这些部分的总和。                            |
 | 12   | 4    | Uninitialized Data Size | 未初始化数据部分的大小，或者如果有多个未初始化的数据部分，则为所有这些部分的总和。                |
 | 16   | 4    | Entry Point RVA         | 入口点 RVA，需要指向字节 0xFF 0x25，后面跟着在标记为执行/读取的部分中的 RVA，对于 EXE 或 DLL 为 0 |
 | 20   | 4    | Base Of Code            | 代码部分的 RVA。 (这是对加载器的提示。)                                                           |
 | 24   | 4    | Base Of Data            | 数据部分的 RVA。 (这是对加载器的提示。)                                                           |

> _这只包含信息性文本。_

入口点 RVA 应始终是 x86 入口点存根或 0。在非 CLI 知道的平台上，此存根将调用 `mscoree` 的入口点 API (`_CorExeMain` 或 `_CorDllMain`)。`mscoree` 入口点将使用模块句柄从图像加载元数据，并调用 CLI 头中指定的入口点。

> _结束信息性文本。_

##### 23.2.3.2. PE头部 Windows NT特定字段

这些字段是Windows NT特定的：

 | 偏移量 | 大小 | 字段                       | 描述                                                                                                     |
 | ------ | ---- | -------------------------- | -------------------------------------------------------------------------------------------------------- |
 | 28     | 4    | Image Base                 | 应为0x10000的倍数。                                                                                      |
 | 32     | 4    | Section Alignment          | 应大于File Alignment。                                                                                   |
 | 36     | 4    | File Alignment             | 应为0x200 (§[II.24.1](ii.24.1-fixed-fields.md))。                                                        |
 | 40     | 2    | OS Major                   | 应为5 (§[II.24.1](ii.24.1-fixed-fields.md))。                                                            |
 | 42     | 2    | OS Minor                   | 应为0 (§[II.24.1](ii.24.1-fixed-fields.md))。                                                            |
 | 44     | 2    | User Major                 | 应为0 (§[II.24.1](ii.24.1-fixed-fields.md))。                                                            |
 | 46     | 2    | User Minor                 | 应为0 (§[II.24.1](ii.24.1-fixed-fields.md))。                                                            |
 | 48     | 2    | SubSys Major               | 应为5 (§[II.24.1](ii.24.1-fixed-fields.md))。                                                            |
 | 50     | 2    | SubSys Minor               | 应为0 (§[II.24.1](ii.24.1-fixed-fields.md))。                                                            |
 | 52     | 4    | Reserved                   | 应为零                                                                                                   |
 | 56     | 4    | Image Size                 | 图像的字节大小，包括所有头和填充；应为Section Alignment的倍数。                                          |
 | 60     | 4    | Header Size                | MS-DOS头、PE头、PE可选头和填充的组合大小；应为文件对齐的倍数。                                           |
 | 64     | 4    | File Checksum              | 应为0 (§[II.24.1](ii.24.1-fixed-fields.md))。                                                            |
 | 68     | 2    | SubSystem                  | 运行此图像所需的子系统。应为`IMAGE_SUBSYSTEM_WINDOWS_CUI` (0x3) 或 `IMAGE_SUBSYSTEM_WINDOWS_GUI` (0x2)。 |
 | 70     | 2    | DLL Flags                  | 位0x100f应为零。                                                                                         |
 | 72     | 4    | Stack Reserve Size         | 应为0x100000 (1Mb) (§[II.24.1](ii.24.1-fixed-fields.md))。                                               |
 | 76     | 4    | Stack Commit Size          | 应为0x1000 (4Kb) (§[II.24.1](ii.24.1-fixed-fields.md))。                                                 |
 | 80     | 4    | Heap Reserve Size          | 应为0x100000 (1Mb) (§[II.24.1](ii.24.1-fixed-fields.md))。                                               |
 | 84     | 4    | Heap Commit Size           | 应为0x1000 (4Kb) (§[II.24.1](ii.24.1-fixed-fields.md))。                                                 |
 | 88     | 4    | Loader Flags               | 应为0                                                                                                    |
 | 92     | 4    | Number of Data Directories | 应为0x10                                                                                                 |


##### 23.2.3.3. PE 头数据目录

可选的头数据目录给出了在 PE 文件的各个部分中出现的几个表的地址和大小。每个数据目录条目按顺序包含它所描述的结构的 RVA 和大小。

 | 偏移量 | 大小 | 字段           | 描述                                                                                                  |
 | ------ | ---- | -------------- | ----------------------------------------------------------------------------------------------------- |
 | 96     | 8    | 导出表         | 始终为0 (§[II.24.1](ii.24.1-fixed-fields.md))。                                                       |
 | 104    | 8    | 导入表         | 导入表的 RVA 和大小，(§[II.25.3.1](ii.25.3.1-import-table-and-import-address-table-iat.md))。         |
 | 112    | 8    | 资源表         | 始终为0 (§[II.24.1](ii.24.1-fixed-fields.md))。                                                       |
 | 120    | 8    | 异常表         | 始终为0 (§[II.24.1](ii.24.1-fixed-fields.md))。                                                       |
 | 128    | 8    | 证书表         | 始终为0 (§[II.24.1](ii.24.1-fixed-fields.md))。                                                       |
 | 136    | 8    | 基址重定位表   | 重定位表；如果未使用则设置为0 (§)。                                                                   |
 | 144    | 8    | 调试           | 始终为0 (§[II.24.1](ii.24.1-fixed-fields.md))。                                                       |
 | 152    | 8    | 版权           | 始终为0 (§[II.24.1](ii.24.1-fixed-fields.md))。                                                       |
 | 160    | 8    | 全局指针       | 始终为0 (§[II.24.1](ii.24.1-fixed-fields.md))。                                                       |
 | 168    | 8    | TLS 表         | 始终为0 (§[II.24.1](ii.24.1-fixed-fields.md))。                                                       |
 | 176    | 8    | 加载配置表     | 始终为0 (§[II.24.1](ii.24.1-fixed-fields.md))。                                                       |
 | 184    | 8    | 绑定导入       | 始终为0 (§[II.24.1](ii.24.1-fixed-fields.md))。                                                       |
 | 192    | 8    | IAT            | 导入地址表的 RVA 和大小，(§[II.25.3.1](ii.25.3.1-import-table-and-import-address-table-iat.md))。     |
 | 200    | 8    | 延迟导入描述符 | 始终为0 (§[II.24.1](ii.24.1-fixed-fields.md))。                                                       |
 | 208    | 8    | CLI 头         | 带有运行时数据目录的 CLI 头，(§[II.25.3.1](ii.25.3.1-import-table-and-import-address-table-iat.md))。 |
 | 216    | 8    | 保留           | 始终为0 (§[II.24.1](ii.24.1-fixed-fields.md))。                                                       |

由目录条目指向的表存储在 PE 文件的一个部分中；这些部分本身由部分头描述。



### 23.3. 节头

紧接在可选头之后的是节表，其中包含了许多节头。这种位置是必需的，因为文件头并未包含指向节表的直接指针；节表的位置是通过计算头部后的第一个字节的位置来确定的。

每个节头都有以下格式，每个条目总共40字节：

 | 偏移量 | 大小 | 字段                 | 描述                                                                                                                                                                                                                                                          |
 | ------ | ---- | -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
 | 0      | 8    | Name                 | 一个8字节，空值填充的ASCII字符串。如果字符串正好是八个字符长，那么就没有终止空值。                                                                                                                                                                            |
 | 8      | 4    | VirtualSize          | 节的总字节大小。如果此值大于SizeOfRawData，节将被零填充。                                                                                                                                                                                                     |
 | 12     | 4    | VirtualAddress       | 对于可执行图像，这是加载到内存中的节的第一个字节的地址，相对于图像基址。                                                                                                                                                                                      |
 | 16     | 4    | SizeOfRawData        | 磁盘上初始化数据的大小，以字节为单位，应为PE头中的FileAlignment的倍数。如果这个值小于VirtualSize，那么节的剩余部分将被零填充。因为这个字段是四舍五入的，而VirtualSize字段不是，所以这个值可能大于VirtualSize。当一个节只包含未初始化的数据时，这个字段应为0。 |
 | 20     | 4    | PointerToRawData     | PE文件中节的第一页的偏移量。这应该是可选头中的FileAlignment的倍数。当一个节只包含未初始化的数据时，这个字段应为0。                                                                                                                                            |
 | 24     | 4    | PointerToRelocations | 应为0 (§[II.24.1](ii.24.1-fixed-fields.md))。                                                                                                                                                                                                                 |
 | 28     | 4    | PointerToLinenumbers | 应为0 (§[II.24.1](ii.24.1-fixed-fields.md))。                                                                                                                                                                                                                 |
 | 32     | 2    | NumberOfRelocations  | 应为0 (§[II.24.1](ii.24.1-fixed-fields.md))。                                                                                                                                                                                                                 |
 | 34     | 2    | NumberOfLinenumbers  | 应为0 (§[II.24.1](ii.24.1-fixed-fields.md))。                                                                                                                                                                                                                 |
 | 36     | 4    | Characteristics      | 描述节特性的标志；见下文。                                                                                                                                                                                                                                    |

下表定义了节可能的特性。

 | 标志                               | 值         | 描述                   |
 | ---------------------------------- | ---------- | ---------------------- |
 | `IMAGE_SCN_CNT_CODE`               | 0x00000020 | 节包含代码。           |
 | `IMAGE_SCN_CNT_INITIALIZED_DATA`   | 0x00000040 | 节包含初始化的数据。   |
 | `IMAGE_SCN_CNT_UNINITIALIZED_DATA` | 0x00000080 | 节包含未初始化的数据。 |
 | `IMAGE_SCN_MEM_EXECUTE`            | 0x20000000 | 节可以作为代码执行。   |
 | `IMAGE_SCN_MEM_READ`               | 0x40000000 | 节可以被读取。         |
 | `IMAGE_SCN_MEM_WRITE`              | 0x80000000 | 节可以被写入。         |

#### 23.3.1. 导入表和导入地址表 (IAT)

导入表和导入地址表 (IAT) 用于导入运行时引擎 (`mscoree.dll`) 的 `_CorExeMain` (对于 `.exe`) 或 `_CorDllMain` (对于 `.dll`) 条目。导入表目录条目指向一个元素零终止的导入目录条目数组 (在一般的 PE 文件中，每个导入的 DLL 有一个条目) ：

 | 偏移 | 大小 | 字段               | 描述                                                      |
 | ---- | ---- | ------------------ | --------------------------------------------------------- |
 | 0    | 4    | ImportLookupTable  | 导入查找表的 RVA                                          |
 | 4    | 4    | DateTimeStamp      | 始终为 0 (§[II.24.1](ii.24.1-fixed-fields.md))。          |
 | 8    | 4    | ForwarderChain     | 始终为 0 (§[II.24.1](ii.24.1-fixed-fields.md))。          |
 | 12   | 4    | Name               | 空终止 ASCII 字符串 "`mscoree.dll`" 的 RVA。              |
 | 16   | 4    | ImportAddressTable | 导入地址表的 RVA (这与可选头中的 IAT 描述符的 RVA 相同)。 |
 | 20   | 20   | &nbsp;             | 导入表的结束。应填充为零。                                |

导入查找表和导入地址表 (IAT) 都是一个元素，零终止的 RVA 数组，指向 Hint/Name 表。RVA 的第 31 位应设置为 0。在一般的 PE 文件中，此表中每个导入的符号有一个条目。

 | 偏移 | 大小 | 字段                | 描述                                                                |
 | ---- | ---- | ------------------- | ------------------------------------------------------------------- |
 | 0    | 4    | Hint/Name Table RVA | 指向 Hint/Name 表的 31 位 RVA。第 31 位应设置为 0，表示按名称导入。 |
 | 4    | 4    | &nbsp;              | 表的结束，应填充为零。                                              |

IAT 应位于可执行和可写的部分，因为加载器将用导入符号的实际入口点替换指向 Hint/Name 表的指针。

Hint/Name 表包含导入的 dll-entry 的名称。

 | 偏移 | 大小 | 字段 | 描述                                                                                                                                |
 | ---- | ---- | ---- | ----------------------------------------------------------------------------------------------------------------------------------- |
 | 0    | 2    | Hint | 应为 0。                                                                                                                            |
 | 2    | 变量 | Name | 包含要导入的名称的区分大小写的空终止 ASCII 字符串。对于 `.exe` 文件，应为 "`_CorExeMain`"，对于 `.dll` 文件，应为 "`_CorDllMain`"。 |

#### 23.3.2. 重定位

在纯 CIL 图像中，需要一个类型为 `IMAGE_REL_BASED_HIGHLOW` (0x3) 的修复，用于访问 IAT 加载运行时引擎的 x86 启动存根。当构建混合的 CIL/本机图像或者当图像包含用户数据中的嵌入式 RVA 时，重定位部分也包含这些重定位。

重定位应该在它们自己的部分中，名为 "`.reloc`"，这应该是 PE 文件中的最后一个部分。重定位部分包含一个修复表。修复表被分解成多个修复块。每个块代表一个 4K 页面的修复，每个块应该从 32 位边界开始。

每个修复块开始于以下结构：

 | 偏移量 | 大小 | 字段       | 描述                                                                                                             |
 | ------ | ---- | ---------- | ---------------------------------------------------------------------------------------------------------------- |
 | 0      | 4    | PageRVA    | 需要应用修复的块的 RVA。低 12 位应为零。                                                                         |
 | 4      | 4    | Block Size | 修复块中的总字节数，包括 Page RVA 和 Block Size 字段，以及后面的 Type/Offset 字段，向上取整到最接近的 4 的倍数。 |

然后，Block Size 字段后面跟着 (BlockSize - 8)/2 Type/Offset。每个条目是一个字 (2 字节)，并具有以下结构 (如果需要，插入 2 字节的 0 以填充到 4 字节的长度的倍数) ：

 | 偏移量 | 大小    | 字段   | 描述                                                                                                 |
 | ------ | ------- | ------ | ---------------------------------------------------------------------------------------------------- |
 | 0      | 4 bits  | Type   | 存储在字的高 4 位。值表示要应用哪种类型的修复 (如上所述)                                             |
 | 0      | 12 bits | Offset | 存储在字的剩余 12 位。从块的 Page RVA 字段指定的起始地址的偏移量。此偏移量指定了修复应该应用的位置。 |

#### 23.3.3. CLI 头

CLI 头包含所有特定于运行时的数据条目和其他信息。头应放置在图像的只读、可共享的部分。此头定义如下：

 | 偏移 | 大小 | 字段                    | 描述                                                                      |
 | ---- | ---- | ----------------------- | ------------------------------------------------------------------------- |
 | 0    | 4    | Cb                      | 头的字节大小                                                              |
 | 4    | 2    | MajorRuntimeVersion     | 运行此程序所需的运行时的最小版本，当前为 2。                              |
 | 6    | 2    | MinorRuntimeVersion     | 版本的次要部分，当前为 0。                                                |
 | 8    | 8    | MetaData                | 物理元数据的 RVA 和大小 (§[II.24](ii.24-metadata-physical-layout.md))。   |
 | 16   | 4    | Flags                   | 描述此运行时图像的标志。(§[II.25.3.3.1](ii.25.3.3.1-runtime-flags.md))。  |
 | 20   | 4    | EntryPointToken         | 图像入口点的 _MethodDef_ 或 _File_ 的 _token_                             |
 | 24   | 8    | Resources               | 实现特定资源的 RVA 和大小。                                               |
 | 32   | 8    | StrongNameSignature     | 此 PE 文件的哈希数据的 RVA，由 CLI 加载器用于绑定和版本控制               |
 | 40   | 8    | CodeManagerTable        | 始终为 0 (§[II.24.1](ii.24.1-fixed-fields.md))。                          |
 | 48   | 8    | VTableFixups            | 文件中包含函数指针数组 (例如，vtable 插槽) 的位置的数组的 RVA，参见下文。 |
 | 56   | 8    | ExportAddressTableJumps | 始终为 0 (§[II.24.1](ii.24.1-fixed-fields.md))。                          |
 | 64   | 8    | ManagedNativeHeader     | 始终为 0 (§[II.24.1](ii.24.1-fixed-fields.md))。                          |

##### 23.3.3.1. 运行时标志

以下标志描述了此运行时图像，并被加载器使用。所有未指定的位应为零。

 | 标志                               | 值         | 描述                                                                                                                                                           |
 | ---------------------------------- | ---------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |
 | `COMIMAGE_FLAGS_ILONLY`            | 0x00000001 | 应为1。                                                                                                                                                        |
 | `COMIMAGE_FLAGS_32BITREQUIRED`     | 0x00000002 | 图像只能加载到32位进程中，例如，如果有32位的vtablefixups，或者从`native integer`到`int32`的转换。具有64位本地整数的CLI实现应拒绝加载设置了此标志的二进制文件。 |
 | `COMIMAGE_FLAGS_STRONGNAMESIGNED`  | 0x00000008 | 图像有强名称签名。                                                                                                                                             |
 | `COMIMAGE_FLAGS_NATIVE_ENTRYPOINT` | 0x00000010 | 应为0。                                                                                                                                                        |
 | `COMIMAGE_FLAGS_TRACKDEBUGDATA`    | 0x00010000 | 应为0 (§[II.24.1](ii.24.1-fixed-fields.md))。                                                                                                                  |

##### 23.3.3.2. 入口点元数据 _token_

 * 入口点 _token_  (§[II.15.4.1.2](ii.15.4.1.2-the-entrypoint-directive.md)) 在多模块程序集的入口点不在清单程序集中时，始终是 _MethodDef_  _token_  (§[II.22.26](ii.22.26-methoddef-0x06.md)) 或 _File_  _token_  (§[II.22.19](ii.22.19-file-0x26.md))。方法的元数据中的签名和实现标志指示如何运行入口。

##### 23.3.3.3. Vtable 修复

某些选择不遵循公共类型系统运行时模型的语言可以拥有需要在 v-table 中表示的虚函数。这些 v-table 是由编译器布局的，而不是由运行时布局的。找到正确的 v-table 插槽并通过该插槽中保存的值间接调用也是由编译器完成的。运行时头中的 **VtableFixups** 字段包含 Vtable 修复数组的位置和大小 (参见 §[II.15.5.1](ii.15.5.1-method-transition-thunks.md))。V-table 应该被发射到 PE 文件的 *读-写* 部分。

此数组中的每个条目描述了指定大小的 v-table 插槽的连续数组。每个插槽开始时都初始化为它们需要调用的方法的元数据 _token_ 值。在图像加载时，运行时加载器将每个条目转换为 CPU 的机器代码的指针，并可以直接调用。

 | 偏移量 | 大小 | 字段               | 描述                     |
 | ------ | ---- | ------------------ | ------------------------ |
 | 0      | 4    | **VirtualAddress** | Vtable 的 RVA            |
 | 4      | 2    | **Size**           | Vtable 中的条目数        |
 | 6      | 2    | **Type**           | 条目的类型，如下表所定义 |

 | 常量                           | 值   | 描述                                                 |
 | ------------------------------ | ---- | ---------------------------------------------------- |
 | `COR_VTABLE_32BIT`             | 0x01 | Vtable 插槽是 32 位的。                              |
 | `COR_VTABLE_64BIT`             | 0x02 | Vtable 插槽是 64 位的。                              |
 | `COR_VTABLE_FROM_UNMANAGED`    | 0x04 | 从非托管代码转换到托管代码。                         |
 | `COR_VTABLE_CALL_MOST_DERIVED` | 0x10 | 调用由 _token_ 描述的最派生的方法 (仅对虚方法有效)。 |

##### 23.3.3.4. 强名称签名

此头部条目指向一个图像的强名称哈希，可以用来确定性地从引用点 (§[II.6.2.1.3](ii.6.2.1.3-originators-public-key.md)) 识别一个模块。

### 23.4. CIL 物理布局
<a id="CIL-physical-layout"></a>

本节包含用于描述 CIL 方法及其异常的数据结构的布局。方法体可以存储在 PE 文件的任何只读部分。元数据中的 _MethodDef_ 记录 (§[II.22.26](ii.22.26-methoddef-0x06.md)) 携带每个方法的 RVA。

一个方法由方法头紧接着方法体组成，可能后面还跟着额外的方法数据部分 (§[II.25.4.5](ii.25.4.5-method-data-section.md))，通常是异常处理数据。如果存在异常处理数据，那么 `CorILMethod_MoreSects` 标志 (§[II.25.4.4](ii.25.4.4-flags-for-method-headers.md)) 应在方法头和之后的每个链式项中指定。

方法头有两种形式 &ndash; tiny (§[II.25.4.2](ii.25.4.2-tiny-format.md)) 和 fat (§[II.25.4.3](ii.25.4.3-fat-format.md))。方法头中的两个最低有效位指示哪种类型存在 (§[II.25.4.1](ii.25.4.1-method-header-type-values.md))。tiny 头长 1 字节，只存储方法的代码大小。如果一个方法没有局部变量，maxstack 是 8 或更小，方法没有异常，方法大小小于 64 字节，并且方法没有高于 0x7 的标志，那么该方法将被赋予一个 tiny 头。fat 头携带完整信息 &ndash; 局部变量签名 _token_ ，maxstack，代码大小，标志。tiny 方法头可以开始于任何字节边界。fat 方法头应开始于 4 字节边界。

#### 23.4.1. 方法头类型值

方法头的第一个字节的最低有效位表示存在哪种类型的头。这两位将且只能是以下的一种：

 | 值                       | 值  | 描述                                                      |
 | ------------------------ | --- | --------------------------------------------------------- |
 | `CorILMethod_TinyFormat` | 0x2 | 方法头是小型的 (§[II.25.4.2](ii.25.4.2-tiny-format.md))。 |
 | `CorILMethod_FatFormat`  | 0x3 | 方法头是大型的 (§[II.25.4.3](ii.25.4.3-fat-format.md))。  |

#### 23.4.2. Tiny 格式

Tiny 头使用 6 位长度编码。以下是所有 tiny 头的特性：

 * 不允许有局部变量

 * 没有异常

 * 没有额外的数据部分

 * 操作数栈的大小不得超过 8 个条目

Tiny 格式头的编码如下：

 | 起始位 | 位数 | 描述                                                                                               |
 | ------ | ---- | -------------------------------------------------------------------------------------------------- |
 | 0      | 2    | 标志 (应设置 `CorILMethod_TinyFormat`，参见 §[II.25.4.4](ii.25.4.4-flags-for-method-headers.md))。 |
 | 2      | 6    | 紧随此头之后的方法体的字节大小。                                                                   |

#### 23.4.3. Fat格式

当Tiny格式不足以满足需求时，就会使用Fat格式。这可能是由于以下一个或多个原因：

 * 方法过大，无法编码大小 (即，至少64字节)

 * 存在异常

 * 存在额外的数据段

 * 存在局部变量

 * 操作数栈需要超过8个条目

Fat头部具有以下结构

 | 偏移量  | 大小    | 字段               | 描述                                                                                                   |
 | ------- | ------- | ------------------ | ------------------------------------------------------------------------------------------------------ |
 | 0       | 12 (位) | **Flags**          | 标志 (`CorILMethod_FatFormat`应在位0:1中设置，参见§[II.25.4.4](ii.25.4.4-flags-for-method-headers.md)) |
 | 12 (位) | 4 (位)  | **Size**           | 以占用的4字节整数的计数表示此头部的大小 (当前为3)                                                      |
 | 2       | 2       | **MaxStack**       | 操作数栈上的最大项数                                                                                   |
 | 4       | 4       | **CodeSize**       | 实际方法体的字节大小                                                                                   |
 | 8       | 4       | **LocalVarSigTok** | 描述方法的局部变量布局的签名的元数据 _token_ 。0表示没有局部变量存在                                   |

#### 23.4.4. 方法头的标志
<a id="method-header"></a>

方法头的第一个字节也可以包含以下仅对Fat格式有效的标志，这些标志指示如何执行该方法：

 | 标志                     | 值   | 描述                                                                      |
 | ------------------------ | ---- | ------------------------------------------------------------------------- |
 | `CorILMethod_FatFormat`  | 0x3  | 方法头是fat。                                                             |
 | `CorILMethod_TinyFormat` | 0x2  | 方法头是tiny。                                                            |
 | `CorILMethod_MoreSects`  | 0x8  | 在此头后面有更多的部分 (§[II.25.4.5](ii.25.4.5-method-data-section.md))。 |
 | `CorILMethod_InitLocals` | 0x10 | 在所有局部变量上调用默认构造函数。                                        |

#### 23.4.5. 方法数据部分

在方法体之后的下一个 4 字节边界处可以有额外的方法数据部分。这些方法数据部分以两字节头开始 (1 字节用于标志，1 字节用于实际数据的长度) 或 4 字节头 (1 字节用于标志，3 字节用于实际数据的长度)。第一个字节确定头的种类，以及实际部分中的数据是什么：

 | 标志                          | 值   | 描述                                                                                                      |
 | ----------------------------- | ---- | --------------------------------------------------------------------------------------------------------- |
 | `CorILMethod_Sect_EHTable`    | 0x1  | 异常处理数据。                                                                                            |
 | `CorILMethod_Sect_OptILTable` | 0x2  | 保留，应为 0。                                                                                            |
 | `CorILMethod_Sect_FatFormat`  | 0x40 | 数据格式是 fat 类型，意味着有一个 3 字节长度的最低有效字节优先格式。如果未设置，头部是小的，长度为 1 字节 |
 | `CorILMethod_Sect_MoreSects`  | 0x80 | 在此当前部分之后还有另一个数据部分                                                                        |

目前，方法数据部分仅用于异常表 (参见 §[II.19](ii.19-exception-handling.md))。小异常头结构的布局如下：

 | 偏移量 | 大小 | 字段         | 描述                                                                            |
 | ------ | ---- | ------------ | ------------------------------------------------------------------------------- |
 | 0      | 1    | **Kind**     | 如上所述的标志。                                                                |
 | 1      | 1    | **DataSize** | 块的数据大小，包括头部，比如说 *n*\*12+4。                                      |
 | 2      | 2    | **Reserved** | 填充，始终为 0。                                                                |
 | 4      | *n*  | **Clauses**  | *n* 个小异常子句 (参见 §[II.25.4.6](ii.25.4.6-exception-handling-clauses.md))。 |

fat 异常头结构的布局如下：

 | 偏移量 | 大小 | 字段         | 描述                                                                               |
 | ------ | ---- | ------------ | ---------------------------------------------------------------------------------- |
 | 0      | 1    | **Kind**     | 使用的是哪种类型的异常块                                                           |
 | 1      | 3    | **DataSize** | 块的数据大小，包括头部，比如说 *n*\*24+4。                                         |
 | 4      | *n*  | **Clauses**  | *n* 个 fat 异常子句 (参见 §[II.25.4.6](ii.25.4.6-exception-handling-clauses.md))。 |

#### 23.4.6. 异常处理条款

异常处理条款也有小型和大型两种版本。

当try块和处理程序代码的大小都小于256字节，且它们的偏移量都小于65536时，应使用小型异常条款。小型异常条款的格式如下：

 | 偏移量 | 大小 | 字段              | 描述                                       |
 | ------ | ---- | ----------------- | ------------------------------------------ |
 | 0      | 2    | **Flags**         | 标志，见下文。                             |
 | 2      | 2    | **TryOffset**     | 从方法体开始的try块的字节偏移量。          |
 | 4      | 1    | **TryLength**     | try块的字节长度                            |
 | 5      | 2    | **HandlerOffset** | 此try块的处理程序的位置                    |
 | 7      | 1    | **HandlerLength** | 处理程序代码的字节大小                     |
 | 8      | 4    | **ClassToken**    | 基于类型的异常处理程序的元数据 _token_     |
 | 8      | 4    | **FilterOffset**  | 基于过滤器的异常处理程序在方法体中的偏移量 |

大型异常处理条款的布局如下：

 | 偏移量 | 大小 | 字段              | 描述                                       |
 | ------ | ---- | ----------------- | ------------------------------------------ |
 | 0      | 4    | **Flags**         | 标志，见下文。                             |
 | 4      | 4    | **TryOffset**     | 从方法体开始的try块的字节偏移量。          |
 | 8      | 4    | **TryLength**     | try块的字节长度                            |
 | 12     | 4    | **HandlerOffset** | 此try块的处理程序的位置                    |
 | 16     | 4    | **HandlerLength** | 处理程序代码的字节大小                     |
 | 20     | 4    | **ClassToken**    | 基于类型的异常处理程序的元数据 _token_     |
 | 20     | 4    | **FilterOffset**  | 基于过滤器的异常处理程序在方法体中的偏移量 |

每个异常处理条款使用以下标志值：

 | 标志                               | 值     | 描述                                |
 | ---------------------------------- | ------ | ----------------------------------- |
 | `COR_ILEXCEPTION_CLAUSE_EXCEPTION` | 0x0000 | 类型化的异常条款                    |
 | `COR_ILEXCEPTION_CLAUSE_FILTER`    | 0x0001 | 异常过滤器和处理程序条款            |
 | `COR_ILEXCEPTION_CLAUSE_FINALLY`   | 0x0002 | 最终条款                            |
 | `COR_ILEXCEPTION_CLAUSE_FAULT`     | 0x0004 | 错误条款 (只在异常时调用的最终条款) |


---

