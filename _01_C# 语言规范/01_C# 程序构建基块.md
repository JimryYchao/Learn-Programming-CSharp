## C# 程序构建基块


---
### C# 与 .NET

C# 源于 C 语言系列，是一种面向对象的、面向组件的、类型安全的新式编程语言。C# 程序在 .NET 上运行，.NET 是名为公共语言运行时（Common Language Runtime，CLR）的虚拟执行系统和一组类库。CLR 是 Microsoft 对公共语言基础结构（CLI）国际标准的实现。CLI 是创建执行和开发环境的基础，语言和库可以在其中无缝地协同工作。

C# 源代码被编译成符合 CLI 规范的中间语言（IL）。IL 代码和资源存储在 `*.dll` 程序集中。程序集包含一个介绍程序集类型、版本和区域性的清单。

执行 C# 程序时，程序集将加载到 CLR。CLR 会直接执行 JIT 即时编译，将 IL 代码转换成本机指令。CLR 提供自动垃圾回收、异常处理和资源管理相关的服务。CLR 执行的代码有时称为 ***托管代码***（*managed code*），***非托管代码***（*unmanaged code*）被编译成面向特定平台的本机语言（*native code*）。

语言互操作性是 .NET 的一项重要功能。C# 编译器生成的 IL 代码符合公共类型规范（CTS）。通过 C# 生成的 IL 代码可以与通过 .NET 版本的 F#、Visual Basic、C++ 生成的代码进行交互。还有 20 多种与 CTS 兼容的语言。单个程序集可包含多个用不同 .NET 语言编写的模块。这些类型可以相互引用，就像它们是用同一种语言编写的一样。

---
### 程序结构

C# 中的组织结构概念包括程序、命名空间、类型、成员和程序集：程序声明类型，类型包含成员并被整理到命名空间中，成员可包含常量、字段、方法、属性、索引器、事件、运算符、构造函数、终结器、嵌套类型等。编译完的程序打包到程序集中，程序集的文件扩展名一般为 `*.exe`（应用程序）或 `*.dll`（库）。

程序集包含中间语言（IL）指令形式的可执行代码和元数据形式的符号信息。执行前，.NET 公共语言运行时的实时（JIT）编译器会将程序集中的 IL 代码转换为特定于处理器的代码。程序集是包含代码和元数据的自描述功能单元，只需在编译程序时引用特定的程序集，即可在程序中使用此程序集中包含的公共类型和成员。

C# 程序由一个或多个文件组成，每个文件均包含零个或多个命名空间。一个命名空间包含类、结构、接口、枚举、委托等类型或其他命名空间。

```csharp
// A skeleton of a C# program
using System;
namespace YourNamespace{
    class YourClass{}
    struct YourStruct{}
    interface IYourInterface{}
    delegate void YourDelegate();
    enum YourEnum{}
    namespace YourNestedNamespace{
        struct YourStruct{}
    }
    class Program{
        static void Main(string[] args){
            //Your program starts here...
            Console.WriteLine("Hello world!");
        }
    }
} 
```

>---
#### 程序启动

一个程序可以编译为一个类库，也可以是一个可以直接启动的应用程序。当应用程序运行时，将创建一个新的应用程序域 "*Application Domain*"。同一台计算机上可以同时存在多个不同的应用程序实例，每个实例都有自己的应用程序域。

应用程序域通过充当应用程序状态的容器来实现应用程序隔离，用以隔离应用程序及其依赖的类库中定义的类型。对象的实例不能在应用程序域中直接共享。每个应用程序域都有自己类型的静态变量副本，并且每个应用程序域最多运行一次类型的静态构造函数。

作为应用程序编译的程序应包含至少一个符合规范要求的方法作为入口点，`Main` 方法是可执行程序的入口点，也是程序控制开始和结束的位置。程序中只能有一个入口点，如果多个类包含 `Main` 方法，必须使用 `StartupObject` 编译器选项来告知程序，将指定哪个 `Main` 方法用作应用程序入口点。

```csharp
class Program
{
    static void Main(string[] args)
    {
        // Display the number of command line arguments.
        Console.WriteLine(args.Length);
    }
}
```

`Main` 方法的声明中，可选包含命令行自变量 `string[] args` 参数。可使用 `System.Environment.GetCommandLineArgs();` 方法获取命令行参数。与 C 和 C++ 不同，程序的名称不被视为 `args` 数组中的第一个命令行实参，但它是 `GetCommandLineArgs()` 方法中的第一个元素。 

```csharp
class Program
{
    static void Main(string[] args)
    {
        var env_args = Environment.GetCommandLineArgs();
        if (args.Length > 0)
            Console.WriteLine("args[0] = " + args[0]);
        Console.WriteLine("env_args[0] = " + E_args[0]);
    }
}
```


> 有效的 Main 签名

```csharp
public static void Main() { }
public static int Main() { }
public static void Main(string[] args) { }
public static int Main(string[] args) { }

public static async Task Main() { }
public static async Task<int> Main() { }
public static async Task Main(string[] args) { }
public static async Task<int> Main(string[] args) { }
```

> Async Main

声明 `async Main` 返回值时，编译器会生成样本代码，用于调用 `Main` 中的异步方法。如果未指定 `async` 关键字，则需要自行编写该代码，如以下示例所示。示例中的代码可确保程序一直运行，直到异步操作完成：

```csharp
public static void Main()
{
    AsyncConsoleWork().GetAwaiter().GetResult();
}
private static async Task<int> AsyncConsoleWork()
{
    // Main body here
    return 0;
}
```

该示例代码可替换为：

```csharp
static async Task<int> Main(string[] args)
{
    return await AsyncConsoleWork();
}
private static async Task<int> AsyncConsoleWork()
{
    // main body here 
    return 0;
}
```

异步方法 `async Main` 编译器始终为其生成正确的代码。编译器生成一个新的入口函数来调用 `async Main`。假设为 `$GeneratedMain`，编译器将生成：

```csharp
static async Task Main(){}  // 生成等效项 => 
private static void $GeneratedMain() 
    => Main().GetAwaiter().GetResult();

static async Task Main(string[] args){} // 生成等效项 =>
private static void $GeneratedMain(string[] args) 
    => Main(args).GetAwaiter().GetResult();

static async Task<int> Main(){} // 生成等效项 =>
private static int $GeneratedMain() 
    => Main().GetAwaiter().GetResult();

static async Task<int> Main(string[] args){} // 生成等效项 =>
private static int $GeneratedMain(string[] args) 
    => Main(args).GetAwaiter().GetResult();
```

>---
#### 顶级语句

C# 9 之后可以在编译单元中使用顶级语句，编译器为该编译单元生成 `Main`，一个项目仅包含一个顶级语句编译单元。顶级语句隐式位于全局命名空间中。使用 `Environment.GetCommandLineArgs()` 访问命令行参数。

```csharp
using System.Console;

Console.WriteLine("Hello World! {0}", Environment.GetCommandLineArgs()[0]);
```

顶级语句中可以通过使用 `await` 和 `return`，编译器为其生成正确的 `Main`。

```csharp
// 包含 await 和 return
static async Task<int> $GeneratedMain(string[] args){}
// 包含 await
static async Task $GeneratedMain(string[] args){}
// 包含 return
static int $GeneratedMain(string[] args){}
// 非异步无返回
static void $GeneratedMain(string[] args){}
```

>---
#### 程序终止

应用程序终止时将控制权返回到执行环境。当 `Main` 方法返回 `int` 或 `Task<int>` 时，若程序执行完没有导致异常，则返回 `int` 的值用作应用程序的终止状态码，用以表示向执行环境传递应用程序成功或失败的通信。

如果有效入口点方法的返回类型为 `void` 或 `Task`，并且执行完成后没有导致异常，则终止状态码为 `0`。

如果有效入口点方法由于异常而终止，则退出代码是特定于实现的。终结器 `finalizer` 是否作为应用程序终止的一部分运行由实现定义。.NET 框架实现尽一切合理的努力为所有尚未被垃圾收集的对象调用终结器，除非这种清理已经被抑制（例如 `GC.SuppressFinalize`）。

>---
#### 托管执行和 CIL

处理器不能直接解释程序集，程序集使用公共中间语言（*Common intermediate Language*，CIL）。C# 编译器将 C# 源代码文件翻译成中间语言。程序集在 VES（*Virtual Execution System*，虚拟执行系统），运行时（*runtime*）中按需即时编译（*just-in-time compilation*，JIT 编译）为机器码供本机使用。代码在运行时的上下文中执行，就称为托管代码 （*managed code*），在运行时的控制下执行的过程称为托管执行 （*managed execution*）。

“托管” 是指运行时管理程序的内存分配、安全性和 JIT 编译等方面，进而控制了程序的主要行为。不需要 “*runtime*” 支持的代码称为本机代码（*native code*）或非托管代码 （*unmanaged code*）。

运行时规范包含在一个包容面更广的规范 CLI（*Common Language Infrastructure*，公共语言基础结构 ）中：
- CIL（*Common intermediate Language*）公共中间语言，MSIL 或 IL；
- BCL（*Base Class Library*）基类库，属于 FCL 的一个子集；
- FCL（*Framework Class Library*）框架类库，底层由大部分 BCL 组成，主要对 .NET 框架、运行时和 CIL 语言提供支持（预定义类型、集合类型、线程处理、应用程序域、运行时、安全性、互操作等）；中间层是包含了对操作系统功能的封装（文件系统、网络连接、图形图像、XML 操作等）；最外层是包含各种类型的应用程序（Windows Forms、ASP.NET、WPF、WCF、WF 等）；
- CTS（*Common Type System*）公共类型系统；
- CLS（*Common Language Specification*）公共语言规范；
- CLR（*Common Language Runtime*）公共语言运行时，也叫 VES（*Virtual Execution System*，虚拟执行系统），CLR 是 .NET 程序集的运行环境；
- Metadata 元数据包括程序集的布局或文件格式规范。
  
CIL 在 CLR 执行引擎的上下文中运行，其中运行的主要服务和功能包括：
- 语言互操作性：不同源语言间的互操作性。语言编译器将每种源语言转换成相同中间语言 CIL 来实现这种互操作性。
- 类型安全：检查类型间转换，确保兼容的类型才能相互转换。这有助于防范缓冲区溢出。
- 代码访问安全性：程序集开发者的代码有权在计算机上执行的证明。
- 垃圾回收：一种内存管理机制，自动释放 CLR 为数据分配的空间。
- 平台可移植性：同一程序集可在多种操作系统上运行。
- BCL（基类库）：提供开发者能（在所有 .NET 框架中）依赖的大型代码库。


---
### 词汇元素

#### Keywords

| keyword      | description |
| :----------- | :---------- |
| `abstract`   |
| `as`         |
| `base`       |
| `bool`       |
| `break`      |
| `byte`       |
| `case`       |
| `catch`      |
| `char`       |
| `checked`    |
| `class`      |
| `const`      |
| `continue`   |
| `decimal`    |
| `default`    |
| `delegate`   |
| `do`         |
| `double`     |
| `else`       |
| `enum`       |
| `event`      |
| `explicit`   |
| `extern`     |
| `false`      |
| `finally`    |
| `fixed`      |
| `float`      |
| `for`        |
| `foreach`    |
| `goto`       |
| `if`         |
| `implicit`   |
| `in`         |
| `int`        |
| `interface`  |
| `internal`   |
| `is`         |
| `lock`       |
| `long`       |
| `namespace`  |
| `new`        |
| `null`       |
| `object`     |
| `operator`   |
| `out`        |
| `override`   |
| `params`     |
| `private`    |
| `protected`  |
| `public`     |
| `readonly`   |
| `ref`        |
| `return`     |
| `sbyte`      |
| `sealed`     |
| `short`      |
| `sizeof`     |
| `stackalloc` |
| `static`     |
| `string`     |
| `struct`     |
| `switch`     |
| `this`       |
| `throw`      |
| `true`       |
| `try`        |
| `typeof`     |
| `uint`       |
| `ulong`      |
| `unchecked`  |
| `unsafe`     |
| `ushort`     |
| `using`      |
| `virtual`    |
| `void`       |
| `volatile`   |
| `while`      |

>---

#### Context Keywords

| keyword      | description |
| :----------- | :---------- |
| `add`        |
| `alias`      |
| `ascending`  |
| `async`      |
| `await`      |
| `by`         |
| `descending` |
| `dynamic`    |
| `equals`     |
| `from`       |
| `get`        |
| `global`     |
| `group`      |
| `into`       |
| `join`       |
| `let`        |
| `nameof`     |
| `on`         |
| `orderby`    |
| `partial`    |
| `remove`     |
| `select`     |
| `set`        |
| `unmanaged`  |
| `value`      |
| `var`        |
| `when`       |
| `where`      |
| `yield`      |

>---
#### Operator and Punctuator

```csharp
   {    }    [    ]    (    )    .    ->   ,    :    ;  
   +    -    *    /    %    &    |    ^    !    ~    =   
   +=   -=   *=   /=   %=   &=   |=   ^=   ~=   ?    ??     
   <    <=   >    >=   !=   ==   ++   --   &&   ||   ??=
   ..   ?.   ?[]  >>   <<   >>=  <<=  >>>  >>>= 
```

>---
#### Identifier

标识符（identifiers）可以由 `_` 开头，由数字字符和字母字符组合的字符序列，不能是数字作为开头。可以在标识符中使用 Unicode 转义序列；使用 `@` 开头时，允许关键字作为标识符。

```csharp
class @class
{
    static void @static(bool @bool) => Console.WriteLine(@bool ? "true" : "false");
    static void main(String[] args)
    {
        cl\u0061ss.st\u0061tic(true);  // \u0061 'a'
    }
}
```

---

### 声明与类型定义
#### 声明与名称空间

C# 程序中的声明定义程序的构成元素。C# 使用命名空间 `namespace` 对相关程序元素进行逻辑分组。

类型声明用于定义类、结构、接口、枚举，以及委托。类型声明中允许的成员种类取决于类型声明的形式：类声明可以包含常量、字段、方法、属性、事件、索引器、运算符、实例构造函数、静态构造函数、终结器和嵌套类型。

声明在其所属的名称空间中定义一个名称。在名称空间中声明不能同名，但以下情况除外：
- 允许在同一名称空间中使用两个或多个具有相同名称的命名空间名称。这些相同名称的命名空间被聚合成一个逻辑命名空间，并共享一个名称空间。

+ 在不同的程序中，在相同的命名空间中的声明可以共享相同的名称。但是，如果将这些声明包含在同一个应用程序中，可能会引入歧义。

- 允许在同一名称空间中使用具有相同名称但不同签名的方法（方法重载），或具有相同名称但类型形参数量不同的类型声明（泛型类型）。
  
+ 在同一名称空间中的 `partial` 分部声明的多个类型共享相同的名称、相同数量的类型参数和相同的类型定义（类、结构或接口）。
  
- 同一名称空间中的命名空间声明和类型声明可以共享相同的名称，只要类型声明至少有一个类型形参。

每个命名空间和类型都有一个完全限定的名称，该名称唯一地标识命名空间或类型。成员 N 的完全限定名是从全局空间开始的标识符的完整层次结构路径，命名空间或类型的完全限定名称始终是唯一的。

```csharp
class A { }                // A
namespace X                // X
{
    class B                // X.B
    {
        class C { }         // X.B.C
    }
    namespace Y            // X.Y
    {
        class D { }         // X.Y.D
    }
}
namespace X.Y              // X.Y
{
    class E { }             // X.Y.E
    class G<T>             // X.Y.G<>
    {
        class H { }         // X.Y.G<>.H
    }
    class G<S, T>           // X.Y.G<,>
    {
        class H<U> { }      // X.Y.G<,>.H<>
    }
}
```

声明空间分类：
- 在程序的所有编译单元中，不包含在某个命名空间下的声明包含在全局名称空间（global declaration space）内，全局名称空间下的成员被聚合在全局命名空间内，可以显式通过 `global::` 进行访问。
+ 在程序的所有编译单元中，所有相同完全限定名称的命名空间中的成员声明隶属于该名称的单个逻辑命名空间。
- 每个编译单元和命名空间内都有一个别名（`using`、`extern alias`）名称空间。
+ 每个非分部类、非分部结构和非分部接口声明都将创建一个新的名称空间。除了构造函数以外，类或结构不能包含与类或结构同名的成员声明，但允许声明具有相同名称不同签名的方法或运算符重载。基类不会占用派生类的名称空间，基接口不会占用派生接口的名称空间，因此允许派生类或接口声明与继承成员同名的成员，这类声明的成员将隐藏具有相同名称的继承成员。
- 每个委托、枚举声明都将创建一个新的名称空间。
+ 每个方法声明、属性声明、访问器声明、索引器声明、运算符声明、构造函数声明、匿名函数和局部函数声明都会创建一个新的局部变量名称空间。局部变量名称空间可以嵌套，但是无法在局部和嵌套的名称空间内包含同名的局部声明。
- 每个块 `{ }` 或 `switch-case` 区间、`for`、`foreach`、`using` 等语句都将为局部变量和本地常量创建局部变量名称空间。 
+ 声明名称的文本顺序通常没有意义。例如对于命名空间、常量、方法、属性、事件、索引器、操作符、实例构造函数、终结器、静态构造函数和类型的声明和使用，文本顺序并不重要。声明顺序的重要性体现在：
  - 字段名称的声明顺序决定了它们的初始化式执行的顺序；
  - 局部变量应该在使用之前定义；
  - 当省略关联常数值时，枚举成员的声明顺序很重要。

---
#### 类型定义

类型定义 C# 中的任何数据的组织结构和行为。类型的声明可以包含其成员、基类型、它实现的接口和该类型的行为。变量是用于引用特定类型的实例的标签。标识符是绑定给类型（类、接口、结构、记录、委托或枚举）、成员、变量或命名空间的名称。

C# 是一种强类型语言，每个变量和常量、求值的表达式、方法形参与返回值等都有一个类型。.NET 类库定义了内置数值类型和表示各种构造的复杂类型，其中包括文件系统、网络连接、对象的集合和数组以及日期。类型中可存储的信息有：分配所需空间、值范围、成员（方法、字段、事件等）、基类型、由它实现的接口、允许执行的运算等。

C# 主要有两种类型：值类型和引用类型。值类型变量包含值，引用类型变量包含对数据（称为 “对象”）的引用。在程序运行中，值类型在堆栈（*stack*）上分配，引用类型在堆（*heap*）上分配。

C# 值类型可分为：简单类型、枚举类型、结构类型、可以为 null 的值类型和元组值类型。C# 引用类型又细分为类类型、接口类型、数组类型和委托类型。
- 简单类型：
  - 有符号整数类型：`sbyte`、`short`、`int`、`long`、`nint`。
  - 无符号整数类型：`byte`、`ushort`、`uint`、`ulong`、`nuint`。
  - Unicode 字符类型：`char`，表示 UTF-16 代码单元。
  - IEEE 二进制浮点数类型：`float`、`double`。
  - 高精度十进制浮点数类型：`decimal`。
  - 布尔类型：`bool`。
- 枚举类型：格式为 `enum E {...}` 的用户定义类型。`enum` 类型是一种包含已命名常量的独特类型。
- 结构类型：格式为 `struct S {...}` 的用户定义类型。`record struct` 为记录结构类型。
- 可以为 null 的值类型：值为 `null` 的其他所有值类型的扩展。
- 元组类型：格式为 `(T1,T2,...)` 的用户定义类型。

C# 引用类型可分为：类类型、接口类型、数组类型、委托类型。
- 类类型：
  - 其他所有类型的最终基类：`object`。
  - Unicode 字符串：`string`，表示 UTF-16 代码单元序列。
  - 格式为：`class C {...}` 的用户定义类型。`record` 为记录类型。
- 接口类型：格式为 `interface I {...}` 的用户定义类型。
- 数组类型：一维、多维和交错数组。例如 `int[]`、`int[,]`、`int[][]`。
- 委托类型：格式为 `delegate TResult D(...)` 的用户定义类型。

> *用户定义类型*

C# 程序使用类型声明创建新类型。用户可定义以下 C# 基本类型：类类型、结构类型、接口类型、枚举类型和委托类型。还可以声明 `record` 类型（`record struct` 或 `record class`）。

- `class` ：类类型定义包含数据成员（字段）和函数成员（方法、属性、构造函数等）的数据结构。类支持单一继承和多态。类对象在堆上分配内存，并受垃圾回收器的管理。
- `struct`：结构类型定义包含数据成员和函数成员的结构，与类相似。结构属于堆栈分配对象，不受垃圾回收器的管理。结构不支持用户指定的继承，可以实现接口。
- `interface`：接口类型将协定定义为一组已命名的公共成员。实现 `interface` 的 `class` 和 `struct` 必须提供接口成员的实现代码。接口和类、结构都可以实现多个接口。。
- `delegate`：委托类型表示引用包含特定参数列表和返回类型的方法。通过委托，可以将方法组视为变量并可作为参数传递的实体。委托类同于函数式语言提供的函数类型或函数指针概念，但是委托是面向对象且类型安全。
- `record`：记录类型用类提供封装数据的内置功能。可以声明为 `record` 引用类型或 `record struct` 值类型。记录类型具有编译器合成成员，主要用于存储值，关联行为最少。
- `enum`：枚举类型是由基础整型数值类型的一组命名常量定义的值类型。可以显式指定关联的常数值。

```csharp
class MyClass{}
struct MyStruct{}
interface IMyInterface{}
enum MyEnum{}
record class MyClass_Record{}
record struct MyStruct_Record{}
```

> 类型与变量

C# 有多种变量，其中包括字段、数组元素、局部变量和参数。变量表示存储位置，每个变量都具有一种类型，用于确定可以在变量中存储哪些值：

- 不可为 null 的值类型：具有精确类型的值。
- 可以为 null 的值类型：`null` 值或具有精确类型的值。
- `object`：`null` 引用、对任意引用类型的对象的引用，或对任意值类型的装箱值的引用。
- 类类型：`null` 引用、对类类型实例的引用，或对派生自类类型的类实例的引用。
- 接口类型：`null` 引用、对实现接口类型的类类型实例或值类型的装箱值的引用。
- 数组类型：`null` 引用、对数组类型实例的引用，或对兼容的数组类型实例的引用。
- 委托类型：`null` 引用、对兼容的委托类型实例的引用。
- 记录类型：记录类包含 `null` 引用或记录类实例的引用，记录结构包含记录结构实例的值。

当在程序中声明变量或常量时，必须指定其类型或使用 `var` 关键字让编译器推断类型。变量的值可以分配给其兼容类型或基类型。

```csharp
// Declaration only:
float temperature;
string name;
MyClass myClass;

// Declaration with initializers (four examples):
char firstLetter = 'C';
var limit = 3;
int[] source = { 0, 1, 2, 3, 4, 5 };
var query = from item in source
            where item <= limit
            select item;
```

>---
#### NET 内置类型

C# 提供了一组标准的内置类型。这些类型表示整数、浮点值、布尔表达式、文本字符、十进制值和其他数据类型。还有内置的 `string` 和 `object` 类型。

- 内置值类型：`bool`、`byte`、`sbyte`、`char`、`decimal`、`double`、`float`、`int`、`uint`、`nint`、`nuint`、`long`、`ulong`、`short`、`ushort`。
- 内置引用类型：`object`、`string`、`dynamic`。
- 无类型：`void`。

```csharp
// 整数
byte b = 1;
int i = 0xffff;  // 十六进制
// 浮点值
double d = 1.0;
float f = 1.0f;
// 布尔
bool state = true;
// 文本字符
char ch = 'C';
// 十进制值
decimal digit = 1980;
// 字符串
string str = "Hello world";
// object
object obj = null;
```

>---
#### 非托管类型

如果某个类型是以下类型之一，则它是非托管类型：
  - `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`nint`、`nuint`、`char`、`float`、`double`、`decimal` 或 `bool`。
  - 任何枚举类型，任何指针类型，任何仅包含非托管类型字段的用户定义的结构类型。

非托管类型使用 `unmanaged` 约束指定：类型参数为 “非指针、不可为 null 的非托管类型”。

```csharp
public struct Coords<T> where T : unmanaged
{
    public T X;
    public T Y;
}
```

>---
#### NET 通用类型系统

对于 .NET 中的类型系统，它支持继承原则。类型可以派生自其他类型（称为基类型）。派生类型继承（有一些限制）基类型的方法、属性和其他成员。所有类型派生自单个基类型 `System.Object (C# keyword: object)`。这样的统一类型层次结构称为通用类型系统（CTS）。

> 类、结构或记录的声明类似于一张蓝图，用于在运行时创建实例或对象：

- 类是引用类型，创建类型的对象后，向其分配对象的变量仅保留对相应内存的引用（将对象引用分配给新变量后，新变量会引用原始对象）。
- 结构是值类型，创建结构时，向其分配结构的变量保留结构的实际数据（将结构分配给新变量时，会复制结构）。
- 记录类型可以是引用类型（`record` 或 `record class`）或值类型（`record struct`）

> 值类型

值类型派生自 `System.ValueType`（派生自 `System.Object`）。值类型变量直接包含其值，结构的内存在声明变量的任何上下文中进行内联分配。对于值类型变量，没有单独的堆分配或垃圾回收开销。

值类型分为 `struct` 和 `enum` 两类。内置的数值类型是结构，使用 `struct` 关键字可以创建用户自定义值类型，无法从任何值类型派生类型。`enum` 枚举定义的是一组已命名的整型常量，所有枚举派生自 `System.Enum`（`Enum` 派生自 `System.ValueType`）。


> 引用类型

定义为 `class`、`record class`、`delegate`、数组或 `interface` 的类型是引用类型。引用类型在声明时包含 null 值，直到用户为其分配该类型的实例或使用 `new()` 创建一个。`interface` 通过其实现类型分配值。所有数组都是引用类型，隐式派生自 `System.Array` 类。

创建对象时，会在托管堆上分配内存。变量只保留对对象位置的引用。对于托管堆上的类型，在分配内存和回收内存时都会产生开销。“垃圾回收” 是 CLR 的自动内存管理功能，用于执行资源管理和内存回收。

引用类型完全支持继承。声明类时，可以从其他任何接口或非密封类继承。派生类可以从基类中继承或重写虚拟方法。

>----
#### 泛型类型

可使用一个或多个类型参数声明的类型，用作实际类型（具体类型）的占位符。客户端代码在创建类型实例时提供具体类型，这种类型称为泛型类型，过程称为泛型实例化。例如，.NET 类型 `System.Collections.Generic.List<T>` 具有一个类型参数 `T`，当创建类型的实例时，必须指定列表将包含的对象的类型 `T`，例如 `string`：

```csharp
List<string> stringList = new List<string>();
stringList.Add("String example");
// compile time error adding a type other than a string:
stringList.Add(4);
```

可以声明泛型类、泛型结构、泛型记录、泛型接口、泛型方法和泛型委托。泛型集合类称为强类型集合，因为编译器知道集合元素的具体类型，并能在编译时检查或引发错误。

```csharp
public class Pair<TFirst, TSecond> // <,> 类型参数列表
{
    public TFirst First { get; }
    public TSecond Second { get; }
    public Pair(TFirst first, TSecond second) => 
        (First, Second) = (first, second);
}
```

使用泛型类时，必须为每个类型参数提供类型自变量。

```csharp
{
    var pair = new Pair<int, string>(1, "two");
    int i = pair.First;     //TFirst int
    string s = pair.Second; //TSecond string
}
```

>---
#### 隐式类型、匿名类型和可空值类型

可以使用 `var` 关键字隐式键入一个局部变量（但不是类成员）。隐式类型仍可在编译时获取类型，但类型是由编译器提供。

```csharp
var list = new List<int> { 1, 2, 3, 4, 5, 6 };   // List<int>
var d_num = 3.1415;     // double
var func = mess => Console.WriteLine(mess);     // Action<string>
```

可结合使用 `new` 运算符和对象初始值设定项创建匿名类型。匿名类型提供了一种便捷的方法，可用来将一组只读属性封装到单个对象中，而无需预定义一个类型。

```csharp
var Person = new { FirstName = "John", LastName = "Ychao" };
var anonArray = new[] {
    new { name = "apple", diam = 4 },
    new { name = "grape", diam = 1 }
};
```

一般值类型不具有 `null` 值，`T?` 表示为值类型 `T` 的可为空类型。例如，`int?` 是可以包含值 `null` 的 `int` 类型。可以为 `null` 的值类型是 `System.Nullable<T>` 的实例。 

```csharp
int? val = null, val2 = 10;
if (val.HasValue)  // false
    Console.WriteLine(val.Value);   
Console.WriteLine(val2 ?? 0);  // 10   
```

>---
#### 编译时类型和运行时类型

变量可以具有不同的编译时和运行时类型。编译时类型是源代码中变量的声明或推断类型；运行时类型是该变量所引用的实例的类型。

```csharp
// 运行时和编译时类型相同
string message = "This is a string of characters";   // 编译时和运行时都是 string

// 运行时和编译时类型不同
object anotherMessage = "This is another string of characters";     // 编译时为 object，运行时为 string
IEnumerable<char> someCharacters = "abcdefghijklmnopqrstuvwxyz";    // 编译时为 IEnumerable<char>，运行时为 string
```

---
### 成员与成员访问

命名空间和类型拥有成员。类型的成员在类型定义中声明或从基类型继承。基类的所有成员（除构造函数、终结器外）将成为派生类型的成员。成员的可访问性限制派生类型对该成员的可见性。派生类型也可以通过声明同名成员隐藏继承的成员。

没有在封闭命名空间中声明或类型声明是全局命名空间的成员，可以显式 `global::` 进行访问成员。命名空间中声明的子命名空间和类型是该命名空间的成员。命名空间没有访问限制，其他成员类型可以添加可访问性。

结构的成员是在结构中声明的成员和从结构体的直接基类 `System.ValueType` 和间接基类 `System.Object` 继承的成员。

枚举的成员是枚举中声明的常量，从枚举的直接基类 `System.Enum` 和间接基类 `System.ValueType` 和 `object` 继承的成员。

类的成员是在类中声明的成员（包含常量、字段、方法、属性、事件、索引器、运算符、实例构造函数、析构函数、静态构造函数和嵌套类型），和从所有基类中继承的成员。从基类继承的成员包括常量、字段、方法、属性、事件、索引器、运算符、嵌套类型和基类的类型，但不包括基类实例构造函数、终结器和静态构造函数。

接口的成员是在接口和所有基接口中声明的成员。严格来讲，类对象中的成员不是任何接口的成员，接口仅提供一种成员协议，要求所有实现该接口的类型同时提供接口成员的实现。

数组成员是从类 `System.Array` 继承的成员。

委托的成员是从类 `System.Delegate` 或 `System.MulticastDelegate` 继承的成员。它还包含一些由遍历器生成的方法成员，如 `Invoke` 等。

>---
#### 成员访问

成员声明允许对成员的可访问性进行控制。成员的可访问性由成员声明的可访问性和包含类型的可访问性结合确定。成员的可访问域绝不会超出包含类型的可访问域。成员的可访问性可以是：

  - `public`：访问不受限制。
  - `protected`：访问限于包容类型、或派生自包含类的类型。
  - `internal`：访问仅限于当前程序集（`.exe` 或 `.dll`）。
  - `protected internal`：访问限于当前程序集、包容类型或派生自包含类的类型。
  - `private`：访问仅限于包容类型。
  - `private protected`：访问限于包含类型、或同一程序集中派生自包含类的类型。
  - `file`：（C#11）已声明的类型仅在当前源文件中可见。文件范围的类型通常用于源生成器。

当成员声明不包括任何访问修饰符时，声明位置的上下文决定声明的可访问性：

  - 命名空间没有任何访问限制，隐式声明为 `public` 且无法添加访问修饰符。
  - 位于编译单元或命名空间中声明的顶级类型只能具有 `internal` 或 `public` 可访问性，默认可访问性为 `internal`。
  - `class` 的成员默认为 `private`，其成员可以声明 `public`、`internal`、`protected`、`protected internal`、`private`、`private protected`。
  - `struct` 的成员默认为 `private`，其成员可以声明为 `public`、`internal`、`private`。
  - `interface` 的成员默认为 `public`，其成员可以声明为 `public`、`internal`、`protected`、`protected internal`、`private`、`private protected`，其中声明为 `private` 的接口成员必须具有默认的实现。
  - `enum` 的成员默认为 `public`，其成员不允许添加访问修饰符。

> 文件本地类型（C#11）

- `file` 修饰符将顶级类型的范围和可见性限制为其所包含的文件范围。`file` 修饰符通常应用于源生成器编写的类型。**文件本地类型** 为源生成器提供了一种方便的方法，能够避免在生成的类型之间发生名称冲突。
- `file` 可用于修饰 `class`、`struct`、`enum`、`interface`、`record`、`delegate`、`record struct`、`Attribute class`。


>---
#### 可访问性约束

C# 中的一些结构要求类型至少具有与成员或其他类型一样的可访问性。存在以下可访问性限制：
- 类类型的直接基类至少具有应与类类型本身相同的可访问性。
- 接口类型的显式基接口至少具有与接口类型本身相同的可访问性。
- 委托类型的返回类型和参数类型至少具有与委托类型本身相同的可访问性。
- 常量的类型至少具有与常量本身相同的可访问性。
- 字段的类型至少具有与字段本身相同的可访问性。
- 方法的返回类型和参数类型至具有与方法本身相同的可访问。
- 属性的类型至少具有与属性本身相同的可访问性。
- 事件的类型至少具有与事件本身同样的可访问性。
- 索引器的类型和参数类型至少具有与索引器本身相同的可访问性。
- 运算符的返回类型和参数类型至少具有与运算符本身具有相同的可访问性。
- 实例构造函数的参数类型至少具有与实例构造函数本身相同的可访问性。
- 类型参数上的接口或类类型约束至少具有与声明该约束的成员相同的可访问性。

```csharp
class SampleA { }
public class SampleB
{
    SampleA F() => new SampleA();
    internal SampleA G() => F();
    public SampleA H() => F();  // err: SampleA 比方法 H 的可访问性低
}
```

---
### 简单值类型

值类型包含结构类型和枚举类型。C# 提供了一组预定义的结构类型，被称为简单类型，简单类型可以通过关键字来识别。

所有的值类型都隐式继承类 `System.ValueType`，任何类型都不可能从值类型派生，所有值类型都是隐式密封的。

- `sbyte` 对应于 `System.Sbyte`。
- `byte` 对应于 `System.Byte`。
- `short` 对应于 `System.Int16`。
- `ushort` 对应于 `System.UInt16`
- `int` 对应于 `System.Int32`。
- `uint` 对应于 `System.UInt`。
- `long` 对应于 `System.Int64`。
- `ulong` 对应于 `System.UInt64`。
- `char` 对应于 `System.Char`。
- `float` 对应于 `System.Single`。
- `double` 对应于 `System.Double`
- `decimal` 对应于 `System.Decimal
- `bool` 对应于 `System.Boolean`。
- `nint` 对应于 `System.IntPtr`。
- `nuint` 对应于 `System.UIntPtr`

>---
#### Integer

C# 支持 11 种整数类型，所有的有符号整数都使用二进制补码格式表示：

| type | description | value range |
| :--- | :---------- | :---------- |
| `sbyte`|    有符号 8 位整数 | -128 ~ 127
| `byte`|    无符号 8 位整数 |  0 ~ 255 
| `short`|    有符号 16 位整数 | -32768 ~ 32767
| `ushort`|    无符号 16 位整数 | 0 ~ 65535
| `int`|    有符号 32 位整数|-2147483648 ~ 2147483647 
| `uint`|    无符号 32 位整数| 0 ~ 4294967295 
| `long`|    有符号 64 位整数| -9223372036854775808 ~ 9223372036854775807 
| `ulong`|    无符号 64 位整数 |0 ~ 18446744073709551615 |
| `char`|     Unicode-16 码位整数值 |0 ~ 65535|
| `nint`|   32 或 64 位本机大小有符号整数
| `nuint`|   32 或 64 位本机大小的无符号整数

没有其他整数类型到 `char` 类型的隐式转换。`char` 的常量应写成字符形式或 `(char)integer` 的强制转换形式。

`checked` 和 `unchecked` 运算符和语句用于控制整型算数运算和转换的溢出检查。`checked` 上下文中整型运算溢出会引发 `System.OverflowException` 异常；`unchecked` 上下文中将忽略溢出，并且不会丢弃任何不适合目标类型的高序位。  

```csharp
// 有符号整数
sbyte   _int8 = -8;         // -2^7 ~ 2^7-1
short   _int16 = -16;       // -2^15 ~ 2^15-1
int     _int32 = -32;       // -2^31 ~ 2^31-1
long    _int64 = -64L;      // -2^63 ~ 2^63-1
// 无符号整数
byte    _uint8 = 8;         // 0 ~ 2^8-1
ushort  _uint16 = 16;       // 0 ~ 2^16
uint    _uint32 = 32;       // 0 ~ 2^32
ulong   _uint64 = 64l;      // 0 ~ 2^64
```

> *不同进制数表示*

```csharp
var decimalLiteral = 42;            // 十进制
var hexLiteral = 0x2A;              // 十六进制 0x, 0X
var binaryLiteral = 0b_0010_1010;   // 二进制 0b, 0B
```

> *整数文本后缀*

```csharp
long _long_64 = 0xffffL;            // long, ulong 长整数后缀 L, l
uint _uint_32 = 32u;                // 无符号整数后缀 U, u
ulong _ulong_64 = 0xffffuL;         // 无符号长整数后缀 ul, lu, Ul, lU, UL, LU 
```

> *数字分隔符*

任何数字序列都可以用下划线分隔，两个连续数字之间可以有一个以上的下划线。在小数中也可以使用。

```csharp
int bin = 0b1001_1010_0001_0100;
int hex = 0x1b_a0_44_fe;
int dec = 33_554_432;
int weird = 1_2__3___4____5_____6______7_______8________9;
double real = 1_000.111_1e-1_000;
```

>---
#### Char

`char` 类型用来表示 Unicode UTF-16 字符，支持比较、相等、增量和减量运算符。算数和按位运算得到 `int` 结果。

`char` 的值可以用字符文本、Unicode 转义序列（`\uUUUU`，四位）、十六进制转义序列（`\xXX`）表示。`char` 可以隐式转换为其它包含数值类型，或显式转换为未包含数值类型。其他类型则无法隐式转换为 `char`。

```csharp
char Ch = 'H';
char Ch_x = '\x65';
char Ch_u = '\u00ff';
```

>---
#### Native Integer

```csharp
// 本机大小的整数
nint    _IntPtr = new IntPtr();     // 有符号本机 32 位或 64 位整数
nuint   _UIntPtr = new UIntPtr();   // 无符号本机 32 位或 64 位整数
```

类型 `nint` 和 `nuint` 由底层类型由 `System.IntPtr` 和 `System.UIntPtr` 表示，编译器为这些类型提供额外的转换和操作。本机大小的整数类型具有特殊行为，因为存储是由目标计算机上的自然整数大小决定的。

```csharp
// sizeof, 获取本机整数的大小需要在不安全的上下文中
unsafe
{
    Console.WriteLine($"size of nint = {sizeof(nint)}");
    Console.WriteLine($"size of nuint = {sizeof(nuint)}");
}
// 本机整数的极值
Console.WriteLine($"nint.MinValue = {nint.MinValue}");
Console.WriteLine($"nint.MaxValue = {nint.MaxValue}");
Console.WriteLine($"nuint.MinValue = {nuint.MinValue}");
Console.WriteLine($"nuint.MaxValue = {nuint.MaxValue}");
// 数值转换：没有适用于本机大小整数文本的直接语法，可以改为使用其他整数值的隐式或显式强制转换
// 本机整数支持内置数值转换规则
nint a = (nint)otherInteger;
```

类型 `nint` 和 `nuint` 转换和操作是由编译器合成的，不是底层 `IntPtr` 和 `UIntPtr` 类型的一部分，因此这些转换和运算符操作无法从动态类型的运行时绑定中获得。

```csharp
nint x = 2;
nint y = x + x; // ok
dynamic d = x;
nint z = d + x; // RuntimeBinderException: '+' cannot be applied 'System.IntPtr' and 'System.IntPtr'
```

>---
#### Float-point

C# 支持两种 IEEE-754 格式表示的 `float` （32 位单精度）和 `double`（64 位双精度）浮点数，它们的值域包含：
- 正零和负零，常规算数中和简单值 0 行为相同，在一些特殊的操作中区分零的正负。
- 正无穷（`1.0/0.0`）与负无穷（`-1.0/0.0`）。
- 非数字值，NaN 是由无效的浮点运算产生的，如 `0.0/0`。
- `float` 可以表示具有大约 1.5 × 10⁻⁴⁵ ~ 3.4 × 10³⁸ 的值，精度为 7 位。
- `double` 可以表示具有大约 5.0 × 10⁻³²⁴ ~ 1.7 × 10³⁰⁸ 的值，精度为 15 ~ 16 位。

```csharp
float F_32 = 3.1415f;          // f 或 F 后缀，6~9 位精度
double D_64 = 3.1415;          // 隐式 d 或 D 后缀，15~17 位精度
// 无穷定义
var n_inf = double.NegativeInfinity;    // 负无穷  
var p_inf = double.PositiveInfinity;    // 正无穷
// 非数值
var nan = 0.0/0;   // 非数值
```

如果二元运算符的任一操作数是浮点类型，则应用数值提升，并以 `float` 或 `double` 执行操作：
- 浮点运算永远不会产生异常，在特殊情况下，浮点运算产生零、无穷大或 NaN。
- 浮点运算的结果四舍五入到目标格式中最接近的可表示值。
- 若浮点运算结果的大小对于目标格式来说太小，则将运算结果变成正零或负零。
- 若浮点运算结果的大小对于目标格式来说太大，则将运算结果变为正无穷大或负无穷大。
- 若浮点操作无效，则该操作的结果为 NaN；若其中一个操作数为 NaN 时，最终运算结果也是 NaN。

>---
#### Decimal

`decimal` 类型是一种 128 位的数据类型，适合于金融和货币计算。十进制类型可以表示的范围至少为 -7.9 × 10⁻²⁸ ~ 7.9 × 10²⁸, 至少有 28 位精度。

```csharp
decimal M_128 = 3.1415m;       // m 或 M 后缀，28~29 位精度
```

若二元运算符的任一操作数是 `decimal` 类型，则应用数值提升，并以 `double` 执行该操作：
- 对于 `decimal` 类型的值进行操作的结果是计算精确的结果，并舍入以适应表示。
- 结果四舍五入到最接近的可表示值。舍入可能会从非零值产生零值。
- 若十进制算数运算产生的结果对于 `decimal` 太大，则会产生 `System.OverflowException` 异常。
- 不同于 `float` 和 `double`，`decimal` 可以精确表示 0.1 的值。

#### decimal 和浮点类型 

`decimal` 比 `float` 和 `double` 具有更高的精度，所以可能比浮点类型具有更小的范围。从浮点类型转换为 `decimal` 类型可能产生溢出异常，反过来 `decimal` 转换为浮点类型可能会损失精度或溢出异常。因此它们之间不存在隐式转换，可以显式强制转换。

```csharp
decimal dm = 1.0m;
double d = (double)dm;

float f = 3.14f;
decimal df = (decimal)f;
```

>---
#### Boolean

`bool` 类型表示布尔逻辑值，值可以为 `true` 或 `false`。布尔类型和其他类型之间不存在标准转换，不能用布尔值代替整型。

在 C/C++ 中，零的整型或浮点型值、空指针可以被转换为布尔值 `false`，非零整型或浮点型、非空指针可以被转换为布尔值 `true`。在 C# 中，这种转换是通过显式地将整数或浮点值与零进行比较，或者显式地将对象引用与 `null` 进行比较来完成的。
 
可以使用 `Convert` 类进行布尔转换：非零数值转换为 `true`，零转换为 `false`；字符串转换时忽略大小写。
 
```csharp
bool t = true;
bool f = false;
bool rt = Convert.ToBoolean("True");    // true
bool rt2 = Convert.ToBoolean(0);        // false
```

>---
#### Enum

枚举类型是声明一组命名常量的值类型。每个枚举类型都有一个相应的整型作为其基础类型，该整数类型可以是 `byte`、`sbyte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`。默认的基础类型是 `int`。

使用 `enum` 定义枚举类型，并声明其枚举成员的命名常量和关联常数值，多个枚举成员可以共享相同的关联值。

关联值可以隐式或显式赋值。若枚举成员是枚举类型中的第一个枚举成员，在为显式赋值时，其关联值为 0。其他未显式赋值的枚举成员的关联值是前一个成员的值加 1。

```csharp
enum Color : uint
{
    Red = 1,
    Green = 2,
   // Blue = -3, // err 
    Blue = 3,
    Max = Blue
}
```

可以使用枚举类型，通过一组互斥值或选项组合来表示选项。若要表示选项组合，请将枚举类型定义为位标志。

```csharp
public enum Days
{
    None      = 0b_0000_0000,  // 0
    Monday    = 0b_0000_0001,  // 1
    Tuesday   = 0b_0000_0010,  // 2
    Wednesday = 0b_0000_0100,  // 4
    Thursday  = 0b_0000_1000,  // 8
    Friday    = 0b_0001_0000,  // 16
    Saturday  = 0b_0010_0000,  // 32
    Sunday    = 0b_0100_0000,  // 64
    Weekend   = Saturday | Sunday
}
```

`System.Enum` 类型是所有枚举类型的抽象基类。可在基类约束中使用 `System.Enum`（称为枚举约束），以指定类型参数为枚举类型。对于任何枚举类型，都存在分别与 `System.Enum` 类型的装箱和取消装箱的相互转换。

对于任何枚举类型，枚举类型与其基础整型类型之间存在显式转换。使用 `Enum.IsDefined` 方法来确定枚举类型是否包含具有特定关联值的枚举成员。

```csharp
Console.WriteLine(1.ConvertEnum<Season>());     // Summer
Console.WriteLine((-1).IsDefinedByEnum<Season>());  // False

Season val = (Season)1;     // 强制转换

public enum Season
{
    Spring,
    Summer,
    Autumn,
    Winter
}
public static class EnumExt
{
    public static T ConvertEnum<T>(this int eVal) where T : Enum
        => (T)Enum.ToObject(typeof(T), eVal);
    public static bool IsDefinedByEnum<T>(this int eVal) where T : Enum 
        => Enum.IsDefined(typeof(T), eVal);
}
```

>---
#### ValueTuple

元组类型表示具有可选名称和单独类型的有序、固定长度的值序列。元组类型写为 `(T1 I1, ... , Tn In)`，n ≥ 2，标识符 `I1, ..., In` 是可选的元组元素名。

`(T1, ..., Tn)` 这种构造语法是 `System.ValueTuple<...>` 的简写，它是一组泛型结构类型。能够直接表示 2 ~ 7 数目之间的任意元组类型。数量大于 7 的元组用泛型 `ValueTuple<T1, ..., T7, TRest>` 表示，其中 `TRest` 包含一个嵌套其余元素的值，由另一个 `ValueTuple<...>` 表示。

元组的值可以通过元组表达式创建，也可以是 `new ValueTuple<...>`。

```csharp
using Point = (int, int);

Point p1 = (1, 2);  // 元组表达式
Point p2 = new ValueTuple<int, int>(1, 2);
Point p3 = new(1, 2);
Point p4 = ValueTuple.Create(1, 2);
```

元组类型中的元素名称必须不同，未提供显式名称的元素根据其元素顺序命名为 `ItemX`，`X` 是从 1 开始的序列。可选元素名不在 `ValueTuple<...>` 类型中，并且不会存在元组值得运行时表示形式中。`ItemX` 的显式定义名称只能用在相应的 `X` 位置。

```csharp
using Point = (int x, int y);

Point p1 = (1, 2);
Console.WriteLine(p1.Item1);  // 使用默认的元素名称
Console.WriteLine(p1.y);    // 使用显式提供的元素名称

(int Item1, string Item2) pair1 = (5, "Five");  
(int Item2, string) pair2 = (5, "Five");  // err, Item2 只能用于 2 位置
```

元组类型支持相等运算符 `==` 和 `!=`。

```csharp
(double x, double y) Point1 = new(1, 1);
(double, double) Point2 = new();
Point2.Item1 = Point1.x;
if(Point2 != Point1)
    Console.WriteLine(Point2);  // (1,0)
```

元组最常见的用例之一是作为方法返回类型，可以将方法结果分组为元组返回类型，而不是定义 `out` 方法参数。可以使用赋值运算符 `=` 在单独的变量中析构元组实例，析构元组时可以使用弃元。

```csharp
var (X, Y, _) = GetRandomPoint();   // 析构元组
Console.WriteLine("The Point2D = ({0},{1})", X, Y);
static (int, int, int) GetRandomPoint()
{
    Random rand = new Random(DateTime.Now.Millisecond);
    return (rand.Next(-128, 128), rand.Next(-128, 128), rand.Next(-128, 128));
}
```

> 元组解构

可以在 `struct`、`class`、`record`、`interface` 中声明名为 `Deconstruct` 的方法，该方法返回 `void`，且拥有至少两个 `out` 参数。该方法为这些类型提供解构为元组的功能支持，`Deconstruct` 方法支持重载。

在声明主构造函数的记录中，编译器会为其自动生成一个 `Deconstruct` 方法，其参数列表对照位置记录中的位置参数。

```csharp
 // 为 class 定义解构函数
var (fname, lname) = new Person("Hello", "World");
class Person(string firstName, string lastName)
{
    public string FirstName { get; } = firstName;
    public string LastName { get; } = lastName;
    public void Deconstruct(out string firstName, out string lastName)
        => (firstName, lastName) = (FirstName, LastName);
}

// 解构一个位置记录
var (fname, lname) = new Person("Hello", "World");
record Person(string firstName, string lastName);
```

解构函数也可以是扩展方法，可以为指定类型提供额外的 `Deconstruct` 扩展方法。

```csharp
public static void Deconstruct(this <Type> destTypeObj, out <Type1> val, out <Type2> val2[, out < Type3 > val3...]0) { }

var (<Type1> rt1, <Type2> rt2[, ...]) = destTypeObj;
```

为了方便起见，某些系统类型提供 `Deconstruct` 方法。例如 `System.Collections.Generic.KeyValuePair<TKey,TValue>` 类型提供此功能，循环访问 `Dictionary` 时，每个元素都是 `KeyValuePair<TKey,TValue>`。

```csharp
Dictionary<string, int> snapshotCommitMap = new(StringComparer.OrdinalIgnoreCase)
{
    ["https://github.com/dotnet/docs"] = 16_465,
    ["https://github.com/dotnet/runtime"] = 114_223,
    ["https://github.com/dotnet/installer"] = 22_436,
    ["https://github.com/dotnet/roslyn"] = 79_484,
    ["https://github.com/dotnet/aspnetcore"] = 48_386
};
foreach (var (repo, commitCount) in snapshotCommitMap)
    Console.WriteLine($"The {repo} repository had {commitCount:N0} commits as of November 10th, 2021.");
```

>---
#### Nullable Value

可空值类型 `T?` 表示其基础值类型 `T` 的所有值及额外的 `null` 值，其默认值为 `null`。任何可为空的值类型都是泛型 `System.Nullable<T>` 结构的实例。当 `t.HasValue` 为 `false` 时，`v.Value` 为 `null` 值。

访问可空值类型变量的 `Value` 属性的过程称为展开（*unwrapping*）；为给定值类型创建可空值类型的过程称为包装（*wrapping*） 

```csharp
int num = 0;
int? n_num = num;  // wrapping

int? nullNumble = 10010;
// num = (int)nullNumble; // 可能出现 null 引用异常
num = nullNumble ?? default;  // unwrapping
Console.WriteLine(num);  // 10010
```

可为空值类型拥有预定义的一元或二元运算符时，若至少存在一个 `null` 值时，运算结果也为 `null`。对于比较运算符 `<`、`>`、`<=` 和 `>=`，如果一个或全部两个操作数都为 `null`，则结果为 `false`。`null == null` 返回 `true`。

可以将 `is` 运算符与类型模式结合使用，既检查 null 的可空值类型的实例，又检索基础类型的值。或使用 `Nullable<T>.HasValue` 指示可为空值类型的实例是否有基础类型的值，如果 `HasValue` 为 `true`，则 `Nullable<T>.Value` 获取基础类型的值。也可以使用空合并操作符将可空类型转换为其基础类型。

```csharp
void NullCheck<T>(T? n) where T : struct
{
    // 几种空判定s
    if (n != null)
        Console.WriteLine("The input is " + n.Value);
    if (n is int temp)
        Console.WriteLine("The input is " + temp);
    if (n.HasValue)
        Console.WriteLine("The input is " + n.Value);
    Console.WriteLine("The input is " + (n ?? default(T)));
}
```

> *确定可空值类型*

```csharp
Console.WriteLine($"int? is {(IsNullable(typeof(int?)) ? "nullable" : "non nullable")} value type");
Console.WriteLine($"int is {(IsNullable(typeof(int)) ? "nullable" : "non-nullable")} value type");

bool IsNullable(Type type) => Nullable.GetUnderlyingType(type) != null;

// Output:
// int? is nullable value type
// int is non-nullable value type
```

---
### Struct

结构体类似于类，可以包含数据成员和函数类成员。结构是值类型。对于在构造函数返回后未显式初始化的结构字段都将零初始化。

结构成员可以是常量、字段、方法、属性、事件、索引器、运算符、实例构造函数、静态构造函数和嵌套类型。

```csharp
public struct Coords(double x, double y)
{
    public double X => x;
    public double Y => y;
    public override string ToString() => $"({X}, {Y})";
}
// 记录结构声明
public record struct Data<T> where T : class
{
    public T Bindings;
    public readonly int GUI { get; init; }
}
```

所有结构类型都隐式继承类 `System.ValueType`。结构声明可以实现接口，但不能指定基类。结构总是隐式密封的，因此没有 `abstract` 和 `sealed` 修饰的方法。结构体无法被继承，它的成员不能是 `protected`、`internal protected`、`private protected`。

结构体中的方法不能是 `virtual` 或 `abstract`，但是可以重写从 `System.ValueType` 继承的虚方法。

```csharp
struct Person(string name) : ICloneable
{
    public object Clone() => new Person(name);
    public override string ToString() => name ?? "";
}
```

当结构成员中不包含构造函数时，编译器为其提供一个默认的公共无参实例构造函数；结构体中的实例字段和默认实现的属性具有初始值设定项时，必须同时包含显式声明的构造函数。

```csharp
struct Sample(string first, string last)
{
    public string Name { get; set; } = first + " " + last;
    public string FirstName = first;
    public string LastName = last;
}
```

>---
#### readonly struct

`readonly struct` 结构类型表明实例不可变，它的实例字段都应声明为 `readonly`；实例属性为只读；不能声明字段形式的事件。

当一个只读结构的实例被传递给一个方法时，被视为一个 `in` 参数，它禁止对任何实例字段进行写访问（自身构造函数除外）。

```csharp
readonly struct Sample
{
    public readonly string FirstName;
    public readonly string LastName;
    public string Name => FirstName + " " + LastName;
}
```

>---
#### ref struct

`ref struct` 被称为引用结构，它的实例在执行堆栈上分配，不能转义到托管堆，因此无法被函数闭包捕获（例如匿名函数和 Lambda 表达式）。

`ref struct` 有以下限制：
  - 不能是数组的元素类型、元组的元素类型、不能实现接口、不能是类型参数、不能在迭代器中使用。
  - `ref struct` 不能是类或非 `ref struct` 的字段的声明类型。
  - `ref struct` 不能被装箱为 `System.ValueType` 或 `System.Object`。
  - `ref struct` 变量不能由 Lambda 表达式或局部函数捕获。
  - `ref struct` 变量不能在 `async` 方法中使用，但可以在同步方法中使用 `ref struct` 变量。例如，在返回 `Task` 或 `Task<TResult>` 的同步方法中。
  - `ref struct` 中不能声明异步实例方法、迭代器实例方法。

`ref` 字段有以下限制：
- `ref` 字段只能在 `ref struct` 内部声明。
- `ref` 字段不能声明为 `static`、`volatile`、`const`。
- `ref` 字段的类型不能是 `ref struct`。
- 引用程序集生成过程必须在 `ref struct` 中保留 `ref` 字段的存在。
- `readonly ref struct` 必须将其 `ref` 字段声明为 `readonly ref`。

```csharp
interface ISample { }
interface ISample<T> { }
public ref struct Point(double x, double y) //:ISample  // err: 不能实现接口
{
    public static Point Origin => default;
    public double X { get => x; set => x = value; }
    public double Y { get => y; set => y = value; }
}
class Sample
{
    //Point[] points;   // err: 不能构造数组
    //ISample<Point> sample;    // err: 不能是类型参数
    //Point Origin;   // err: 不能是类或非 ref 结构的字段
    //object origin = (object)Point.Origin;  // err: ref 结构无法装箱成 object
    async void AsyncTest()
    {
        // Point Origin = new(0, 0); // err: async 方法中无法使用 ref 结构
    }
}
```

`ref struct` 可以使用 `default` 表达式进行初始化，但是它的所有 `ref` 字段被初始化为 `null`，因此直接访问这些字段将引发 `NullReferenceException`。可以在调用 `ref` 字段或变量前，使用 `Unsafe.IsNullRef<T>(ref T t)` 检查变量值的引用是否为空。

```csharp
ref struct Sample
{
    private ref int Value;
    public int GetValue()
    {
        if (System.Runtime.CompilerServices.Unsafe.IsNullRef(ref Value))
            throw new InvalidOperationException(message);
        return Value;
    }
}
```

`ref struct` 结构的 `ref` 字段可以与 `readonly` 组合：
- `readonly ref` 字段不能在构造函数或 `init` 属性访问器之外重新 `= ref` 赋值，但是可以在此之外的任何上下文中作为一个值进行 `=` 赋值（注意查 `null`）。
- `ref readonly` 字段可以被 `= ref` 赋值，但是不能 `=` 赋值。
- `readonly ref readonly` 是 `readonly ref` 和 `ref readonly` 的组合，即仅能在构造函数或 `init` 属性访问器中初始化，在其他任何上下文均不能通过 `= ref` 或 `=` 改变字段的状态。 

```csharp
ref struct ReadOnlyExample
{
    ref readonly int Field1;
    readonly ref int Field2;
    readonly ref readonly int Field3;

    void Uses(int[] array)
    {
        Field1 = ref array[0];  // Okay
        Field1 = array[0];      // Error: can't assign ref readonly value (value is readonly)

        Field2 = ref array[0];  // Error: can't repoint readonly ref
        Field2 = array[0];      // Okay
        
        Field3 = ref array[0];  // Error: can't repoint readonly ref
        Field3 = array[0];      // Error: can't assign ref readonly value (value is readonly)
    }
}
```

>---
#### struct this

`this` 在结构体中的含义不同于 `this` 在类中的含义。当结构类型覆盖从 `System.ValueType` 继承的虚方法时（如 `Equals`、`GetHashCode` 或 `ToString`），通过结构类型的实例调用虚拟方法不会导致装箱。即使将结构用作类型参数并且通过类型参数类型的实例调用也是如此。

```csharp
class Sample
{
    struct Counter
    {
        int value;
        public override string ToString() => value++.ToString();
    }
    static void Test<T>() where T : new()
    {
        T x = new T();
        Console.WriteLine(x.ToString());    // 0
        Console.WriteLine(x.ToString());    // 1
        Console.WriteLine(x.ToString());    // 2
    }
    static void Main() => Test<Counter>();
}
```

>---
#### 内联数组

从 C#12 开始，可以声明结构类型的内联数组。内联数组是包含相同类型的 N 个元素的连续块的结构，它是一个安全代码，等效于仅在不安全代码中可用的固定缓冲区声明，编译器可以利用有关内联数组的已知信息。内联数组是仅包含单个字段、且未指定其他任何的显式布局的结构类型。

使用 `System.Runtime.CompilerServices.InlineArrayAttribute` 特性修饰 `struct` 类型，并指定一个大于零的值。

```csharp
[System.Runtime.CompilerServices.InlineArray(10)]
public struct Buffer<T>
{
    private T Elem;
}
// 类似于固定缓冲区
public struct Buffer
{
    public unsafe fixed int buffer[1024]; 
}
```

内联数组是一种高级语言功能。它们适用于高性能方案，在这些方案中，内联的连续元素块比其他替代数据结构速度更快。可以像访问数组一样访问内联数组，可以使用范围和索引运算符。

内联数组对单个字段的类型有最低限制：它不能是指针类型，但可以是任何引用类型或任何值类型。几乎可以将内联数组与任何 C# 数据结构一起使用。

运行时团队和其他库作者使用内联数组来提高应用的性能。内联数组使开发人员能够创建固定大小的 `struct` 类型数组。具有内联缓冲区的结构应提供类似于不安全的固定大小缓冲区的性能特征。

```csharp
var buffer = new Buffer<int>();
for (int i = 0; i < 10; i++)
    buffer[i] = i;
foreach (var i in buffer)
    Console.WriteLine(i);
```

---
### Class 

`class` 类型定义了一个数据结构，其中包含了数据成员（常量和字段）、函数成员（方法、属性、事件、索引器、运算符、实例构造函数、静态构造函数和终结器）和嵌套成员。类类型支持继承，这是一种派生类可以扩展和专门化基类的机制。

预定义的类类型在 C# 中具有特殊含义：
- `System.Object`：所有其他类型的最终基类。
- `System.String`：C# 字符串类型。
- `System.ValueType`：所有值类型的基类。
- `System.Enum`：所有枚举类型的基类。
- `System.Array`：所有数组类型的基类。
- `System.Delegate`：所有委托类型的基类。
- `System.Exception`：所有异常类型的基类。
- `System.Attribute`：所有特性类型的基类。

>---
#### Object 对象类型


`object` 类型是 `System.Object` 在 .NET 中的别名。在 C# 的统一类型系统中，所有类型（预定义类型、用户定义类型、引用类型和值类型）都是直接或间接从 `System.Object` 继承的。可以将任何类型的值赋给 `object` 类型的变量。

引用类型的值可以直接隐式转换成 `object`。值类型的值需要经过装箱操作后隐式转换为 `object`。将 `object` 类型的变量转换为值类型的过程称为拆箱。装箱是隐式的，拆箱是显式的。装箱和拆箱的概念是类型系统 C# 统一视图的基础。

```csharp
string str = "Hello World";
object obj = str;  // implicit
string s_str = (string)str;  

int num = 10010;
obj = num;      // implicit boxing
int s_num = (int)num;  // unboxing
```

>---
#### 类声明

类的声明中可以包含一组可选的 `Attribute` 特性、一组可选的类修饰符（访问修饰符，`abstract`、`static`、`sealed` 等）、分部修饰 `partial`、`class` 关键字、一个可选的类型参数列表和类型参数约束、类的标识符、类的主体。

- `public`、`protected`、`internal`、`private` 修饰符控制类类型的可访问性。在顶级类中只能使用 `public` 和 `internal`。
- `partial` 修饰符用以声明分部类。
- `abstract` 声明抽象类，`static` 声明静态类，`sealed` 声明密封类。 

```csharp
public sealed class SampleClass<T> where T : notnull
{
    // ... Members
}
```

>---
#### Abstract Class

抽象类代表抽象实体。其抽象成员定义了从抽象实体派生的对象应包含什么，抽象成员不包含实现。抽象类的大多数功能通常都没有实现。从抽象类派生的子类，必须为抽象基类的抽象方法提供实现。


`abstract` 修饰符用于指示类是不完整的，并打算作为基类。抽象类不能直接实例化为对象，但可以包含派生自抽象类的非抽象类实例的引用。

在抽象类中定义抽象方法，目的是将抽象方法的具体实现（`override`）延迟到派生类。抽象方法是没有实现的特殊虚方法。在基类中也可以声明 `virtual` 虚方法并提供缺省实现，派生类可以重写（`override`）虚方法以扩展或重新定义派生类的行为。

```csharp
interface ISample       // 接口
{
    void Debug(string message);
}
abstract class BaseSample : ISample     // 继承接口并定义抽象方法
{
    public abstract void Debug(string mess);
    public virtual void Error(string mess) => Debug(mess);
}
internal class Sample : BaseSample      // 为抽象类和接口提供方法实现
{
    public override void Debug(string mess) => Console.WriteLine(mess);
    public sealed override void Error(string mess) => base.Error("ERROR : " + mess);
}
```

>---
#### Sealed Class

`sealed` 定义密封类或密封成员，密封类防止被继承，密封成员防止被派生类重写。因此密封类不能是抽象类。这些密封类也支持运行时优化，可以将密封类对象上的虚函数成员的调用转换为非虚调用。

```csharp
using System.Text;

PointArray ps = new((0, 0), (1, 1), (2, 2));
Console.WriteLine(ps);
// Output : (0, 0), (1, 1), (2, 2)

// 定义抽象记录防止被继承
sealed record PointArray(params (int, int)[] points)
{
    // 重写 ToString 方法
    public override string ToString()
    {
        if (points.Length > 0)
        {
            StringBuilder sb = new StringBuilder(points[0].ToString());
            foreach (var p in points[1..])
                sb.Append(", " + p);
            return sb.ToString();
        }
        else return string.Empty;
    }
}
class Point3D: PointArray;  // err: 无法派生密封类
```

>---
#### Generic Class  

类的声明中可以包含若干的类型参数，和一组可选的类型参数约束。具有类型参数的构造类未指定约束时，默认约束为 `object`。声明泛型构造类的实例时，必须指定类型参数的具体类型。

```csharp
Sample<int> Si = new();
Si.Value = 99;

Sample<string> Ss = new();
Ss.Value = "Hello"; 

class Sample<T> where T : struct // T 约束为结构类型
{
    public T Value { get; set; }
}
```

>---
#### Static Class

`static` 修饰符用以声明静态类。静态类不能被实例化，它的成员必须显式地包含静态修饰符（常量和嵌套类型除外）。静态类中可以声明静态扩展方法。

静态类不能被用作类型，无法用作是基类、成员的组成类型、泛型类型参数或类型约束，也不能用于数组类型、`new()`、强制转换、模式匹配、`sizeof`、`default` 表达式等。

加载引用静态类的程序时，.NET 运行时会加载该静态类的类型信息，并在程序中首次引用类之前初始化其字段并调用其静态构造函数。静态构造函数只调用一次，在程序所驻留的应用程序域的生存期内，静态类会保留在内存中。

```csharp
public static class EnumExt
{   
    // 扩展方法
    public static T? ConvertEnum<T>(this int eVal) where T : Enum
        => (T)Enum.ToObject(typeof(T), eVal);  // int 转换为 enum
    public static bool IsDefinedByEnum<T>(this int eVal) where T : Enum
        => Enum.IsDefined(typeof(T), eVal);    // 检查 enum 是否关联整数值
}
```

>---
#### Class Members

一个类可包含的成员有：常量、字段、方法、属性、索引器、运算符、事件、终结器、实例构造函数、静态构造函数和嵌套类型（类、接口、结构、枚举、委托）。

```csharp
class MyClass
{
    // 实例构造函数
    public MyClass() { S_OnDestroy = static delegate { Console.WriteLine("MyClass Destroyed"); }; }
    // 常量
    public const string Version = "0.0.1";
    // 枚举
    public enum Day { workDay, weekDay }
    // 字段
    private readonly static MyClass s_default = new MyClass();
    // 静态属性
    public static MyClass Default => s_default;
    // 实例方法
    public Data CreateData(byte[] data, int id) => new Data(data, id);
    // 索引器
    public int this[int index] => index;
    // 运算符
    public static bool operator ==(MyClass left, MyClass right) => left.Equals(right);
    public static bool operator !=(MyClass left, MyClass right) => !left.Equals(right);
    // 委托
    delegate void OnDestroy();
    // 事件
    event OnDestroy S_OnDestroy;
    // 终结器
    ~MyClass() => S_OnDestroy?.Invoke();
    // 嵌套接口
    public interface INested { }
    // 嵌套类
    sealed class NestedClass : INested { }
    // 嵌套结构
    struct NestedStruct : INested { }
    // 记录
    public readonly record struct Data(byte[] data, int gui);
}
class Sample
{
    static void Main(string[] args)
    {
        MyClass.Data d1 = MyClass.Default.CreateData("Hello"u8.ToArray(), "Hello".GetHashCode());
    }
}
```

>---
#### 基类规范和类继承


类声明中可以包含一个 *class_base* 规范，该规范定义了类的直接基类和类直接实现的接口。若规范中只列出了接口类型，则直接基类是 `object`。C# 类仅支持单一线性继承（不能循环依赖），因此除了 `object` 每个类都仅有一个直接基类。

类从其直接基类继承成员。若直接基类是构造类型，则必须指定构造类型的类型参数（不能是直接基类类型），也可是类本身作为构造类型的类型参数。

```csharp
class Sample<T>;
class DerivedSample : Sample<int>;
class DerivedSample<U> : Sample<U>;
```

*class_base* 中可能包含接口类型的列表，类可以直接实现给定的接口类型。

```csharp
interface ISample
{
    void Fun();
}
class Sample : ISample
{
    public void Fun() => Console.WriteLine("Hello World");
}
```

类继承其直接基类的成员。继承意味着类隐式地包含其直接基类的所有成员，但基类的实例构造函数、终结器和静态构造函数除外。

继承的一些重要方面是:
- 继承是可传递的。如果 c 从 x 派生，x 派生自 A，则 c 继承 B 中声明的成员和 A 中声明的成员。
- 派生类继承其直接基类。派生类可以向其继承的成员添加新成员，但不能删除继承成员的定义。
- 实例构造函数、终结器和静态构造函数不被继承，但所有其他成员都可以继承，不管它们声明的可访问性如何。
- 派生类可以通过声明具有相同名称或签名的新成员来隐藏继承的成员。但是，隐藏继承的成员并不会删除该成员，它只是使该成员无法通过派生类直接访问。
- 类的实例包含在类及其基类中声明的所有实例字段的集合，并且存在从派生类类型到其任何基类类型的隐式转换。因此，对某个派生类实例的引用可以被视为对其任何基类实例的引用。
- 类可以声明虚方法、属性、索引器和事件，派生类可以重写这些函数成员的实现。这使类能够显示多态行为，其中函数成员调用执行的操作取决于调用该函数成员的实例的运行时类型。

---
### Dynamic

`dynamic` 类型可以引用任何对象，当运算符应用于动态类型的表达式时，操作解析被延迟到程序运行时。非法的操作应用到动态类型时，编译期间不会给出任何错误，当操作在运行时失败，将引发异常。

编译器不会对包含类型 `dynamic` 的表达式的操作进行解析或类型检查，编译器将有关该操作信息打包在一起，之后这些信息会用于在运行时求值操作，因此 `dynamic` 类型只在编译时存在，在运行时则不存在。

在大多数情况下，`dynamic` 类型与 `object` 类型的行为类似。由于 `dynamic` 和 `object` 之间存在隐式转换，两者在函数上被认为是具有相同的签名。若两者都可作为类型推断的目标类型时，类型推断的结果更倾向于 `dynamic` 而不是 `object`。

无法在动态类型上使用索引和范围运算 `dynamicObj[a..b]` 或 `dynamicObj[^a]`。

```csharp
using System;
class Program
{
    static void Main(string[] args)
    {
        ExampleClass ec = new ExampleClass();
        Console.WriteLine(ec.ExampleMethod(10));
        Console.WriteLine(ec.ExampleMethod("value"));
        /* The following line causes a compiler error because ExampleMethod takes only one argument. */
        //Console.WriteLine(ec.ExampleMethod(10, 4));

        dynamic dynamic_ec = new ExampleClass();
        Console.WriteLine(dynamic_ec.ExampleMethod(10));
        /* Because dynamic_ec is dynamic, the following call to ExampleMethod
           with two arguments does not produce an error at compile time.
           However, it does cause a run-time error. */
        //Console.WriteLine(dynamic_ec.ExampleMethod(10, 4));
    }
}
class ExampleClass
{
    static dynamic _field;
    dynamic Prop { get; set; }
    public dynamic ExampleMethod(dynamic d)
    {
        dynamic local = "Local variable";
        int two = 2;
        if (d is int)
            return local;
        else
            return two;
    }
}
// Results:
// Local variable
// 2
// Local variable
```

>---
#### CIL 中的动态类型

在 CIL 中，`dynamic` 类型实际上是一个 `System.Object`，当没有任何调用时，它的声明和 `object` 没有任何区别。为调用成员，编译器要声明 `System.Runtime.CompilerServices.CallSite<T>` 类型的一个变量，`T` 视成员签名而变化。

如 `ToString()` 这样的调用，也需实例化 `CallSite<Func<CallSite,object,string>>` 类型。另外还会动态定义一个方法，该方法可通过参数 `CallSite site`，`object dynamicTarget` 和 `string result` 进行调用。其中，`site` 是调用点本身。 `dynamicTarget` 是要在上面调用方法的 `object`，而 `result` 是 `ToString()` 方法调用的基础类型的返回值。注意不是直接实例化 `CallSite<Func<CallSite _site, object dynamicTarget, string result>>`，而是通过一个 `Create()` 工厂方法来实例化它。这个方法接受一个 `Microsoft.CSharp.RuntimeBinder.CSharpConvertBinder` 类型的参数。在得到 `CallSite<T>` 的一个实例后，最后一步是调用 `CallSite<T>.Target()` 来调用实际的成员。

在执行时，框架会在底层用反射来查找成员并验证签名是否匹配。然后，CLR 生成一个表达式树，它代表由调用点定义的动态表达式。表达式树编译好后，就得到了和本来应由编译器生成的结果相似的 CIL。这些 CIL 代码在调用点缓存下来，并通过一个委托调用来实际地触发调用。由于 CIL 现已缓存于调用点，所以后续调用不会再产生反射和编译的开销。

> C# 调用

```csharp
class Sample
{
    static void Main(string[] args)
    {
        dynamic dy = 0;
        string str = dy.ToString();
    }
}
```

> CIL To C#

```csharp
internal class Sample
{
	[CompilerGenerated]
	private static class <>o__0   // 生成一个动态绑定关联对象
	{
		public static CallSite<Func<CallSite, object, object>> <>p__0;
		public static CallSite<Func<CallSite, object, string>> <>p__1;
	}

	[System.Runtime.CompilerServices.NullableContext(1)]
	private static void Main(string[] args)
	{
		object dy = 0;   // 被视为 `object` 的 `dynamic dy = 0;`
		if (<>o__0.<>p__1 == null)
		{
			<>o__0.<>p__1 = CallSite<Func<CallSite, object, string>>
                .Create(Binder.Convert(CSharpBinderFlags.None, typeof(string), typeof(Sample)));
		}
		Func<CallSite, object, string> target = <>o__0.<>p__1.Target;
		CallSite<Func<CallSite, object, string>> <>p__ = <>o__0.<>p__1;
		if (<>o__0.<>p__0 == null)
		{
			<>o__0.<>p__0 = CallSite<Func<CallSite, object, object>>
            .Create(Binder.InvokeMember(CSharpBinderFlags.None, "ToString", null, typeof(Sample), 
                    new CSharpArgumentInfo[1] { CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, null) }));
		}
		string str = target(<>p__, <>o__0.<>p__0.Target(<>o__0.<>p__0, dy));  // 调用 CallSite<T>.Target
	}
}
```

---
### String

`string` 类型是直接从 `object` 继承的密封类类型，它的实例表示一段 Unicode 字符序列。`string` 是预定义类 `System.String` 的别名。相等运算符 `==` 和 `!=` 用以比较 `string` 对象的值，而不是比较 `string` 对象的引用。

```csharp
string str1 = "hello";
string str2 = "h";
str2 += "ello";
Console.WriteLine(str1 == str2);  // true
Console.WriteLine(object.ReferenceEquals(str1, str2)); // false
```

`+` 用于拼接两个字符串片段。字符串是不可变的，每次赋值时，编译器实际上会创建一个新的字符串对象来保存新的字符序列，并将新对象赋值给目标，并将之前的内存用于垃圾回收。

```csharp
string str = "Hello " + "World!";
```

`[]` 运算符可用于访问字符串字符序列中的指定索引位置的字符。

```csharp
string str = "test";
for (int i = 0; i < str.Length; i++)
  Console.Write(str[i] + " ");
// Output: t e s t
```

>---
#### 内插字符串

`$` 字符将字符串字面量标识为内插字符串，内插字符串是可能包含内插表达式的字符串文本。将内插字符串解析为结果字符串时，带有内插表达式的项会替换为表达式结果的字符串表示形式。大括号转义序列（`{{` 和 `}}`）表示为 `{` 和 `}` 的字符串形式。

```csharp
$"{<interpolationExpression>[,<alignment>][:<formatString>]}"
// - interpolationExpression     生成需要设置格式的结果的表达式
// - alignment                   常数表达式，定义对齐方式和最小字符宽度，负值表示左对齐，正值表示右对齐
// - formatString                受表达式结果类型支持的格式字符串，例如 DateTime 格式化输出

Console.WriteLine($"|{"Left",-7}|{"Right",7}|");
// |Left   |  Right|

const int FieldWidthRightAligned = 20;      // $"{{" 打印 {
Console.WriteLine($"{{{Math.PI,FieldWidthRightAligned}}} - default formatting of the pi number");
Console.WriteLine($"{{{Math.PI,FieldWidthRightAligned:F3}}} - display only three decimal digits of the pi number");
//{   3.141592653589793} - default formatting of the pi number
//{               3.142} - display only three decimal digits of the pi number

string message = $"The usage policy for {safetyScore} is {
    safetyScore switch
    {
        > 90 => "Unlimited usage",
        > 80 => "General usage, with daily safety check",
        > 70 => "Issues must be addressed within 1 week",
        > 50 => "Issues must be addressed within 1 day",
        _ => "Issues must be addressed before continued use",
    }}";
```

内插字符串初始化常量时，所有的内插表达式也必须是常量字符串。

```csharp
public class Sample
{
    const string S1 = $"Hello world";
    const string S2 = $"Hello{" "}World";
    const string S3 = $"{S1} Kevin, welcome to the team!";
}
```

C# 11 起内插表达式支持使用换行，以使表达式更具有可读性。

```csharp
var v = $"Count is\t: {this.Is.A.Really(long(expr))
                            .That.I.Should(
                                be + able)[
                                    to.Wrap()]}.";
```

>---
#### 逐字字符串

`@` 指示将原义解释字符串。简单转义序列（如代表反斜杠的 `"\\"`）、十六进制转义序列（如代表大写字母 A 的 `"\x0041"`）和 Unicode 转义序列（如代表大写字母 A 的 `"\u0041"`）都将按字面解释。引号转义 `""` 不会按字面解释。

逐字内插字符串中，大括号转义序列（`{{` 和 `}}`）不按字面解释。

```csharp
string filename1 = @"c:\documents\files\u0066.txt";
string filename2 = "c:\\documents\\files\\u0066.txt";
Console.WriteLine(filename1);
Console.WriteLine(filename2);
// The example displays the following output:
//     c:\documents\files\u0066.txt
//     c:\documents\files\u0066.txt

string str = $@"{{{Math.PI,20}}} >> ""default formatting of the pi number""";
Console.WriteLine(str);
//{   3.141592653589793} >> "default formatting of the pi number"
```

>---
#### 原始字符串

原始字符串字面量从 C# 11 开始可用。字符串字面量可以包含任意文本，而无需转义序列，字符串字面量可以包括空格和新行、嵌入引号以及其他特殊字符。原始字符串字面量用至少三个双引号（`"""`）的分隔符括起来。

```csharp
var message = """
This is a multi-line
    string literal with the second line indented.
""";
// 原始字符串的起始、结束引导序列长度要超过字符串中最长的引号序列长度
"""""
This raw string literal has four """", count them: """" four!
embedded quote characters in a sequence. That's why it starts and ends
with five double quotes.

You could extend this example with as many embedded quotes as needed for your text.
"""""
```

原始字符串支持单行形式，分隔符和字符串内容在同一行。单行形式不参与行首空格缩进。

```csharp
var str = """This is a single line""";
```

多行原始字符串的字面量分隔符必须位于自己的行，末尾分隔符的右侧决定了原始字符串的行缩进。

```csharp
var str = """
    This is a multi-line
        string literal with the second line indented.
""";
Console.WriteLine(str);
/* output
    This is a multi-line
        string literal with the second line indented.
| <--- 行缩进位置
*/

var str2 = """
    This is a multi-line
        string literal with the second line indented.
    """;
/* output
This is a multi-line
    string literal with the second line indented.
| <--- 行缩进位置
*/
```

原始字符串也支持内插表达式，字符串指定开始插值所需的大括号数目（由开头的内插字符 `$` 数目决定），任何少于这个数的大括号序列都被视为字符串内容。

```csharp
string value = "text";
var str =
    $$"""
    {
        "Summary": {{value}},
        "length": {{value.Length}}
    }
    """;
string value2 = $$"""{{
    1
    + 2
    + 3}}""";  // 被视为单行原始字符串
```

>---
####  UTF-8 字符串

.NET 中的字符串是使用 UTF-16 编码存储的。UTF-8 是 Web 协议和其他重要库的标准。从 C# 11 开始，可以将 `u8` 后缀添加到字符串以指定 UTF-8 编码。UTF-8 字符串存储为 `ReadOnlySpan<byte>` 对象，两个 `UTF-8` 字符串之间可以拼接。UTF-8 字符串不支持字符串内插，但可以是 `@` 逐字字符串。

```csharp
using System.Text;

// u8 to u16
ReadOnlySpan<byte> strU8 = @"Hello world!"u8;
string strU16 = Encoding.UTF8.GetString(strU8);
Console.WriteLine(strU16);

// u16 to u8
string str = "Hello world!";
ReadOnlySpan<byte> bytes = Encoding.UTF8.GetBytes(str);

// u8 + u8
ReadOnlySpan<byte> str1 = "Hello"u8 + " World"u8;
```

---
### Interface

`interface` 定义了一个协议，实现接口的类型必须遵循它的协议。一个接口可以继承多个基接口，一个类或结构可以实现多个接口。

接口类型可以包含方法、属性、事件、索引器，也可以包含静态构造函数、静态成员、常量、运算符、嵌套类型等，这些成员默认的可访问性是 `public`。

```csharp
interface ISample
{
    // 实例成员
    void FunA();
    int Value { get; set; }
    event Action MEvent;
    int this[int index] { get; set; }

    // 静态成员
    static ISample() { Console.WriteLine("Static ISample"); }
    static int GUI => 10010;
    static Action StaticEvent;
    const string TypeName = nameof(ISample);
    static ISample operator ++(ISample s)
    {
        s.Value++;
        return s;
    }

    // 嵌套类型
    delegate void OnInvoke();
    class Nested;
    interface INestedSample;
}
class Sample : ISample
{
    public int this[int index] { get => throw new NotImplementedException(); set => throw new NotImplementedException(); }
    public int Value { get => throw new NotImplementedException(); set => throw new NotImplementedException(); }
    public event Action MEvent;
    public void FunA() => throw new NotImplementedException();
}
```

类的属性和索引器可以为接口中定义的属性或索引器定义额外的访问器。若接口属性或索引器使用显式接口实现而不是派生类型隐式实现时，访问器必须匹配。

```csharp
interface ISample
{
    int Value { get; }
    string Name { get; }
}
class Sample : ISample
{
    public int Value { get; set; }  // 额外的 set 访问器
    string ISample.Name { get; /* set; // err */ }
}
```

#### 1.5.1. 隐式实现与显式接口实现

类或结构应提供继承接口中未实现成员的实现定义，在实现类或结构中定位接口成员的实现的过程称为接口映射。可以以隐式或显式接口方式实现继承的接口成员。隐式实现的成员只能声明为 `public` 且无法修改访问修饰符，但可以声明为 `abstract` 或 `virtual`。显式接口实现的方法无法添加访问修饰符或 `abstract`、`virtual`、`sealed`。

```csharp
interface ISample
{
    void FunA();
    void FunB();
}
class Sample : ISample
{
    public virtual void FunA() { /* ... */ }  // 隐式实现，添加 virtual
    async void ISample.FunB() { /* ... */ }  // 显式接口实现，声明为异步方法
}
```

若当接口方法映射到类中的虚方法（使用隐式实现）时，派生类则可能重写虚方法并更改接口的实现和映射关系。

```csharp
interface ISample
{
    void Fun();
}
class Sample  : ISample
{
    public virtual void Fun() => Console.WriteLine("Sample Fun");
}
class Derived : Sample
{
    public override void Fun() => Console.WriteLine("Derived Fun");
    static void Main(string[] args)
    {
        Sample s = new Sample();
        Derived d = new Derived();
        ISample Is = s;
        ISample Id = d;
        s.Fun();    // Sample Fun
        d.Fun();    // Derived Fun
        Is.Fun();   // Sample Fun
        Id.Fun();   // Derived Fun
    }
}
```

对于多继承接口，当两个或多个不相关的基接口声明具有相同名称或签名的成员时，可能会出现歧义。

```csharp
interface ICounter
{
    void Count(int c);
    int Value { get; set; }
    void Fun();
}
interface IList
{
    int Count { get; set; }
    int Value { get; set; }
    void Fun();
}
interface IListCounter : ICounter, IList;

class Sample
{
    public void Test(IListCounter x)
    {
        x.Value = 100;  // 歧义
        x.Fun();        // 歧义

        x.Count(1);
        x.Count = 1;   // 被隐藏，
        ((IList)x).Count = 1;
        ((ICounter)x).Count(1);
    }
}
```

为消除接口之间的歧义，类或接口可以声明显式接口成员实现，用以调用限定于接口的成员。类或结构的显式接口实现不包含任何修饰符，它不作为实现类型的成员，只能通过接口实例调用。

```csharp
Sample logger = new Sample();
string mess = "Hello World";
logger.Print(mess);
((IDebug)logger).Print(mess);
((IError)logger).Print(mess);
/* Output
 Hello World
 DEBUG : Hello World
 ERROR : Hello World
*/

interface IDebug{
    void Print(string mess);
}
interface IError{
    void Print(string mess);
}
class Sample : IDebug, IError
{
    // 显式接口实现
    void IDebug.Print(string mess) => Console.WriteLine("DEBUG : " + mess);
    void IError.Print(string mess) => Console.WriteLine("ERROR : " + mess);
    // 默认实现
    public void Print(string mess) => Console.WriteLine(mess);
}
```

若接口函数成员具有一个参数数组，末位排序的参数数组在派生类型中实现时可以在类或结构中可选地附加 `params` 修饰。若接口方法的参数是一个数组，隐式实现时可选地附加 `params` 修饰，显式接口实现时不能附加。

```csharp
interface ISample
{
    void Fun(params int[] arr);
    void FunB(int[] arr);
}
class Sample : ISample
{
    public void Fun(params int[] arr) { }  // 默认实现
    public void FunB(params int[] arr) { }

    // or
    void ISample.Fun(params int[] arr) { }     // 显式接口实现
    void ISample.FunB(int[] arr) { }
}
```

> 显式接口实现的目的

- 由于显式接口成员不能通过类或结构实例访问，因此它们允许将接口实现排除在类或结构的公共接口之外。
- 显式接口成员实现允许消除具有相同签名成员的歧义。若没有显式接口成员实现，类和结构就不可能具有相同签名和返回类型的接口成员的不同实现。


#### 1.5.2. 接口成员默认实现

一般而言，接口不提供其成员的实现，仅用来指定实现接口的类或结构应提供实现的成员。接口可为成员定义默认实现，以便提供常见功能的默认实现。接口成员中提供的默认实现等效于派生类型中的显式接口实现，只能通过接口实例进行访问。

```csharp
interface ISample
{
    void FunA();
    void FunB() => Console.WriteLine("ISample.FunB");  // 默认实现的接口方法
}
class Sample : ISample
{
    public void FunA() => Console.WriteLine("Sample.FunA");
    static void Main(string[] args)
    {
        Sample s = new Sample();
        s.FunA();       // Sample.FunA

        ISample s2 = s; 
        s2.FunA();      // Sample.FunA
        s2.FunB();      // ISample.FunB
        // 接口实例访问显式实现的成员
    }
}
```

具有默认实现的接口方法不要求其派生类型显式接口重定义，接口实现类型可以重定义具有默认实现（非 `sealed` 或 `private`）的接口成员，以改变派生继承的接口映射关系：
- 派生接口只能通过显式接口方式重写基接口方法，可以将基接口方法重新声明为抽象 `abstract`。
- 派生类型可以通过显式接口方式或隐式方式实现继承的接口方法，并改变派生类型与基接口的映射关系。

```csharp
interface ISampleA
{
    void FunA();
    void FunB() => Console.WriteLine("ISample.FunB");  // 默认实现的接口方法
}
interface ISampleB : ISampleA
{
    abstract void ISampleA.FunB();   // 重新声明为 abstract
}
class Sample : ISampleA, ISampleB
{
    public void FunA() => Console.WriteLine("Sample.FunA From ISampleA");
    public void FunB() => Console.WriteLine("Sample.FunB From ISampleB");  
    // 覆盖继承的接口映射, 可以是隐式或显式实现
    static void Main(string[] args)
    {
        Sample s = new Sample();
        s.FunA();       // Sample.FunA From ISampleA

        ISampleA s2 = s;
        s2.FunA();      // Sample.FunA From ISampleA
        s2.FunB();      // Sample.FunB From ISampleB

        ISampleB s3 = s;
        s3.FunA();      // Sample.FunA From ISampleA
        s3.FunB();      // Sample.FunB From ISampleB
    }
}
```

没有默认实现的接口成员是隐式公共抽象的，可以显式指定可访问性修饰符。其中 `private`、`virtual`、`sealed` 修饰的成员必须有默认实现。具有默认实现的非私有成员，是隐式 `virtual` 的，可以显式指定为 `virtual`。声明为 `sealed` 的接口成员无法被派生接口或派生类型通过显式接口重定义的方式改变从基接口继承的接口映射关系，即使是在派生类或接口中使用隐式方式实现，但是可以在派生接口中使用 `new` 隐藏继承的成员。

```csharp
interface ISampleA
{
    void FunA();
    private void FunInline() => Console.WriteLine("ISampleA.FunInline");
    sealed void FunB() => Console.WriteLine("ISampleA.FunB");  // 默认实现的接口方法
    virtual void FunC() => FunInline();  // virtual,sealed,private 方法需要有方法主体
}
interface ISampleB : ISampleA
{
    //void ISampleA.FunB() { }   // err, 无法通过显式实现改变继承的接口映射
    new void FunB();  // new 隐藏 ISampleA.FunB 并成为 ISampleB 的成员
}
class Sample : ISampleA, ISampleB
{
    public void FunA() => Console.WriteLine("Sample.FunA From ISampleA");
    public void FunB() => Console.WriteLine("Sample.FunB From ISampleB");
    static void Main(string[] args)
    {
        Sample s = new Sample();
        s.FunA();       // Sample.FunA From ISampleA

        ISampleA s2 = s;
        s2.FunA();      // Sample.FunA From ISampleA
        s2.FunB();      // ISampleA.FunB     
        s2.FunC();      // ISampleA.FunInline

        ISampleB s3 = s;
        s3.FunA();      // Sample.FunA From ISampleA
        s3.FunB();      // Sample.FunB From ISampleB
        s3.FunC();      // ISampleA.FunInline
    }
}
```

密封或私有的接口方法无法在派生中通过显式接口实现的方式进行重定义以改变从基接口继承的接口映射。即使在派生类型中声明为 `public` 方法，也无法覆盖继承的接口映射关系。接口的 `private` 方法是隐式密封的。

```csharp
interface ISample
{
    private void Fun(int a) => Console.WriteLine($"ISample.Fun({a})");
    // private >> protected 或其他访问修饰符
    // protected void Fun(int a) => Console.WriteLine($"ISample.Fun({a})");  // Output: Sample.Fun(10)
    sealed void Output(int a)
    {
        Console.Write("ISample.Output : ");
        Fun(a);
    }
}
class Sample : ISample
{
    public void Fun(int a) => Console.WriteLine($"Sample.Fun({a})");
    public void Output(int a)
    {
        Console.Write("Sample.Output : ");
        Fun(a);
    }
    static void Main(string[] args)
    {
        Sample s = new Sample();
        s.Output(10010);  // Sample.Output : Sample.Fun(10010)  // 无法改变接口映射

        ISample sample = s;
        sample.Output(10010);  // ISample.Output : ISample.Fun(10010)
    }
}
```

#### 1.5.3. 泛型方法的实现

当泛型方法隐式实现接口方法时，为每个方法类型参数给出的约束在两个声明中应该是等效的（在任何接口类型参数被适当的类型参数替换之后），其中方法类型参数由从左到右的顺序位置标识。隐式实现的方法必须显式指定约束（类型参数是 `object` 的约束不需要显式指定约束），而显式接口实现的方法隐式继承类型参数约束，不能显式声明约束。当隐式实现的约束声明不合法时，只能通过显式方式实现接口成员。

```csharp
interface ISample<X, Y, Z>
{
    void FunA<T>(T t) where T : X?;
    void FunB<T>(T t) where T : Y;
    void FunC<T>(T t) where T : Z;
}

class C : ISample<object, C, string>
{
    public void FunA<T>(T t) { }                  // Ok，`FunA` 不需要指定 `where T:object` 约束，因为 `object` 是所有类型参数的隐式约束。
    public void FunB<T>(T t) where T : C { }      // Ok，`FunB` 指定的约束和接口中的约束匹配
//  public void FunC<T>(T t) where T : string { } // Error，只能显式接口实现
    void ISample<object, C, string>.FunC<T>(T t) { }
}
```

#### 1.5.4. 接口重实现

在类中显式方式实现的接口无法在派生类中重写接口映射，除非在子类中添加接口到 *class_base* 以进行接口的重实现。派生类的隐式或显式重实现的接口成员将覆盖从基类继承的接口映射关系。

```csharp
interface ISample
{
    void Fun();
}
class Sample : ISample
{
    void ISample.Fun() => Console.WriteLine("Sample Fun");
}
class Derived : Sample, ISample
{
    public void Fun() => Console.WriteLine("Derived Fun");  // 接口重新映射
    static void Main(string[] args)
    {
        Sample s = new Sample();
        Sample sd = new Derived();
        Derived d = new Derived();
        ISample Is = s;
        ISample Isd = sd;
        ISample Id = d;
        Is.Fun();   // Sample Fun
        Isd.Fun();  // Derived Fun
        Id.Fun();   // Derived Fun
    }
}
```

#### 1.5.5. 抽象类与接口

与非抽象类一样，抽象类应提供在类的基类列表中列出的所有接口成员的实现。但是，允许抽象类将接口方法映射到抽象方法上。显式接口实现的成员不能是抽象的。

```csharp
interface ISample
{
    void Fun();
    int Value { get; }
}
abstract class AbSample : ISample
{
    public abstract int Value { get; }
    void ISample.Fun() => Console.WriteLine(Value);
}
```

#### 1.5.6. 接口的静态抽象和虚拟成员

从 C#11 开始，接口可以声明除静态字段之外的所有静态成员类型的 `static abstract` 和 `static virtual` 成员。

```csharp
interface ISample
{
    static abstract void Func();
    static abstract event Action E;
    static abstract object Proper { get; set; }
}
interface ISample<T> where T : ISample<T>
{
    static abstract void Func();
    static abstract event Action E;
    static abstract T P { get; set; }
    static abstract object Proper { get; set; }
    static abstract T operator +(T l, T r);
    static abstract bool operator ==(T l, T r);
    static abstract bool operator !=(T l, T r);
    static abstract implicit operator T(string s);
    static abstract explicit operator string(T t);
}
```

接口指定静态抽象成员，然后要求类和结构为接口抽象静态成员提供显式或隐式实现，静态虚成员具有默认实现。显式实现的接口静态 `abstract` 或 `virtual` 成员只能从受接口约束的类型参数上访问，隐式实现的接口静态 `abstract` 或 `virtual` 成员可以通过派生类型直接访问。

```csharp
interface ISample
{
    static abstract void FunA();
    static abstract void FunB();
    static virtual void FunC() => Console.WriteLine("Static ISample.FunC");
}
class Sample : ISample
{
    public static void FunA() => Console.WriteLine("Static Sample.FunA");
    static  void ISample.FunB() => Console.WriteLine("Sample: Static ISample.FunB");
    static void Main(string[] args)
    {
        // 派生类直接访问
        Sample.FunA();   // Static Sample.FunA

        Test<Sample>();
    }
    static void Test<T>() where T : ISample
    {
        // 通过类型参数访问接口成员
        T.FunA();    // Static Sample.FunA
        T.FunB();    // Sample: Static ISample.FunB
        T.FunC();    // Static ISample.FunC
    }

    // public static void FunC() => Console.WriteLine("Static Sample.FunC");  // 隐式重定义
    // Test<Sample>: T.FunC();   // Static Sample.FunC
    // Sample.FunC();   // 隐式方式实现的静态虚成员可以直接通过派生类型访问
}
```

派生接口同样可以重新定义从基接口继承静态抽象或静态虚成员。

```csharp
interface ISample
{
    static abstract void FunA();
    static abstract void FunB();
    static virtual void FunC() => Console.WriteLine("Static ISample.FunC");
}
interface IDerivedSample: ISample
{
    static void ISample.FunA() => Console.WriteLine("IDerivedSample : Static ISample.FunA");  // 接口重定义
    static abstract void ISample.FunC();  // 重新定义为 static abstract
}
```

接口中声明的 `static virtual` 和 `static abstract` 方法没有类似于类中声明的 `virtual` 或 `abstract` 方法的运行时调度机制。相反，编译器使用编译时可用的类型信息，即调用基（编译时）类型的静态方法。`static virtual` 和 `static abstract` 方法几乎完全是在泛型接口中声明的。

```csharp
interface ISample<T> where T : ISample<T>, new()
{
    static virtual void Fun() { }
    static virtual T Value { get; } = new T();
    static abstract event Action E;
    static abstract T operator ++(T t);
}

struct Sample : ISample<Sample>
{
    public int Value { get; set; } = 0;
    public Sample(int value)
    {
        this.Value = value;
    }
    static void ISample<Sample>.Fun() { }  // 显式重定义
    public static event Action E;  // 隐式实现

    // 显式实现，无法从 Sample 访问, 只能通过类型参数访问
    static Sample ISample<Sample>.operator ++(Sample s)
    {
        s.Value++;
        return s;
    }
    static void Main(string[] args)
    {
        Sample s = new Sample(99);
        s.Increment(ref s);
        Console.WriteLine(s.Value);  // 100
    }
    void Increment<T> (ref T t) where T : ISample<T>,new()
    {
        t++;  // 类型参数访问
    }
}
```

对于与非虚实例成员的对称，静态非字段成员允许使用可选的 `sealed` 修饰符，即使它们默认是非虚的：

```csharp
interface ISample
{
    static sealed void M() => Console.WriteLine("Default behavior");

    static int f = 0;
    static sealed int P1 { get; set; }
    static sealed int P2 { get => f; set => f = value; }

    static sealed event Action E1;
    static sealed event Action E2 { add => E1 += value; remove => E1 -= value; }
    static sealed ISample operator +(ISample l, ISample r) => l;
}
```

---
### 语句

#### 声明语句

声明语句声明新的局部变量、局部常量或 `ref` 局部变量。 

```csharp
void Sample()
{
    int a, b;        // 仅声明
    int c = 1;       // 声明并初始化
    var arr = new[] { 1, 2, 3, 4, 5 };    // 隐式类型声明
    const string greeting = "Hello";      // 常量声明
    ref int r_num = ref c;
}
```

>---
#### 空语句

当在需要语句的上下文中不需要执行任何操作时，使用空语句（`;`）。执行空语句只是将控制转移到语句的结束点。

```csharp
while (condition)
    ;
```

>---
#### if-else

`if`、`if-else`、`if-else if` 语句根据布尔表达式的结果选择要遵循的若干代码路径的哪一个。

```csharp
string scan = Console.ReadLine();

if (scan is null)
    Console.WriteLine("Input NULL");
else if (scan is "")
    Console.WriteLine("Input Empty");
else Console.WriteLine(scan);
```

>---
#### switch

`switch` 语句根据与匹配表达式匹配的模式来选择要执行的语句列表。可以为 `switch` 语句的一部分指定多个 `case` 模式；`default` 模式始终匹配成功，最多只有一个 `default` 子句。

在 `switch` 语句中无法贯穿，但可以并列多个 case，可以使用跳转语句从 `switch` 跳出或转移其他分支。可以在 `case` 模式中使用 `when` 筛选。

```csharp
switch (a)
{
    case > 0 when a < 10:
        Console.WriteLine("0 < a < 10");
        break;
    case > 10:
    case  < -10:
        break;
    case 0:
        Console.WriteLine($"a == {a}");
        break;
    case 5:
    case -5:
        goto case 0;  // 仅 case 常量
    default:
        break;
}
```

在 `switch` 语句块中声明的局部变量不考虑它在哪个分支，它们属于同一名称空间和作用域。例如，`int y` 尽管声明出现在 `case 0` 段中，但对于默认情况，局部变量 `y` 在 `switch` 某 `case` 或 `default` 段中的作用域内。

```csharp
int x = 1;
switch (x)
{
    case 0:
        int y;
        break;
    default:
        y = 10;
        Console.WriteLine(x + y);
        break;
}
```

>---
####  for

```csharp
for( 初始化表达式; 条件表达式; 迭代器)
{ 
    循环体 
} 
```

“初始化表达式” 部分仅在进入循环前执行一次，并根据条件表达式确定是否进入循环体。“迭代器” 在每次循环体执行后执行一次。`for` 语句的每部分都是可选的：`for(;;)` 相当于 `while(true)`。

```csharp
for (int i = 0; i < 10; i++)
    Console.WriteLine(i);
```

>---
#### foreach

`foreach(var t in ts)` 语句为类型实例中实现 `System.Collections.IEnumerable` 或 `System.Collections.Generic.IEnumerable<T>` 接口的每个元素执行循环体。

```csharp
var fibNumbers = new List<int> { 0, 1, 1, 2, 3, 5, 8, 13 };
foreach (int element in fibNumbers)
{
    Console.Write($"{element} ");
}
// Output:
// 0 1 1 2 3 5 8 13
```

除了这些类型，迭代对象可以是其类型具有公共无参数 `GetEnumerator` 方法（从 C# 9 开始，`GetEnumerator` 方法可以是类型的扩展方法），`GetEnumerator` 方法的返回类型具有公共 `Current` 属性（可以有 `ref` 修饰，返回迭代变量）和公共无参 `bool MoveNext()` 方法。

```csharp
NumArray arr = new NumArray(1, 2, 3, 4, 5, 6, 7, 8, 9);
foreach (int i in arr)
    Console.WriteLine(i);

record struct NumArray(params int[] nums)
{
    public IEnumerator<int> GetEnumerator() => nums.ToList().GetEnumerator();
}
```

若枚举器的 `Current` 属性返回 `ref Current` 则可以使用 `ref` 或 `ref readonly` 修饰声明迭代变量。

```csharp
Span<int> storage = stackalloc int[10];
int num = 0;
foreach (ref int item in storage)
    item = num++;
foreach (ref readonly var item in storage)
    Console.Write($"{item} ");
// Output:
// 0 1 2 3 4 5 6 7 8 9
```

定义一个集合类型 `C`、枚举器类型 `E` 和迭代类型 `T`、`ref T` 或 `ref readonly T`，组成一个 `foreach` 语句的形式 `foreach (V v in x) { embedded_statement }`，迭代器的行为类似于：

```csharp
{
    E e = ((C)(x)).GetEnumerator();
    try
    {
        while(e.MoveNext())
        {
            V v = (V)(T)e.Current;
            embedded_statement; 
        }
    }finally
    {
        if(e is IDisposable d)
            d.Dispose();
    }
}
```

`foreach` 语句在编译时，首先确定表达式的集合类型、枚举器类型和迭代元素类型。

对于 `foreach(var t in expr)`：
- 如果表达式 `expr` 的类型 `X` 是数组类型，则可以隐式转换为 `IEnumerable` 接口。`foreach` 语句编译时确定集合类型 `IEnumerable`，枚举器类型是 `IEnumerator`，迭代元素类型是 `X`。
+ 如果表达式 `expr` 是动态表达式，且可以推断表达式的结果可以隐式转换到 `IEnumerable` 接口。那么编译时确定集合类型是 `IEnumerable`，枚举器类型是 `IEnumerator`，迭代元素类型是 `dynamic` 或 `object` 类型。
- 否则，将判断表达式的结果类型 `X` 是否具有合适的 `GetEnumerator` 方法：
  - 首先在没有类型参数的 `X` 类型中查找对标识符为 `GetEnumerator` 的公共非静态方法成员。`GetEnumerator` 方法不含有任何参数，返回类型 `E` 应该是一个类、结构或接口类型。
  - 接下来在 `E` 上查找是否具有 `Current` 的公共非静态的属性。
  - 接下来在 `E` 上查找是否具有 `MoveNext` 的公共非静态的返回 `bool` 类型的方法。
  - 当满足上述所有查找条件时，该 `X` 是一个可枚举对象。`foreach` 语句编译时确定集合类型是 `X`，枚举器类型是 `E`，迭代元素类型是 `E.Current` 的属性类型。
  - 查找过程中当不满足任意步骤的查找条件时，则进行下一步判断。
+ 检查是否有可枚举接口：
  - 如果在所有类型 `Ti` 中存在从 `X` 到 `IEnumerable<Ti>` 的隐式转换，则存在一个唯一类型 `T`，使得 `T` 不是动态类型，并且对于所有其他类型 `Ti` 存在从 `IEnumerable<T>` 到 `IEnumerable<Ti>` 的隐式转换，则集合类型为接口 `IEnumerable<T>`，枚举类型为接口 `IEnumerator<T>`，迭代元素类型为 `T`。
  - 否则，如果有多个这样的类型 `T`，则产生一个错误，并且不采取进一步的步骤。
  - 否则，如果存在从 `X` 到 `IEnumerable` 接口的隐式转换。那么集合类型就是  `IEnumerable`，枚举类型就是 `IEnumerator`，元素类型为 `object`。
- 否则，将判断表达式的结果类型 `X` 是否具有合适的 `GetEnumerator` 扩展方法，且它的返回类型 `E` 包含符合迭代器规则的 `Current` 和 `MoveNext` 成员。`foreach` 语句编译时确定集合类型是 `X`，枚举器类型是 `E`，迭代元素类型是 `E.Current` 的属性类型。
+ 否则，将产生一个错误，并且不采取进一步的步骤。

```csharp
class Sample(int[] arr)
{
    int[] arr = arr;

    public SampleEnumerator GetEnumerator()
    {
        return new SampleEnumerator(this);
    }
    static void Main(string[] args)
    {
        Sample s = new Sample(new int[] { 1, 2, 3, 4, 5, 6 });

        foreach (var item in s)
        {
            Console.WriteLine(item);
        }
    }
    public class SampleEnumerator
    {
        private Sample sample;
        private int index = -1;
        public SampleEnumerator(Sample sample) => this.sample = sample;
        public int Current => sample.arr[index];
        public bool MoveNext() => (++index) < sample.arr.Length;
    }
}
```

> `foreach` 语句解析

- `foreach` 语句可扩展为使用 `IEnumerable` 和 `IEnumerator` 接口的标准用语，以便循环访问集合中的所有元素。

```csharp
// 原始 foreach 结构
IEnumerable collection = new int[] { 10, 20, 30, 40, 50 };
foreach (var item in collection)
    Console.WriteLine(item.ToString());

// 编译器转化类似于
IEnumerator? _enumerator = collection.GetEnumerator();
while (_enumerator.MoveNext())
{
    var item = _enumerator.Current;
    Console.WriteLine(item.ToString());
}

// 编译器完整编译
var enumerator = collection.GetEnumerator();
try
{
    while (enumerator.MoveNext())
    {
        var item = enumerator.Current;
        // do with item
        Console.WriteLine(item.ToString());
    }
}
finally
{
    // dispose of enumerator.
    (enumerator as IDisposable)?.Dispose();
}
```

>---
#### await foreach

C# 支持迭代器方法和异步方法，但不支持同时是迭代器和异步方法的方法。可以使用 `await foreach` 语句以支持异步数据流，这种迭代器返回 `IAsyncEnumerable<T>` 或 `IAsyncEnumerator<T>` 而不是 `IEnumerable<T>` 或 `IEnumerator<T>`。`IAsyncDisposable` 接口用于启用异步清理。

可以将 `await foreach` 语句与类型具有公共无参 `GetAsyncEnumerator` 方法且该方法的返回类型具有公共 `Current` 属性和公共无参数 `ValueTask<bool> MoveNextAsync` 方法的实例一起使用。异步检索下一个元素时，可能会挂起循环的每次迭代。

对于 `await foreach` 的编译时处理，等同于 `foreach` 的编译时处理。查找成元时，`GetEnumerator` 替换为 `GetAsyncEnumerator`，`bool MoveNext` 替换为 `TaskType<bool> MoveNextAsync`，`T Current` 替换为 `TaskType Current`。 

```csharp
namespace System.Collections.Generic
{
    public interface IAsyncEnumerable<out T>
    {
        IAsyncEnumerator<T> GetAsyncEnumerator(CancellationToken cancellationToken = default);
    }

    public interface IAsyncEnumerator<out T> : IAsyncDisposable
    {
        ValueTask<bool> MoveNextAsync();
        T Current { get; }
    }
}
```

`await foreach` 可以被视为：
 
```csharp
await foreach(var task in asyncEnumerable)
{
    use(task);
}
// >>>>> 
{
    IAsyncEnumerator<T> asyncEnumerator = asyncEnumerable.GetAsyncEnumerator();
    try
    {
        while (await asyncEnumerator.MoveNextAsync())
        {
            Use(asyncEnumerator.Current);
        }
    }
    finally { await ((System.IAsyncDisposable)asyncEnumerator).DisposeAsync(); }
}
```

异步迭代流 `IAsyncEnumerable<T>`：

```csharp
await foreach (int n in GenerateNumbersAsync(5))
{
    Console.Write(n);
    Console.Write(" ");
}
// Output: 0 2 4 6 8
async IAsyncEnumerable<int> GenerateNumbersAsync(int count)
{
    for (int i = 0; i < count; i++)
        yield return await ProduceNumberAsync(i);
}
async Task<int> ProduceNumberAsync(int seed)
{
    await Task.Delay(1000);
    return 2 * seed;
}
```

>---
#### do 

`do{ .. } while(e)` 循环执行一次或多次。

```csharp
int n = 0;
do
{
    Console.Write(n);
    n++;
} while (n < 5);
// Output:
// 01234
```

>---
#### while

`while(e) { .. }` 循环会执行零次或多次。

```csharp
int n = 0;
while (n < 5)
{
    Console.Write(n);
    n++;
}
// Output:
// 01234
```

>---
#### break 

`break` 语句将终止它最接近的封闭循环语句（即 `for`、`foreach`、`while` 或 `do` 循环）或 `switch` 语句。

```csharp
double[] measurements = { -4, 5, 30, double.NaN };
foreach (double measurement in measurements)
{
    switch (measurement)
    {
        case < 0.0:
            Console.WriteLine($"Measured value is {measurement}; too low.");
            break;
        case > 15.0:
            Console.WriteLine($"Measured value is {measurement}; too high.");
            break;
        case double.NaN:
            Console.WriteLine("Failed measurement.");
            break;
        default:
            Console.WriteLine($"Measured value is {measurement}.");
            break;
    }
}
// Output:
// Measured value is -4; too low.
// Measured value is 5.
// Measured value is 30; too high.
// Failed measurement.
```

>---
#### continue

`continue` 语句开启最接近的封闭循环语句（即 `for`、`foreach`、`while` 或 `do` 循环）的新循环。

```csharp
for (int i = 0; i < 5; i++)
{
    Console.Write($"Iteration {i}: ");
    if (i < 3)
    {
        Console.WriteLine("skip");
        continue;
    }
    Console.WriteLine("done");
}
// Output:
// Iteration 0: skip
// Iteration 1: skip
// Iteration 2: skip
// Iteration 3: done
// Iteration 4: done
```

>---
#### return

`return` 语句终止它所在的函数的执行，并将控制权和函数结果（若有）返回给调用方。

```csharp
double surfaceArea = CalculateCylinderSurfaceArea(1, 1);
Console.WriteLine($"{surfaceArea:F2}"); // output: 12.57

double CalculateCylinderSurfaceArea(double baseRadius, double height)
{
    double baseArea = Math.PI * baseRadius * baseRadius;
    double sideArea = 2 * Math.PI * baseRadius * height;
    return 2 * baseArea + sideArea;     // return
}
```

>---
#### goto

`goto` 语句将控制权转交给带有标签的语句。

```csharp
var matrices = new Dictionary<string, int[][]>
{
    ["A"] = new[]
    {
        new[] { 1, 2, 3, 4 },
        new[] { 4, 3, 2, 1 }
    },
    ["B"] = new[]
    {
        new[] { 5, 6, 7, 8 },
        new[] { 8, 7, 6, 5 }
    },
};

CheckMatrices(matrices, 4);

void CheckMatrices(Dictionary<string, int[][]> matrixLookup, int target)
{
    foreach (var (key, matrix) in matrixLookup)
    {
        for (int row = 0; row < matrix.Length; row++)
            for (int col = 0; col < matrix[row].Length; col++)
                if (matrix[row][col] == target)
                    goto Found;
        Console.WriteLine($"Not found {target} in matrix {key}.");
        continue;
    Found:
        Console.WriteLine($"Found {target} in matrix {key}.");
    }
}
// Output:
// Found 4 in matrix A.
// Not found 4 in matrix B.
```

在 `switch` 语句中 使用 `goto` 语句将控制权移交到具有常量大小写的 `case` 或 `goto default`。

```csharp
public enum CoffeeChoice
{
    Plain,
    WithMilk,
    WithIceCream,
}
public class GotoInSwitchExample
{
    public static void Main()
    {
        Console.WriteLine(CalculatePrice(CoffeeChoice.Plain));  // output: 10.0
        Console.WriteLine(CalculatePrice(CoffeeChoice.WithMilk));  // output: 15.0
        Console.WriteLine(CalculatePrice(CoffeeChoice.WithIceCream));  // output: 17.0
    }
    private static decimal CalculatePrice(CoffeeChoice choice)
    {
        decimal price = 0;
        switch (choice)
        {
            case CoffeeChoice.Plain:
                price += 10.0m;
                break;
            case CoffeeChoice.WithMilk:
                price += 5.0m;
                goto case CoffeeChoice.Plain;
            case CoffeeChoice.WithIceCream:
                price += 7.0m;
                goto case CoffeeChoice.Plain;
        }
        return price;
    }
}
```

>---
#### yield

在迭代器中使用 `yield` 语句提供下一个值的 `yield return` 或表示迭代结束的 `yield break`。迭代器的返回类型可以是 `IEnumerable<T>`、`IEnumerable`、`IAsyncEnumerable<T>` 异步迭代。

当开始对迭代器的结果进行迭代时，迭代器会一直执行，直到到达第一个 `yield return` 语句为止。 然后，迭代器的执行会暂停，调用方会获得第一个迭代值并处理该值。在后续的每次迭代中，迭代器的执行都会在导致上一次挂起的 `yield return` 语句之后恢复，并继续执行，直到到达下一个 `yield return` 语句为止。当控件到达迭代器或 `yield break` 语句的末尾时，迭代完成。

Lambda 表达式中不允许使用 `yield return` 语句。

```csharp
foreach (var item in Square([1, 2, 3, 4, 5, 6, 99999/* 溢出位 */, 7, 8, 9]))
    Console.Write(item + " ");  // output: 1 4 9 16 25 36
IEnumerable<int> Square(int[] items)
{
    int rt;
    for (int i = 0; i < items.Length; i++)
    {
        try { rt = checked(items[i] * items[i]); }
        catch { yield break; }  // 在溢出时跳出迭代
        yield return rt;
    }
}
```

> *异步迭代*

```csharp
await foreach (var item in SquareAsync([1, 2, 3, 4, 5, 99999, 6, 7, 8]))
    Console.WriteLine(item);

async IAsyncEnumerable<int> SquareAsync(int[] nums)
{
    int rt = 0;
    for (int i = 0; i < nums.Length; i++)
    {
        try { rt = await Square(nums[i]); }
        catch
        {
            Console.WriteLine("Overflow");
            yield break;
        }
        yield return rt;
    }
}
async Task<int> Square(int num)
{
    await Task.Run(() => Console.Write($"Input {num}*{num} = "));
    return checked(num * num);
}
// output:
//      Input 1*1 = 1 
//      Input 2*2 = 4
//      Input 3*3 = 9
//      Input 4*4 = 16
//      Input 5*5 = 25
//      Input 99999*99999 = Overflow
```

>---
#### checked, unchecked

`checked` 和 `unchecked` 语句指定整型类型算术运算和转换的溢出检查上下文。当发生整数算术溢出时，溢出检查上下文将定义发生的情况。在已检查的上下文中，引发 `System.OverflowException`；如果在常数表达式中发生溢出，则会发生编译时错误。在未检查的上下文中，会通过丢弃任何不适应目标类型的高序位来将操作结果截断。 

默认情况下，整型算术运算和转换在未检查的上下文中执行。常数表达式在已检查的上下文中计算，如果发生溢出，则会发生编译时错误。可以使用 `unchecked` 为常数表达式显式指定未检查的上下文。

从 C# 11 开始，用户可以定义的 `checked` 运算符重载和转换。

```csharp
int Sum(int x, int y) => unchecked(x + y);
int Mul(int x, int y)
{
    checked
    {
        int mul = x * y;
        Console.WriteLine(mul);
        return mul;
    }
}
```

>---
#### lock

`lock(x){ .. }` 语句获取给定对象的互斥锁，执行语句块，然后释放锁，其中 `x` 是引用类型。当锁被持有时，持有该锁的线程可以再次获取并释放该锁。任何其他线程都被阻止获取锁并等待，直到锁被释放。`lock` 语句确保在任何时刻最多只有一个线程执行它的线程体。

在 `lock` 语句的正文中不能使用 `await` 表达式。

```csharp
public class Account
{
    private readonly object balanceLock = new object();
    private decimal balance;
    public Account(decimal initialBalance) => balance = initialBalance;
    public void UpdateAccount(decimal amount)
    {
        lock (balanceLock)
            balance += amount;
    }
    public decimal GetBalance()
    {
        lock (balanceLock)
            return balance;
    }
}
class AccountTest
{
    static async Task Main()
    {
        var account = new Account(1000);
        var tasks = new Task[100];
        for (int i = 0; i < tasks.Length; i++)
            tasks[i] = Task.Run(() => Update(account));
        await Task.WhenAll(tasks);
        Console.WriteLine($"Account's balance is {account.GetBalance()}");
        // Output:
        // Account's balance is 2000
    }
    static void Update(Account account)
    {
        decimal[] amounts = { 0, 2, -3, 6, -2, -1, 8, -5, 11, -6 };
        foreach (var amount in amounts)
            account.UpdateAccount(amount);
    }
}
```

当同步对共享资源的线程访问时，一般锁定专用对象实例（例如，`private readonly object balanceLock = new object();`）或另一个不太可能被代码无关部分用作 `lock` 对象的实例。避免对不同的共享资源使用相同的 `lock` 对象实例，因为这可能导致死锁或锁争用。避免使用 `this`、`Type` 实例、字符串字面量作为 `lock` 对象。

>---
#### using

`using(<IDisposable> disposable){ .. }` 语句或 `using <IDisposable> disposable;` 声明可确保正确使用 `IDisposable` 实例 `disposable`：`disposable` 局部变量在它的作用域末尾调用它的 `Dispose` 方法并释放该对象。`using` 语句可确保在发生异常的情况下也会释放 `IDisposable` 实例。在一个 `using` 语句中声明多个实例时，它们将按声明的相反顺序释放。

由 `using` 语句或声明进行声明的变量是只读的，无法重新分配该变量或将其作为 `ref` 或 `out` 参数传递。

```csharp
// using 语句
static IEnumerable<int> LoadNumbers_1(string filePath)
{
    var numbers = new List<int>();
    using (StreamReader reader = File.OpenText("numbers.txt"))  
    {
        string line;
        while ((line = reader.ReadLine()) is not null)
            if (int.TryParse(line, out int number))
                numbers.Add(number);
    }
    return numbers; 
}
// using 声明
static IEnumerable<int> LoadNumbers_2(string filePath)
{
    using StreamReader reader = File.OpenText(filePath); 
    var numbers = new List<int>();
    string line;
    while ((line = reader.ReadLine()) is not null)
        if (int.TryParse(line, out int number))
            numbers.Add(number);
    return numbers;
}
```

>---
#### await using

使用 `await using` 语句来正确使用 `IAsyncDisposable` 实例：在声明的局部变量离开被声明的作用域语句块时，将自动调用 `DisposeAsync` 方法释放该实例。`await using` 也可以使用拥有公共无参 `public async ValueTask DisposeAsync()` 方法的对象（不必是 `IAsyncDisposable` 接口实例）。

```csharp
await using (var resource = new AsyncDisposableExample())
{
    // Use the resource
}
class AsyncDisposableExample{
    public async ValueTask DisposeAsync() => Console.WriteLine("DisposeAsync...");
}

```

可以将 `using` 语句和声明与适用于可释放模式的 `ref` 结构的实例一起使用，该结构有一个实例 `public void Dispose()` 方法。

```csharp
int num = 1;
using (Sample s = new Sample(ref num))
{
    // ref 字段可以在 using 中修改，但其引用不可修改
    s.Value = 10;
    Console.WriteLine(num);
}
ref struct Sample
{
    public Sample(ref int val)
    {
        Value = ref val;
    }
    public ref int Value;
    public void Dispose() => Console.WriteLine("ref struct Disposed");
}
```

---
### 异常处理 TODO

使用 `throw` 和 `try` 语句来处理异常，使用 `throw` 语句引发异常，使用 `try` 语句捕获和处理在执行代码块期间可能发生的异常。

引发异常时，公共语言运行时 CLR 将查找可以处理此异常的 `catch` 块。如果当前执行的方法不包含此类 `catch` 块，则 CLR 查看调用了当前方法的方法，并以此类推遍历调用堆栈。如果未找到 `catch` 块，CLR 将终止正在执行的线程。

>---

#### 5.6.1. throw 表达式或语句

> throw 语句

在 `throw e;` 语句中，表达式 `e` 的结果必须隐式转换为 `System.Exception`。可以在 `catch` 块中使用 `throw;` 语句重新引发由 `catch` 处理的异常。`throw;` 保留异常的原始堆栈跟踪，该跟踪存储在 `Exception.StackTrace` 属性中；`throw e;` 更新 `e` 的 `StackTrace` 属性。

```csharp
try
{
    Action ac = null;
    ac();
}
catch (Exception e)
{
    Console.WriteLine(e);
    throw e;  // line 信息更新
}
```

> throw 表达式

`throw` 表达式的结果没有类型，但是可以隐式转换为任意类型。`throw` 表达式只允许：
- 作为条件运算符 `? : ` 的第二或第三个操作数。
- 作为空合并运算符 `??` 的第二个操作数。
- 作为 Lambda 表达式或方法的表达式主体。
 
```csharp
class Person(string name)
{
    public string Name => name ?? throw new ArgumentNullException(nameof(name));
}
```

>---

#### 5.6.2. try-catch

- 用 `try-catch` 语句处理在执行代码块期间可能发生的异常。将代码置于 `try` 块中可能发生异常的位置，使用 `catch` 子句指定要在相应的 `catch` 块中处理的异常的基类型。
- 可以提供多个 `catch` 子句，也可以为 `catch` 指定异常筛选器 `when`。可以在 `catch` 中使用 `throw` 语句重新引发异常。

```csharp
try
{
    // try do....
}
catch (ArgumentException e) when (e is ArgumentNullException || e is ArgumentOutOfRangeException)
{
    Console.WriteLine($"Processing failed: {e.Message}");
}
catch (OperationCanceledException)
{
    Console.WriteLine("Processing is cancelled.");
}
catch // 无筛选条件
{
    throw;  // 重新引发异常
}
```

- 如果异步函数中发生异常，则等待函数的结果时，它会传播到函数的调用方。如果迭代器方法中发生异常，则仅当迭代器前进到下一个元素时，它才会传播到调用方。

```csharp
await Run();

static async Task Run()
{
    try
    {
        Task<int> processing = ProcessAsync(-1);
        Console.WriteLine("Launched processing.");

        int result = await processing;
        Console.WriteLine($"Result: {result}.");
    }
    catch (ArgumentException e)
    {
        Console.WriteLine($"Processing failed: {e.Message}");
    }
    // Output:
    // Launched processing.
    // Processing failed: Input must be non-negative. (Parameter 'input')
}
static async Task<int> ProcessAsync(int input)
{
    if (input < 0)
    {
        throw new ArgumentOutOfRangeException(nameof(input), "Input must be non-negative.");
    }

    await Task.Delay(500);
    return input;
}
```

>---

#### 5.6.3. try-finally

- 在 `try-finally` 语句中，当控件离开 `try` 块时，将执行 `finally` 块。控件可能会离开 `try` 块，由于 `try` 正常执行、或执行跳转语句、或发生异常。可以使用 `finally` 块来清理 `try` 块中使用的已分配资源。可以在 `finally` 块之前可选的使用 `catch` 块进行捕获异常处理。

```csharp
try
{
    int[] arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
    for (int i = 0; i <= arr.Length; i++)
        arr[i]++;
}
catch (ArgumentException e) when (e is ArgumentNullException || e is ArgumentOutOfRangeException)
{
    Console.WriteLine($"Processing failed: {e.Message}");
}
finally
{
    Console.WriteLine("Finally ...");
}
```



---
### 自动内存管理

C# 采用自动内存管理，使开发人员无手动分配和释放由对象占用的内存。自动内存管理策略是由 *垃圾回收器* 实现的。对象的内存管理生命周期如下所示：
  1. 创建对象时，将为其分配内存，运行构造函数，并将对象视为实时对象。
  2. 如果对象及其任何部分不能通过任何可能的执行继续访问（除了运行终结器），则该对象被视为不再使用，并可用于终结回收。C# 编译器和垃圾回收器可以选择对代码进行分析，以确定将来可能会使用哪些对对象的引用。如果作用域中的局部变量是唯一的对象引用，并且从当前执行点开始的任何可能的执行中都不会引用该本地变量，则垃圾回收器可能（但不必需）将该对象视为不再使用。
  3. 一旦对象符合销毁条件，在稍后某个未指定的时间运行对象的终结器（如果有）。正常情况下，对象的析构函数只运行一次，尽管特定于实现的 Api 可能会允许重写此行为。
  4. 一旦对象的终结器运行，如果该对象及其任何部分不能通过任何可能的执行继续进行访问（包括运行终结器），则该对象将被视为不可访问且认为该对象符合回收条件。
  5. 最后，在对象变为符合收集条件后的某个时间，垃圾回收器将释放与该对象关联的内存。

垃圾回收器维护有关对象使用情况的信息，并使用这些信息做出内存管理决策，如在内存中定位新创建的对象的位置，何时重新定位对象以及何时不再使用或不可访问对象。

可以通过 `System.GC` 类上的静态方法控制垃圾回收器的行为，此类可用于请求进行收集，运行（或不运行）终结器。由于垃圾收集器在决定何时收集对象和运行终结器方面有很大的自由度，因此符合标准的实现可能产生与以下代码显示的输出不同的输出：

```csharp
class Sample
{
    unsafe static void Main(string[] args)
    {
        int i = 0;
        do
        {
            Sample s = new Sample();
            s.CreateGC(100000);
            Task.Delay(200).GetAwaiter().GetResult();
            GC.Collect();
            GC.WaitForPendingFinalizers();
        } while (i++ < 10);
    }
    static nint Ps;
    static nint LastPs;

   async void CreateGC(int size)
    {
        await Task.Delay(1);
        int[] arr = new int[size];
        for (int i = 0; i < arr.Length; i++)
            arr[i] = i;
    }
    ~Sample() => Console.WriteLine("Finalizer Invoked");
}
```

通常情况下，终结器只对存储在其自身字段中的数据执行清理，而不对引用的对象或静态字段执行任何操作。使用终结器的替代方法是让类实现 `System.IDisposable` 接口，这使得对象的客户端可以确定何时释放对象的资源，通常是通过将对象作为 `using` 语句中的资源来访问。

```csharp
protected void Defer() 
{
   using var sr = new System.IO.StringReader("Hello World");
} // > call sr.Dispose()
```




---
### 预处理指令

预处理指令提供了有条件地跳过部分编译单元、报告错误和警告条件以及描述源代码的不同区域的能力。不同于 C，在 C# 中，没有单独的预处理步骤，预处理指令作为词法分析阶段的一部分进行处理。可用的预处理指令有：

- `#define`、`#undef`：分别用于定义和取消定义条件编译符号。
- `#if`、`#elif`、`else`、`endif`：使用条件编译符号以指示在源代码中的哪些部分可以有条件地跳过。
- `#error`：用于发出错误。
- `#warning`：用于发出警告。
- `#region`、`endregion`：用于显式标记或折叠源代码的某些部分。
- `#line`：用于控制错误和警告发出的行号。
- `#nullable`：用于控制可为空注释上下文和可为空警告上下文。
- `#pragma`：用于向编译器指定可选的上下文信息。

>---
#### 条件编译


`#if`、`#elif`、`#else` 和 `#endif` 条件编译指令根据当前的条件编译符号有条件地包含或排除源文件的某些部分。条件编译符号存在 `defined` 和 `undefined` 两种状态。

使用 `#define` 指令来定义条件编译符号；`#undef` 指令来取消定义条件编译符号。它们仅对当前编译单元有效。

预处理表达式可以出现在 `#if` 和 `#elif` 指令中，表达式可以使用 `!`、`==`、`!=`、`&&`、`||` 操作符，括号用以分组。表达式求值总是产生一个布尔值，仅可以引用的是条件编译符号和布尔字面值。


```csharp
#define MYTEST
using System;
public class MyClass
{
    static void Main()
    {
#if DEBUG == true
        Console.WriteLine("DEBUG is defined");
#elif (!DEBUG && MYTEST)
        Console.WriteLine("MYTEST is defined");
#elif (DEBUG && MYTEST)
        Console.WriteLine("DEBUG and MYTEST are defined");
#else
        Console.WriteLine("DEBUG and MYTEST are not defined");
#endif
    }
}
```

> `<DefineConstants>`

可以通过 `DefineConstants` 编译器选项来定义项目级别的符号，作用于整个项目域，优先级低于在编译单元内通过 `#define` 定义的条件编译符。在当前编译单元范围中，可以通过 `#undef` 取消定义符号，取消定义的作用域仅限于当前声明的编译单元内。

可以使用 `ConditionalAttribute` 来执行条件编译。可以使用 `#define` 定义的符号，也可以是编译器选项设置的符号。`ConditionalAttribute` 仅对特性类或 `void` 方法有效。未定义符号的条件方法或条件特性在编译时，编译器在其所有调用点删除调用。


```xml
<DefineConstants>CONDITION1</DefineConstants>
```
```csharp
#define CONDITION2
using System.Diagnostics;

class Test
{
    static void Main()
    {
        Console.WriteLine("Calling Method1");
        Method1(3);
        Console.WriteLine("Calling Method2");
        Method2();

        Console.WriteLine("Using the Debug class");
        Trace.Listeners.Add(new ConsoleTraceListener());
        Debug.WriteLine("DEBUG is defined");
    }

    [Conditional("CONDITION1")] 
    public static void Method1(int x) => Console.WriteLine("CONDITION1 is defined");
    [Conditional("CONDITION1"), Conditional("CONDITION2")]
    public static void Method2() => Console.WriteLine("CONDITION1 or CONDITION2 is defined");
}
```

>---
#### 诊断指令

诊断指令用于显式生成错误和警告消息，其报告方式与其他编译时错误和警告的方式相同。
- `#warning` 使用指定的消息生成编译器警告。
- `#error` 使用指定的消息生成编译器错误。

```csharp
#warning Code review needed before check-in
#if Debug && Retail
    #error A build can't be both debug and retail
#endif

class Test {...}
```

>---
#### 区域指令

区域指令用于显式标记源代码区域。可以使用 `#region` 和 `#endregion` 预处理器指令来标记可折叠的源代码区域。

```csharp
#region MyClass definition 
public class MyClass
{
    static void Main()
    {
    }
}
#endregion 
```

>---
#### 行指令

行指令可用于更改编译器在输出（如警告和错误）中报告的行号和源文件名，这些信息也被调用者信息属性使用。借助 `#line`，可修改编译器的行号及（可选）用于错误和警告的文件名输出。

```csharp
class MainClass
{
    static void Main()
    {
#line 200 "Special"
        int i;
        int j;
#line default
        char c;
        float f;
#line hidden // numbering not affected
        string s;
        double d;
    }
}
/*
Special(200,13): warning CS0168: The variable 'i' is declared but never used
Special(201,13): warning CS0168: The variable 'j' is declared but never used
MainClass.cs(9,14): warning CS0168: The variable 'c' is declared but never used
MainClass.cs(10,15): warning CS0168: The variable 'f' is declared but never used
MainClass.cs(12,16): warning CS0168: The variable 's' is declared but never used
MainClass.cs(13,16): warning CS0168: The variable 'd' is declared but never used
*/
```

> 行指令语法

- `#line num filename` 指示下一行的行号强制设为 `num`，在下一个 `#line` 指令前，文件名都会报告为 `filename`。
- `#line filename` 指令可指定要在编译器输出中显示的文件名。默认情况下，将使用源代码文件的实际名称。文件名必须在行号之后。
- `#line default` 指令将行号恢复至默认行号，并对上一指令重新编号的行进行计数。
- `#line hidden` 指令能对调试程序隐藏连续行，当开发者逐行执行调试代码时，介于 `#line hidden` 和下一 `#line` 指令（假设它不是其他 `#line hidden` 指令）间的任何行都将被跳过。`#line hidden` 指令不影响错误报告中的文件名或行号。 

> C#10 `#line` 指令拓展

```csharp
#line (1, 1) - (5, 60) 10 "partial-class.cs"
/*34567*/int b = 0;
```

- `(1, 1)`：指令后面行上的第一个字符的起始行和列。
- `(5, 60)`：标记区域的结束行和列。
- `10`：将使 `#line` 指令生效的列偏移量。
- `"partial-class.cs"`：输出文件的名称。

>---
#### 可空上下文设置指令

`#nullable` 预处理器指令将设置可为空注释上下文和可为空警告上下文。此指令控制是否可为空注释是否有效（引用类型的 `?` 注释），以及是否给出为 `Null` 性警告。

可在项目级别设置 `<Nullable>`，预处理器指令 `#nullable` 优先于项目级设置，用于设置其控制的上下文，直到另一个 `#nullable` 替代它，或到源文件的末尾。

```csharp
#nullable disable      // 将可为空注释和警告上下文设置为“已禁用”。
#nullable enable       // 将可为空注释和警告上下文设置为“已启用”。
#nullable restore      // 将可为空注释和警告上下文还原为项目设置。
#nullable disable annotations   // 将可为空注释上下文设置为“已禁用”。
#nullable enable annotations    // 将可为空注释上下文设置为“已启用”。
#nullable restore annotations   // 将可为空注释上下文还原为项目设置。
#nullable disable warnings      // 将可为空警告上下文设置为“已禁用”。
#nullable enable warnings       // 将可为空警告上下文设置为“已启用”。
#nullable restore warnings      // 将可为空警告上下文还原为项目设置。
```

>---
#### 编译指示指令

`#pragma` 预处理指令用于指定编译器的可选上下文信息。`#pragma` 为编译器给出特殊指令以编译它所在的文件，这些指令必须受编译器支持。语法：`#pragma pragma-name pragma-arguments`。
  
> `#pragma warning`

- `#pragma warning` 可以启用或禁用特定警告。

```csharp
#pragma warning disable warning-list    // 禁用
#pragma warning restore warning-list    // 启用
```

- `warning-list` 是以逗号分隔的警告编号的列表。

```csharp
using System;

#pragma warning disable 414, CS3021  // CS 前缀可选，禁用
[CLSCompliant(false)]
public class C
{
    int i = 1;
    static void Main(){}
}
#pragma warning restore CS3021  // 启用
[CLSCompliant(false)]  // CS3021
public class D
{
    int i = 1;
    public static void F(){}
}
```

> `#pragma checksum`

- `#pragma checksum`：生成校验和。

```csharp
#pragma checksum "filename" "{guid}" "checksum bytes"
```

- `filename` 是需要监视更改或更新的文件的名称，`guid` 是哈希算法的全局唯一标识符 GUID，`checksum bytes` 是表示校验和字节的十六进制数字的字符串（偶数个）。
- Visual Studio 调试器使用校验和确保它可始终找到正确的源。编译器为源文件计算校验和，然后将输出发出到程序数据库 PDB 文件。调试器随后使用 PDB 针对它为源文件计算的校验和进行比较。
- 如果编译器在文件中没有找到 `#pragma checksum` 指令，它将计算校验和，并将该值写入 PDB 文件。

---