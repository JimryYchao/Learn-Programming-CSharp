## C# 程序构建基块


---
### C# 与 .NET

C# 源于 C 语言系列，是一种面向对象的、面向组件的、类型安全的新式编程语言。C# 程序在 .NET 上运行，.NET 是名为公共语言运行时（Common Language Runtime，CLR）的虚拟执行系统和一组类库。CLR 是 Microsoft 对公共语言基础结构（CLI）国际标准的实现。CLI 是创建执行和开发环境的基础，语言和库可以在其中无缝地协同工作。

C# 源代码被编译成符合 CLI 规范的中间语言（IL）。IL 代码和资源存储在 `*.dll` 程序集中。程序集包含一个介绍程序集类型、版本和区域性的清单。

执行 C# 程序时，程序集将加载到 CLR。CLR 会直接执行 JIT 即时编译，将 IL 代码转换成本机指令。CLR 提供自动垃圾回收、异常处理和资源管理相关的服务。CLR 执行的代码有时称为 ***托管代码***（*managed code*），***非托管代码***（*unmanaged code*）被编译成面向特定平台的本机语言（*native code*）。

语言互操作性是 .NET 的一项重要功能。C# 编译器生成的 IL 代码符合公共类型规范（CTS）。通过 C# 生成的 IL 代码可以与通过 .NET 版本的 F#、Visual Basic、C++ 生成的代码进行交互。还有 20 多种与 CTS 兼容的语言。单个程序集可包含多个用不同 .NET 语言编写的模块。这些类型可以相互引用，就像它们是用同一种语言编写的一样。

---
### 程序结构

C# 中的组织结构概念包括程序、命名空间、类型、成员和程序集：程序声明类型，类型包含成员并被整理到命名空间中，成员可包含常量、字段、方法、属性、索引器、事件、运算符、构造函数、终结器、嵌套类型等。编译完的程序打包到程序集中，程序集的文件扩展名一般为 `*.exe`（应用程序）或 `*.dll`（库）。

程序集包含中间语言（IL）指令形式的可执行代码和元数据形式的符号信息。执行前，.NET 公共语言运行时的实时（JIT）编译器会将程序集中的 IL 代码转换为特定于处理器的代码。程序集是包含代码和元数据的自描述功能单元，只需在编译程序时引用特定的程序集，即可在程序中使用此程序集中包含的公共类型和成员。

C# 程序由一个或多个文件组成，每个文件均包含零个或多个命名空间。一个命名空间包含类、结构、接口、枚举、委托等类型或其他命名空间。

```csharp
// A skeleton of a C# program
using System;
namespace YourNamespace{
    class YourClass{}
    struct YourStruct{}
    interface IYourInterface{}
    delegate void YourDelegate();
    enum YourEnum{}
    namespace YourNestedNamespace{
        struct YourStruct{}
    }
    class Program{
        static void Main(string[] args){
            //Your program starts here...
            Console.WriteLine("Hello world!");
        }
    }
} 
```

>---
#### 程序启动

一个程序可以编译为一个类库，也可以是一个可以直接启动的应用程序。当应用程序运行时，将创建一个新的应用程序域 "*Application Domain*"。同一台计算机上可以同时存在多个不同的应用程序实例，每个实例都有自己的应用程序域。

应用程序域通过充当应用程序状态的容器来实现应用程序隔离，用以隔离应用程序及其依赖的类库中定义的类型。对象的实例不能在应用程序域中直接共享。每个应用程序域都有自己类型的静态变量副本，并且每个应用程序域最多运行一次类型的静态构造函数。

作为应用程序编译的程序应包含至少一个符合规范要求的方法作为入口点，`Main` 方法是可执行程序的入口点，也是程序控制开始和结束的位置。程序中只能有一个入口点，如果多个类包含 `Main` 方法，必须使用 `StartupObject` 编译器选项来告知程序，将指定哪个 `Main` 方法用作应用程序入口点。

```csharp
class Program
{
    static void Main(string[] args)
    {
        // Display the number of command line arguments.
        Console.WriteLine(args.Length);
    }
}
```

`Main` 方法的声明中，可选包含命令行自变量 `string[] args` 参数。可使用 `System.Environment.GetCommandLineArgs();` 方法获取命令行参数。与 C 和 C++ 不同，程序的名称不被视为 `args` 数组中的第一个命令行实参，但它是 `GetCommandLineArgs()` 方法中的第一个元素。 

```csharp
class Program
{
    static void Main(string[] args)
    {
        var env_args = Environment.GetCommandLineArgs();
        if (args.Length > 0)
            Console.WriteLine("args[0] = " + args[0]);
        Console.WriteLine("env_args[0] = " + E_args[0]);
    }
}
```


> 有效的 Main 签名

```csharp
public static void Main() { }
public static int Main() { }
public static void Main(string[] args) { }
public static int Main(string[] args) { }

public static async Task Main() { }
public static async Task<int> Main() { }
public static async Task Main(string[] args) { }
public static async Task<int> Main(string[] args) { }
```

> Async Main

声明 `async Main` 返回值时，编译器会生成样本代码，用于调用 `Main` 中的异步方法。如果未指定 `async` 关键字，则需要自行编写该代码，如以下示例所示。示例中的代码可确保程序一直运行，直到异步操作完成：

```csharp
public static void Main()
{
    AsyncConsoleWork().GetAwaiter().GetResult();
}
private static async Task<int> AsyncConsoleWork()
{
    // Main body here
    return 0;
}
```

该示例代码可替换为：

```csharp
static async Task<int> Main(string[] args)
{
    return await AsyncConsoleWork();
}
private static async Task<int> AsyncConsoleWork()
{
    // main body here 
    return 0;
}
```

异步方法 `async Main` 编译器始终为其生成正确的代码。编译器生成一个新的入口函数来调用 `async Main`。假设为 `$GeneratedMain`，编译器将生成：

```csharp
static async Task Main(){}  // 生成等效项 => 
private static void $GeneratedMain() 
    => Main().GetAwaiter().GetResult();

static async Task Main(string[] args){} // 生成等效项 =>
private static void $GeneratedMain(string[] args) 
    => Main(args).GetAwaiter().GetResult();

static async Task<int> Main(){} // 生成等效项 =>
private static int $GeneratedMain() 
    => Main().GetAwaiter().GetResult();

static async Task<int> Main(string[] args){} // 生成等效项 =>
private static int $GeneratedMain(string[] args) 
    => Main(args).GetAwaiter().GetResult();
```

>---
#### 顶级语句

C# 9 之后可以在编译单元中使用顶级语句，编译器为该编译单元生成 `Main`，一个项目仅包含一个顶级语句编译单元。顶级语句隐式位于全局命名空间中。使用 `Environment.GetCommandLineArgs()` 访问命令行参数。

```csharp
using System.Console;

Console.WriteLine("Hello World! {0}", Environment.GetCommandLineArgs()[0]);
```

顶级语句中可以通过使用 `await` 和 `return`，编译器为其生成正确的 `Main`。

```csharp
// 包含 await 和 return
static async Task<int> $GeneratedMain(string[] args){}
// 包含 await
static async Task $GeneratedMain(string[] args){}
// 包含 return
static int $GeneratedMain(string[] args){}
// 非异步无返回
static void $GeneratedMain(string[] args){}
```

>---
#### 程序终止

应用程序终止时将控制权返回到执行环境。当 `Main` 方法返回 `int` 或 `Task<int>` 时，若程序执行完没有导致异常，则返回 `int` 的值用作应用程序的终止状态码，用以表示向执行环境传递应用程序成功或失败的通信。

如果有效入口点方法的返回类型为 `void` 或 `Task`，并且执行完成后没有导致异常，则终止状态码为 `0`。

如果有效入口点方法由于异常而终止，则退出代码是特定于实现的。终结器 `finalizer` 是否作为应用程序终止的一部分运行由实现定义。.NET 框架实现尽一切合理的努力为所有尚未被垃圾收集的对象调用终结器，除非这种清理已经被抑制（例如 `GC.SuppressFinalize`）。

>---
#### 托管执行和 CIL

处理器不能直接解释程序集，程序集使用公共中间语言（*Common intermediate Language*，CIL）。C# 编译器将 C# 源代码文件翻译成中间语言。程序集在 VES（*Virtual Execution System*，虚拟执行系统），运行时（*runtime*）中按需即时编译（*just-in-time compilation*，JIT 编译）为机器码供本机使用。代码在运行时的上下文中执行，就称为托管代码 （*managed code*），在运行时的控制下执行的过程称为托管执行 （*managed execution*）。

“托管” 是指运行时管理程序的内存分配、安全性和 JIT 编译等方面，进而控制了程序的主要行为。不需要 “*runtime*” 支持的代码称为本机代码（*native code*）或非托管代码 （*unmanaged code*）。

运行时规范包含在一个包容面更广的规范 CLI（*Common Language Infrastructure*，公共语言基础结构 ）中：
- CIL（*Common intermediate Language*）公共中间语言，MSIL 或 IL；
- BCL（*Base Class Library*）基类库，属于 FCL 的一个子集；
- FCL（*Framework Class Library*）框架类库，底层由大部分 BCL 组成，主要对 .NET 框架、运行时和 CIL 语言提供支持（预定义类型、集合类型、线程处理、应用程序域、运行时、安全性、互操作等）；中间层是包含了对操作系统功能的封装（文件系统、网络连接、图形图像、XML 操作等）；最外层是包含各种类型的应用程序（Windows Forms、ASP.NET、WPF、WCF、WF 等）；
- CTS（*Common Type System*）公共类型系统；
- CLS（*Common Language Specification*）公共语言规范；
- CLR（*Common Language Runtime*）公共语言运行时，也叫 VES（*Virtual Execution System*，虚拟执行系统），CLR 是 .NET 程序集的运行环境；
- Metadata 元数据包括程序集的布局或文件格式规范。
  
CIL 在 CLR 执行引擎的上下文中运行，其中运行的主要服务和功能包括：
- 语言互操作性：不同源语言间的互操作性。语言编译器将每种源语言转换成相同中间语言 CIL 来实现这种互操作性。
- 类型安全：检查类型间转换，确保兼容的类型才能相互转换。这有助于防范缓冲区溢出。
- 代码访问安全性：程序集开发者的代码有权在计算机上执行的证明。
- 垃圾回收：一种内存管理机制，自动释放 CLR 为数据分配的空间。
- 平台可移植性：同一程序集可在多种操作系统上运行。
- BCL（基类库）：提供开发者能（在所有 .NET 框架中）依赖的大型代码库。


---
### 词汇元素

#### Keywords

| keyword      | description |
| :----------- | :---------- |
| `abstract`   | 声明抽象类，抽象成员
| `as`         | as 类型转换测试
| `base`       | 类型基类访问
| `bool`       | 布尔类型
| `break`      | 跳转语句，中断最接近循环
| `byte`       | 8 位无符号整数
| `case`       | `switch` 语句 `case` 分支
| `catch`      | 异常处理 `catch` 子句
| `char`       | UTF-16 字符码位
| `checked`    | 算数溢出检查
| `class`      | 类声明
| `const`      | 常量声明
| `continue`   | 跳转语句，启动最接近循环的下一次循环
| `decimal`    | 十进制浮点数
| `default`    | `switch` 语句 `default` 分支；`default` 表达式
| `delegate`   | 委托类型、匿名函数、函数指针声明
| `do`         | 循环语句，至少执行一次
| `double`     | IEEE-784 双精度浮点数 
| `else`       | `if` 语句 `else` 分支
| `enum`       | 枚举声明
| `event`      | 事件声明
| `explicit`   | 用户定义显式转换
| `extern`     | 外部声明
| `false`      | `bool` 假值
| `finally`    | 异常处理 `finally` 子句
| `fixed`      | 声明移动变量指针固定语句
| `float`      | IEEE0-784 单精度浮点数
| `for`        | 迭代语句 `for`
| `foreach`    | 迭代语句 `foreach`
| `goto`       | 跳转语句，标签跳转
| `if`         | 条件语句 `if`
| `implicit`   | 用户定义隐式转换
| `in`         | 参数限定符，只读输入限定；泛型逆变
| `int`        | 32 位有符号整数
| `interface`  | 接口类型声明
| `internal`   | 程序集可访问性
| `is`         | `is` 类型推测和模式匹配
| `lock`       | 锁定语句
| `long`       | 64 位有符号整数
| `namespace`  | 命名空间声明
| `new`        | `new` 类型创建；匿名类型声明
| `null`       | 空值，无类型
| `object`     | 对象类型，最终基类
| `operator`   | 用户操作数重载
| `out`        | 参数限定符，赋值输出限定；泛型协变
| `override`   | 虚函数类成员重写
| `params`     | 函数可变参数
| `private`    | 私有可访问性
| `protected`  | 派生可访问性
| `public`     | 公共可访问性
| `readonly`   | 只读类型限定符
| `ref`        | 参数限定符，引用传递限定；引用变量或类型限定
| `return`     | 函数返回语句
| `sbyte`      | 8 位无符号整数
| `sealed`     | 密封类、密封函数类成员
| `short`      | 16 位有符号整数
| `sizeof`     | 类型大小
| `stackalloc` | 栈数组分配
| `static`     | 静态声明
| `string`     | 字符串声明
| `struct`     | 结构声明
| `switch`     | 条件语句 `switch`
| `this`       | 类型实例自身访问
| `throw`      | 异常处理 `throw` 抛出
| `true`       | `bool` 真值
| `try`        | 异常处理 `try` 子句
| `typeof`     | 类型反射
| `uint`       | 32 位无符号整数
| `ulong`      | 64 位无符号整数
| `unchecked`  | 算数溢出检查忽略
| `unsafe`     | 不安全上下文
| `ushort`     | 16 位无符号整数
| `using`      | `using` 声明；类型别名声明
| `virtual`    | 虚函数类成员声明
| `void`       |函数无返回类型
| `volatile`   | 易变修饰符
| `while`      | 循环语句，至少循环零次

>---

#### Context Keywords

| keyword      | description |
| :----------- | :---------- |
| `add`        | 事件 `add` 访问器
| `remove`     | 事件 `remove` 访问器
| `get`        | 属性、索引器 `get` 访问器
| `set`        |  属性、索引器 `set` 访问器
| `value`      | 访问器 `value` 局部变量 
| `alias`      | 程序集别名 `extern alias`
| `ascending`  | 查询表达式 `orderby` 子句升序排序
| `async`      | 异步方法声明
| `await`      | 异步表达式
| `by`         | 查询表达式 `by` 子句
| `descending` | 查询表达式 `orderby` 子句降序排序
| `dynamic`    | 动态类型声明
| `equals`     | 查询表达式 `equals` 子句
| `from`       | 查询表达式 `from` 子句
| `global`     | `using` 全局声明
| `group`      | 查询表达式 `group` 子句
| `into`       | 查询表达式 `into` 子句
| `join`       | 查询表达式 `join` 子句
| `let`        | 查询表达式 `let` 子句
| `nameof`     | 类型名称获取
| `on`         | 查询表达式 `on` 子句
| `orderby`    | 查询表达式 `orderby` 子句
| `partial`    | 分部声明
| `select`     | 查询表达式 `select` 子句
| `unmanaged`  | 类型参数约束，非托管类型约束
| `var`        | 类型推断声明
| `when`       | `case`、`catch` 筛选子句
| `where`      | 查询表达式 `where` 子句；约束声明
| `yield`      | `foreach` 迭代子句

>---
#### Operator and Punctuator

```csharp
   {    }    [    ]    (    )    .    ->   ,    :    ;  
   +    -    *    /    %    &    |    ^    !    ~    =   
   +=   -=   *=   /=   %=   &=   |=   ^=   ~=   ?    ??     
   <    <=   >    >=   !=   ==   ++   --   &&   ||   ??=
   ..   ?.   ?[]  >>   <<   >>=  <<=  >>>  >>>= 
```

>---
#### Unicode escape sequence

Unicode 字符转义序列表示一个 Unicode 字符。Unicode 字符转义序列在标识符、字符文本，字符串文本中处理，在其他位置如运算符、标点、关键字不会被处理。
Unicode 转义序列表示由 `\u` 或 `\U` 和十六进制数组成单个 Unicode 字符，C# 使用 Unicode 码位的 16 位编码，字符文本中不允许使用 `U+10000` 到 `U+10FFFF` 范围内的 Unicode 字符，而是使用字符串文本中的 Unicode 代理项对来表示。不支持 `0x10FFFF` 以上的码位的 Unicode 字符。


>---
#### Identifier

标识符（identifiers）可以由 `_` 开头，由数字字符和字母字符组合的字符序列，不能是数字作为开头。可以在标识符中使用 Unicode 转义序列；使用 `@` 开头时，允许关键字作为标识符。

```csharp
class @class
{
    static void @static(bool @bool) => Console.WriteLine(@bool ? "true" : "false");
    static void main(String[] args)
    {
        cl\u0061ss.st\u0061tic(true);  // \u0061 'a'
    }
}
```

>---
#### Literal

文本（Literal）表示为值的源代码表示形式。包含有：
- 布尔值文本：`true` 和 `false`。
- 整数文本：十进制表示序列（0 ~ 9）、十六进制表示序列（0x0 ~ 0xf），整数序列可以添加无符号数（`u` 后缀）或长整数（`L` 后缀）。
- 实数文本：表示实数序列，写入类型为 `float`（`f` 后缀）、`double`（可选 `d` 后缀）、`decimal`（`m` 后缀）。
- 字符文本：字符文本表示单个字符 `'c'`，包含 11 个可能的简单转义序列（单引号 `\'`、双引号 `\"`、反斜杠 `\\`、Null `\0`、警报 `\a`、退格符 `\b`、换页符 `\f`、换行符 `\n`、回车符 `\r`、水平制表符 `\t`、垂直制表符 `\v`）
- 字符串文本：包含常规字符串文本与原义字符串文本，常规字符串中可能包含简单的转义序列、十六进制 `\x XXX`或 Unicode `\u UUUU` 的转义序列；原义字符串以 `@` 作为前缀，除 `""` 转义为双引号 `"`，其他的字符按原义解释。 
- 内插字符串文本：字符串字面量以 `$` 作为前缀，可以内插表达式 `{expr}` 在运行时进行计算，并将结果转换为字符串字面值。
- Null 文本：表示值 `null`。

---

### 声明与类型定义
#### 声明与名称空间

C# 程序中的声明定义程序的构成元素。C# 使用命名空间 `namespace` 对相关程序元素进行逻辑分组。

类型声明用于定义类、结构、接口、枚举，以及委托。类型声明中允许的成员种类取决于类型声明的形式：类声明可以包含常量、字段、方法、属性、事件、索引器、运算符、实例构造函数、静态构造函数、终结器和嵌套类型。

声明在其所属的名称空间中定义一个名称。在名称空间中声明不能同名，但以下情况除外：
- 允许在同一名称空间中使用两个或多个具有相同名称的命名空间名称。这些相同名称的命名空间被聚合成一个逻辑命名空间，并共享一个名称空间。

+ 在不同的程序中，在相同的命名空间中的声明可以共享相同的名称。但是，如果将这些声明包含在同一个应用程序中，可能会引入歧义。

- 允许在同一名称空间中使用具有相同名称但不同签名的方法（方法重载），或具有相同名称但类型形参数量不同的类型声明（泛型类型）。
  
+ 在同一名称空间中的 `partial` 分部声明的多个类型共享相同的名称、相同数量的类型参数和相同的类型定义（类、结构或接口）。
  
- 同一名称空间中的命名空间声明和类型声明可以共享相同的名称，只要类型声明至少有一个类型形参。

每个命名空间和类型都有一个完全限定的名称，该名称唯一地标识命名空间或类型。成员 N 的完全限定名是从全局空间开始的标识符的完整层次结构路径，命名空间或类型的完全限定名称始终是唯一的。

```csharp
class A { }                // A
namespace X                // X
{
    class B                // X.B
    {
        class C { }         // X.B.C
    }
    namespace Y            // X.Y
    {
        class D { }         // X.Y.D
    }
}
namespace X.Y              // X.Y
{
    class E { }             // X.Y.E
    class G<T>             // X.Y.G<>
    {
        class H { }         // X.Y.G<>.H
    }
    class G<S, T>           // X.Y.G<,>
    {
        class H<U> { }      // X.Y.G<,>.H<>
    }
}
```

声明空间分类：
- 在程序的所有编译单元中，不包含在某个命名空间下的声明包含在全局名称空间（global declaration space）内，全局名称空间下的成员被聚合在全局命名空间内，可以显式通过 `global::` 进行访问。
+ 在程序的所有编译单元中，所有相同完全限定名称的命名空间中的成员声明隶属于该名称的单个逻辑命名空间。
- 每个编译单元和命名空间内都有一个别名（`using`、`extern alias`）名称空间。
+ 每个非分部类、非分部结构和非分部接口声明都将创建一个新的名称空间。除了构造函数以外，类或结构不能包含与类或结构同名的成员声明，但允许声明具有相同名称不同签名的方法或运算符重载。基类不会占用派生类的名称空间，基接口不会占用派生接口的名称空间，因此允许派生类或接口声明与继承成员同名的成员，这类声明的成员将隐藏具有相同名称的继承成员。
- 每个委托、枚举声明都将创建一个新的名称空间。
+ 每个方法声明、属性声明、访问器声明、索引器声明、运算符声明、构造函数声明、匿名函数和局部函数声明都会创建一个新的局部变量名称空间。局部变量名称空间可以嵌套，但是无法在局部和嵌套的名称空间内包含同名的局部声明。
- 每个块 `{ }` 或 `switch-case` 区间、`for`、`foreach`、`using` 等语句都将为局部变量和本地常量创建局部变量名称空间。 
+ 声明名称的文本顺序通常没有意义。例如对于命名空间、常量、方法、属性、事件、索引器、操作符、实例构造函数、终结器、静态构造函数和类型的声明和使用，文本顺序并不重要。声明顺序的重要性体现在：
  - 字段名称的声明顺序决定了它们的初始化式执行的顺序；
  - 局部变量应该在使用之前定义；
  - 当省略关联常数值时，枚举成员的声明顺序很重要。

---
#### 类型定义

类型定义 C# 中的任何数据的组织结构和行为。类型的声明可以包含其成员、基类型、它实现的接口和该类型的行为。变量是用于引用特定类型的实例的标签。标识符是绑定给类型（类、接口、结构、记录、委托或枚举）、成员、变量或命名空间的名称。

C# 是一种强类型语言，每个变量和常量、求值的表达式、方法形参与返回值等都有一个类型。.NET 类库定义了内置数值类型和表示各种构造的复杂类型，其中包括文件系统、网络连接、对象的集合和数组以及日期。类型中可存储的信息有：分配所需空间、值范围、成员（方法、字段、事件等）、基类型、由它实现的接口、允许执行的运算等。

C# 主要有两种类型：值类型和引用类型。值类型变量包含值，引用类型变量包含对数据（称为 “对象”）的引用。在程序运行中，值类型在堆栈（*stack*）上分配，引用类型在堆（*heap*）上分配。

C# 值类型可分为：简单类型、枚举类型、结构类型、可以为 null 的值类型和元组值类型。C# 引用类型又细分为类类型、接口类型、数组类型和委托类型。
- 简单类型：
  - 有符号整数类型：`sbyte`、`short`、`int`、`long`、`nint`。
  - 无符号整数类型：`byte`、`ushort`、`uint`、`ulong`、`nuint`。
  - Unicode 字符类型：`char`，表示 UTF-16 代码单元。
  - IEEE 二进制浮点数类型：`float`、`double`。
  - 高精度十进制浮点数类型：`decimal`。
  - 布尔类型：`bool`。
- 枚举类型：格式为 `enum E {...}` 的用户定义类型。`enum` 类型是一种包含已命名常量的独特类型。
- 结构类型：格式为 `struct S {...}` 的用户定义类型。`record struct` 为记录结构类型。
- 可以为 null 的值类型：值为 `null` 的其他所有值类型的扩展。
- 元组类型：格式为 `(T1,T2,...)` 的用户定义类型。

C# 引用类型可分为：类类型、接口类型、数组类型、委托类型。
- 类类型：
  - 其他所有类型的最终基类：`object`。
  - Unicode 字符串：`string`，表示 UTF-16 代码单元序列。
  - 格式为：`class C {...}` 的用户定义类型。`record` 为记录类型。
- 接口类型：格式为 `interface I {...}` 的用户定义类型。
- 数组类型：一维、多维和交错数组。例如 `int[]`、`int[,]`、`int[][]`。
- 委托类型：格式为 `delegate TResult D(...)` 的用户定义类型。

> *用户定义类型*

C# 程序使用类型声明创建新类型。用户可定义以下 C# 基本类型：类类型、结构类型、接口类型、枚举类型和委托类型。还可以声明 `record` 类型（`record struct` 或 `record class`）。

- `class` ：类类型定义包含数据成员（字段）和函数成员（方法、属性、构造函数等）的数据结构。类支持单一继承和多态。类对象在堆上分配内存，并受垃圾回收器的管理。
- `struct`：结构类型定义包含数据成员和函数成员的结构，与类相似。结构属于堆栈分配对象，不受垃圾回收器的管理。结构不支持用户指定的继承，可以实现接口。
- `interface`：接口类型将协定定义为一组已命名的公共成员。实现 `interface` 的 `class` 和 `struct` 必须提供接口成员的实现代码。接口和类、结构都可以实现多个接口。。
- `delegate`：委托类型表示引用包含特定参数列表和返回类型的方法。通过委托，可以将方法组视为变量并可作为参数传递的实体。委托类同于函数式语言提供的函数类型或函数指针概念，但是委托是面向对象且类型安全。
- `record`：记录类型用类提供封装数据的内置功能。可以声明为 `record` 引用类型或 `record struct` 值类型。记录类型具有编译器合成成员，主要用于存储值，关联行为最少。
- `enum`：枚举类型是由基础整型数值类型的一组命名常量定义的值类型。可以显式指定关联的常数值。

```csharp
class MyClass{}
struct MyStruct{}
interface IMyInterface{}
enum MyEnum{}
record class MyClass_Record{}
record struct MyStruct_Record{}
```

> 类型与变量

C# 有多种变量，其中包括字段、数组元素、局部变量和参数。变量表示存储位置，每个变量都具有一种类型，用于确定可以在变量中存储哪些值：

- 不可为 null 的值类型：具有精确类型的值。
- 可以为 null 的值类型：`null` 值或具有精确类型的值。
- `object`：`null` 引用、对任意引用类型的对象的引用，或对任意值类型的装箱值的引用。
- 类类型：`null` 引用、对类类型实例的引用，或对派生自类类型的类实例的引用。
- 接口类型：`null` 引用、对实现接口类型的类类型实例或值类型的装箱值的引用。
- 数组类型：`null` 引用、对数组类型实例的引用，或对兼容的数组类型实例的引用。
- 委托类型：`null` 引用、对兼容的委托类型实例的引用。
- 记录类型：记录类包含 `null` 引用或记录类实例的引用，记录结构包含记录结构实例的值。

当在程序中声明变量或常量时，必须指定其类型或使用 `var` 关键字让编译器推断类型。变量的值可以分配给其兼容类型或基类型。

```csharp
// Declaration only:
float temperature;
string name;
MyClass myClass;

// Declaration with initializers (four examples):
char firstLetter = 'C';
var limit = 3;
int[] source = { 0, 1, 2, 3, 4, 5 };
var query = from item in source
            where item <= limit
            select item;
```

>---
#### NET 内置类型

C# 提供了一组标准的内置类型。这些类型表示整数、浮点值、布尔表达式、文本字符、十进制值和其他数据类型。还有内置的 `string` 和 `object` 类型。

- 内置值类型：`bool`、`byte`、`sbyte`、`char`、`decimal`、`double`、`float`、`int`、`uint`、`nint`、`nuint`、`long`、`ulong`、`short`、`ushort`。
- 内置引用类型：`object`、`string`、`dynamic`。
- 无类型：`void`。

```csharp
// 整数
byte b = 1;
int i = 0xffff;  // 十六进制
// 浮点值
double d = 1.0;
float f = 1.0f;
// 布尔
bool state = true;
// 文本字符
char ch = 'C';
// 十进制值
decimal digit = 1980;
// 字符串
string str = "Hello world";
// object
object obj = null;
```

>---
#### 非托管类型

如果某个类型是以下类型之一，则它是非托管类型：
  - `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`nint`、`nuint`、`char`、`float`、`double`、`decimal` 或 `bool`。
  - 任何枚举类型，任何指针类型，任何仅包含非托管类型字段的用户定义的结构类型。

非托管类型使用 `unmanaged` 约束指定：类型参数为 “非指针、不可为 null 的非托管类型”。

```csharp
public struct Coords<T> where T : unmanaged
{
    public T X;
    public T Y;
}
```

>---
#### NET 通用类型系统

对于 .NET 中的类型系统，它支持继承原则。类型可以派生自其他类型（称为基类型）。派生类型继承（有一些限制）基类型的方法、属性和其他成员。所有类型派生自单个基类型 `System.Object (C# keyword: object)`。这样的统一类型层次结构称为通用类型系统（CTS）。

> 类、结构或记录的声明类似于一张蓝图，用于在运行时创建实例或对象：

- 类是引用类型，创建类型的对象后，向其分配对象的变量仅保留对相应内存的引用（将对象引用分配给新变量后，新变量会引用原始对象）。
- 结构是值类型，创建结构时，向其分配结构的变量保留结构的实际数据（将结构分配给新变量时，会复制结构）。
- 记录类型可以是引用类型（`record` 或 `record class`）或值类型（`record struct`）

> 值类型

值类型派生自 `System.ValueType`（派生自 `System.Object`）。值类型变量直接包含其值，结构的内存在声明变量的任何上下文中进行内联分配。对于值类型变量，没有单独的堆分配或垃圾回收开销。

值类型分为 `struct` 和 `enum` 两类。内置的数值类型是结构，使用 `struct` 关键字可以创建用户自定义值类型，无法从任何值类型派生类型。`enum` 枚举定义的是一组已命名的整型常量，所有枚举派生自 `System.Enum`（`Enum` 派生自 `System.ValueType`）。


> 引用类型

定义为 `class`、`record class`、`delegate`、数组或 `interface` 的类型是引用类型。引用类型在声明时包含 null 值，直到用户为其分配该类型的实例或使用 `new()` 创建一个。`interface` 通过其实现类型分配值。所有数组都是引用类型，隐式派生自 `System.Array` 类。

创建对象时，会在托管堆上分配内存。变量只保留对对象位置的引用。对于托管堆上的类型，在分配内存和回收内存时都会产生开销。“垃圾回收” 是 CLR 的自动内存管理功能，用于执行资源管理和内存回收。

引用类型完全支持继承。声明类时，可以从其他任何接口或非密封类继承。派生类可以从基类中继承或重写虚拟方法。

>----
#### 泛型类型

可使用一个或多个类型参数声明的类型，用作实际类型（具体类型）的占位符。客户端代码在创建类型实例时提供具体类型，这种类型称为泛型类型，过程称为泛型实例化。例如，.NET 类型 `System.Collections.Generic.List<T>` 具有一个类型参数 `T`，当创建类型的实例时，必须指定列表将包含的对象的类型 `T`，例如 `string`：

```csharp
List<string> stringList = new List<string>();
stringList.Add("String example");
// compile time error adding a type other than a string:
stringList.Add(4);
```

可以声明泛型类、泛型结构、泛型记录、泛型接口、泛型方法和泛型委托。泛型集合类称为强类型集合，因为编译器知道集合元素的具体类型，并能在编译时检查或引发错误。

```csharp
public class Pair<TFirst, TSecond> // <,> 类型参数列表
{
    public TFirst First { get; }
    public TSecond Second { get; }
    public Pair(TFirst first, TSecond second) => 
        (First, Second) = (first, second);
}
```

使用泛型类时，必须为每个类型参数提供类型自变量。

```csharp
{
    var pair = new Pair<int, string>(1, "two");
    int i = pair.First;     //TFirst int
    string s = pair.Second; //TSecond string
}
```

>---
#### 隐式类型、匿名类型和可空值类型

可以使用 `var` 关键字隐式键入一个局部变量（但不是类成员）。隐式类型仍可在编译时获取类型，但类型是由编译器提供。

```csharp
var list = new List<int> { 1, 2, 3, 4, 5, 6 };   // List<int>
var d_num = 3.1415;     // double
var func = mess => Console.WriteLine(mess);     // Action<string>
```

可结合使用 `new` 运算符和对象初始值设定项创建匿名类型。匿名类型提供了一种便捷的方法，可用来将一组只读属性封装到单个对象中，而无需预定义一个类型。

```csharp
var Person = new { FirstName = "John", LastName = "Ychao" };
var anonArray = new[] {
    new { name = "apple", diam = 4 },
    new { name = "grape", diam = 1 }
};
```

一般值类型不具有 `null` 值，`T?` 表示为值类型 `T` 的可为空类型。例如，`int?` 是可以包含值 `null` 的 `int` 类型。可以为 `null` 的值类型是 `System.Nullable<T>` 的实例。 

```csharp
int? val = null, val2 = 10;
if (val.HasValue)  // false
    Console.WriteLine(val.Value);   
Console.WriteLine(val2 ?? 0);  // 10   
```

>---
#### 编译时类型和运行时类型

变量可以具有不同的编译时和运行时类型。编译时类型是源代码中变量的声明或推断类型；运行时类型是该变量所引用的实例的类型。

```csharp
// 运行时和编译时类型相同
string message = "This is a string of characters";   // 编译时和运行时都是 string

// 运行时和编译时类型不同
object anotherMessage = "This is another string of characters";     // 编译时为 object，运行时为 string
IEnumerable<char> someCharacters = "abcdefghijklmnopqrstuvwxyz";    // 编译时为 IEnumerable<char>，运行时为 string
```

---
### 成员与成员访问

命名空间和类型拥有成员。类型的成员在类型定义中声明或从基类型继承。基类的所有成员（除构造函数、终结器外）将成为派生类型的成员。成员的可访问性限制派生类型对该成员的可见性。派生类型也可以通过声明同名成员隐藏继承的成员。

没有在封闭命名空间中声明或类型声明是全局命名空间的成员，可以显式 `global::` 进行访问成员。命名空间中声明的子命名空间和类型是该命名空间的成员。命名空间没有访问限制，其他成员类型可以添加可访问性。

结构的成员是在结构中声明的成员和从结构体的直接基类 `System.ValueType` 和间接基类 `System.Object` 继承的成员。

枚举的成员是枚举中声明的常量，从枚举的直接基类 `System.Enum` 和间接基类 `System.ValueType` 和 `object` 继承的成员。

类的成员是在类中声明的成员（包含常量、字段、方法、属性、事件、索引器、运算符、实例构造函数、析构函数、静态构造函数和嵌套类型），和从所有基类中继承的成员。从基类继承的成员包括常量、字段、方法、属性、事件、索引器、运算符、嵌套类型和基类的类型，但不包括基类实例构造函数、终结器和静态构造函数。

接口的成员是在接口和所有基接口中声明的成员。严格来讲，类对象中的成员不是任何接口的成员，接口仅提供一种成员协议，要求所有实现该接口的类型同时提供接口成员的实现。

数组成员是从类 `System.Array` 继承的成员。

委托的成员是从类 `System.Delegate` 或 `System.MulticastDelegate` 继承的成员。它还包含一些由遍历器生成的方法成员，如 `Invoke` 等。

>---
#### 成员访问

成员声明允许对成员的可访问性进行控制。成员的可访问性由成员声明的可访问性和包含类型的可访问性结合确定。成员的可访问域绝不会超出包含类型的可访问域。成员的可访问性可以是：

  - `public`：访问不受限制。
  - `protected`：访问限于包容类型、或派生自包含类的类型。
  - `internal`：访问仅限于当前程序集（`.exe` 或 `.dll`）。
  - `protected internal`：访问限于当前程序集、包容类型或派生自包含类的类型。
  - `private`：访问仅限于包容类型。
  - `private protected`：访问限于包含类型、或同一程序集中派生自包含类的类型。
  - `file`：（C#11）已声明的类型仅在当前源文件中可见。文件范围的类型通常用于源生成器。

当成员声明不包括任何访问修饰符时，声明位置的上下文决定声明的可访问性：

  - 命名空间没有任何访问限制，隐式声明为 `public` 且无法添加访问修饰符。
  - 位于编译单元或命名空间中声明的顶级类型只能具有 `internal` 或 `public` 可访问性，默认可访问性为 `internal`。
  - `class` 的成员默认为 `private`，其成员可以声明 `public`、`internal`、`protected`、`protected internal`、`private`、`private protected`。
  - `struct` 的成员默认为 `private`，其成员可以声明为 `public`、`internal`、`private`。
  - `interface` 的成员默认为 `public`，其成员可以声明为 `public`、`internal`、`protected`、`protected internal`、`private`、`private protected`，其中声明为 `private` 的接口成员必须具有默认的实现。
  - `enum` 的成员默认为 `public`，其成员不允许添加访问修饰符。

> 文件本地类型（C#11）

- `file` 修饰符将顶级类型的范围和可见性限制为其所包含的文件范围。`file` 修饰符通常应用于源生成器编写的类型。**文件本地类型** 为源生成器提供了一种方便的方法，能够避免在生成的类型之间发生名称冲突。
- `file` 可用于修饰 `class`、`struct`、`enum`、`interface`、`record`、`delegate`、`record struct`、`Attribute class`。


>---
#### 可访问性约束

C# 中的一些结构要求类型至少具有与成员或其他类型一样的可访问性。存在以下可访问性限制：
- 类类型的直接基类至少具有应与类类型本身相同的可访问性。
- 接口类型的显式基接口至少具有与接口类型本身相同的可访问性。
- 委托类型的返回类型和参数类型至少具有与委托类型本身相同的可访问性。
- 常量的类型至少具有与常量本身相同的可访问性。
- 字段的类型至少具有与字段本身相同的可访问性。
- 方法的返回类型和参数类型至具有与方法本身相同的可访问。
- 属性的类型至少具有与属性本身相同的可访问性。
- 事件的类型至少具有与事件本身同样的可访问性。
- 索引器的类型和参数类型至少具有与索引器本身相同的可访问性。
- 运算符的返回类型和参数类型至少具有与运算符本身具有相同的可访问性。
- 实例构造函数的参数类型至少具有与实例构造函数本身相同的可访问性。
- 类型参数上的接口或类类型约束至少具有与声明该约束的成员相同的可访问性。

```csharp
class SampleA { }
public class SampleB
{
    SampleA F() => new SampleA();
    internal SampleA G() => F();
    public SampleA H() => F();  // err: SampleA 比方法 H 的可访问性低
}
```

---
### 简单值类型

值类型包含结构类型和枚举类型。C# 提供了一组预定义的结构类型，被称为简单类型，简单类型可以通过关键字来识别。

所有的值类型都隐式继承类 `System.ValueType`，任何类型都不可能从值类型派生，所有值类型都是隐式密封的。

- `sbyte` 对应于 `System.Sbyte`。
- `byte` 对应于 `System.Byte`。
- `short` 对应于 `System.Int16`。
- `ushort` 对应于 `System.UInt16`
- `int` 对应于 `System.Int32`。
- `uint` 对应于 `System.UInt`。
- `long` 对应于 `System.Int64`。
- `ulong` 对应于 `System.UInt64`。
- `char` 对应于 `System.Char`。
- `float` 对应于 `System.Single`。
- `double` 对应于 `System.Double`
- `decimal` 对应于 `System.Decimal
- `bool` 对应于 `System.Boolean`。
- `nint` 对应于 `System.IntPtr`。
- `nuint` 对应于 `System.UIntPtr`

>---
#### Integer

C# 支持 11 种整数类型，所有的有符号整数都使用二进制补码格式表示：

| type | description | value range |
| :--- | :---------- | :---------- |
| `sbyte`|    有符号 8 位整数 | -128 ~ 127
| `byte`|    无符号 8 位整数 |  0 ~ 255 
| `short`|    有符号 16 位整数 | -32768 ~ 32767
| `ushort`|    无符号 16 位整数 | 0 ~ 65535
| `int`|    有符号 32 位整数|-2147483648 ~ 2147483647 
| `uint`|    无符号 32 位整数| 0 ~ 4294967295 
| `long`|    有符号 64 位整数| -9223372036854775808 ~ 9223372036854775807 
| `ulong`|    无符号 64 位整数 |0 ~ 18446744073709551615 |
| `char`|     Unicode-16 码位整数值 |0 ~ 65535|
| `nint`|   32 或 64 位本机大小有符号整数
| `nuint`|   32 或 64 位本机大小的无符号整数

没有其他整数类型到 `char` 类型的隐式转换。`char` 的常量应写成字符形式或 `(char)integer` 的强制转换形式。

`checked` 和 `unchecked` 运算符和语句用于控制整型算数运算和转换的溢出检查。`checked` 上下文中整型运算溢出会引发 `System.OverflowException` 异常；`unchecked` 上下文中将忽略溢出，并且不会丢弃任何不适合目标类型的高序位。  

```csharp
// 有符号整数
sbyte   _int8 = -8;         // -2^7 ~ 2^7-1
short   _int16 = -16;       // -2^15 ~ 2^15-1
int     _int32 = -32;       // -2^31 ~ 2^31-1
long    _int64 = -64L;      // -2^63 ~ 2^63-1
// 无符号整数
byte    _uint8 = 8;         // 0 ~ 2^8-1
ushort  _uint16 = 16;       // 0 ~ 2^16
uint    _uint32 = 32;       // 0 ~ 2^32
ulong   _uint64 = 64l;      // 0 ~ 2^64
```

> *不同进制数表示*

```csharp
var decimalLiteral = 42;            // 十进制
var hexLiteral = 0x2A;              // 十六进制 0x, 0X
var binaryLiteral = 0b_0010_1010;   // 二进制 0b, 0B
```

> *整数文本后缀*

```csharp
long _long_64 = 0xffffL;            // long, ulong 长整数后缀 L, l
uint _uint_32 = 32u;                // 无符号整数后缀 U, u
ulong _ulong_64 = 0xffffuL;         // 无符号长整数后缀 ul, lu, Ul, lU, UL, LU 
```

> *数字分隔符*

任何数字序列都可以用下划线分隔，两个连续数字之间可以有一个以上的下划线。在小数中也可以使用。

```csharp
int bin = 0b1001_1010_0001_0100;
int hex = 0x1b_a0_44_fe;
int dec = 33_554_432;
int weird = 1_2__3___4____5_____6______7_______8________9;
double real = 1_000.111_1e-1_000;
```

>---
#### Char

`char` 类型用来表示 Unicode UTF-16 字符，支持比较、相等、增量和减量运算符。算数和按位运算得到 `int` 结果。

`char` 的值可以用字符文本、Unicode 转义序列（`\uUUUU`，四位）、十六进制转义序列（`\xXX`）表示。`char` 可以隐式转换为其它包含数值类型，或显式转换为未包含数值类型。其他类型则无法隐式转换为 `char`。

```csharp
char Ch = 'H';
char Ch_x = '\x65';
char Ch_u = '\u00ff';
```

>---
#### Native Integer

```csharp
// 本机大小的整数
nint    _IntPtr = new IntPtr();     // 有符号本机 32 位或 64 位整数
nuint   _UIntPtr = new UIntPtr();   // 无符号本机 32 位或 64 位整数
```

类型 `nint` 和 `nuint` 由底层类型由 `System.IntPtr` 和 `System.UIntPtr` 表示，编译器为这些类型提供额外的转换和操作。本机大小的整数类型具有特殊行为，因为存储是由目标计算机上的自然整数大小决定的。

```csharp
// sizeof, 获取本机整数的大小需要在不安全的上下文中
unsafe
{
    Console.WriteLine($"size of nint = {sizeof(nint)}");
    Console.WriteLine($"size of nuint = {sizeof(nuint)}");
}
// 本机整数的极值
Console.WriteLine($"nint.MinValue = {nint.MinValue}");
Console.WriteLine($"nint.MaxValue = {nint.MaxValue}");
Console.WriteLine($"nuint.MinValue = {nuint.MinValue}");
Console.WriteLine($"nuint.MaxValue = {nuint.MaxValue}");
// 数值转换：没有适用于本机大小整数文本的直接语法，可以改为使用其他整数值的隐式或显式强制转换
// 本机整数支持内置数值转换规则
nint a = (nint)otherInteger;
```

类型 `nint` 和 `nuint` 转换和操作是由编译器合成的，不是底层 `IntPtr` 和 `UIntPtr` 类型的一部分，因此这些转换和运算符操作无法从动态类型的运行时绑定中获得。

```csharp
nint x = 2;
nint y = x + x; // ok
dynamic d = x;
nint z = d + x; // RuntimeBinderException: '+' cannot be applied 'System.IntPtr' and 'System.IntPtr'
```

>---
#### Float-point

C# 支持两种 IEEE-754 格式表示的 `float` （32 位单精度）和 `double`（64 位双精度）浮点数，它们的值域包含：
- 正零和负零，常规算数中和简单值 0 行为相同，在一些特殊的操作中区分零的正负。
- 正无穷（`1.0/0.0`）与负无穷（`-1.0/0.0`）。
- 非数字值，NaN 是由无效的浮点运算产生的，如 `0.0/0`。
- `float` 可以表示具有大约 1.5 × 10⁻⁴⁵ ~ 3.4 × 10³⁸ 的值，精度为 7 位。
- `double` 可以表示具有大约 5.0 × 10⁻³²⁴ ~ 1.7 × 10³⁰⁸ 的值，精度为 15 ~ 16 位。

```csharp
float F_32 = 3.1415f;          // f 或 F 后缀，6~9 位精度
double D_64 = 3.1415;          // 隐式 d 或 D 后缀，15~17 位精度
// 无穷定义
var n_inf = double.NegativeInfinity;    // 负无穷  
var p_inf = double.PositiveInfinity;    // 正无穷
// 非数值
var nan = 0.0/0;   // 非数值
```

如果二元运算符的任一操作数是浮点类型，则应用数值提升，并以 `float` 或 `double` 执行操作：
- 浮点运算永远不会产生异常，在特殊情况下，浮点运算产生零、无穷大或 NaN。
- 浮点运算的结果四舍五入到目标格式中最接近的可表示值。
- 若浮点运算结果的大小对于目标格式来说太小，则将运算结果变成正零或负零。
- 若浮点运算结果的大小对于目标格式来说太大，则将运算结果变为正无穷大或负无穷大。
- 若浮点操作无效，则该操作的结果为 NaN；若其中一个操作数为 NaN 时，最终运算结果也是 NaN。

>---
#### Decimal

`decimal` 类型是一种 128 位的数据类型，适合于金融和货币计算。十进制类型可以表示的范围至少为 -7.9 × 10⁻²⁸ ~ 7.9 × 10²⁸, 至少有 28 位精度。

```csharp
decimal M_128 = 3.1415m;       // m 或 M 后缀，28~29 位精度
```

若二元运算符的任一操作数是 `decimal` 类型，则应用数值提升，并以 `double` 执行该操作：
- 对于 `decimal` 类型的值进行操作的结果是计算精确的结果，并舍入以适应表示。
- 结果四舍五入到最接近的可表示值。舍入可能会从非零值产生零值。
- 若十进制算数运算产生的结果对于 `decimal` 太大，则会产生 `System.OverflowException` 异常。
- 不同于 `float` 和 `double`，`decimal` 可以精确表示 0.1 的值。

#### decimal 和浮点类型 

`decimal` 比 `float` 和 `double` 具有更高的精度，所以可能比浮点类型具有更小的范围。从浮点类型转换为 `decimal` 类型可能产生溢出异常，反过来 `decimal` 转换为浮点类型可能会损失精度或溢出异常。因此它们之间不存在隐式转换，可以显式强制转换。

```csharp
decimal dm = 1.0m;
double d = (double)dm;

float f = 3.14f;
decimal df = (decimal)f;
```

>---
#### Boolean

`bool` 类型表示布尔逻辑值，值可以为 `true` 或 `false`。布尔类型和其他类型之间不存在标准转换，不能用布尔值代替整型。

在 C/C++ 中，零的整型或浮点型值、空指针可以被转换为布尔值 `false`，非零整型或浮点型、非空指针可以被转换为布尔值 `true`。在 C# 中，这种转换是通过显式地将整数或浮点值与零进行比较，或者显式地将对象引用与 `null` 进行比较来完成的。
 
可以使用 `Convert` 类进行布尔转换：非零数值转换为 `true`，零转换为 `false`；字符串转换时忽略大小写。
 
```csharp
bool t = true;
bool f = false;
bool rt = Convert.ToBoolean("True");    // true
bool rt2 = Convert.ToBoolean(0);        // false
```

>---
#### Enum

枚举类型是声明一组命名常量的值类型。每个枚举类型都有一个相应的整型作为其基础类型，该整数类型可以是 `byte`、`sbyte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`。默认的基础类型是 `int`。

使用 `enum` 定义枚举类型，并声明其枚举成员的命名常量和关联常数值，多个枚举成员可以共享相同的关联值。

关联值可以隐式或显式赋值。若枚举成员是枚举类型中的第一个枚举成员，在为显式赋值时，其关联值为 0。其他未显式赋值的枚举成员的关联值是前一个成员的值加 1。

```csharp
enum Color : uint
{
    Red = 1,
    Green = 2,
   // Blue = -3, // err 
    Blue = 3,
    Max = Blue
}
```

可以使用枚举类型，通过一组互斥值或选项组合来表示选项。若要表示选项组合，请将枚举类型定义为位标志。

```csharp
public enum Days
{
    None      = 0b_0000_0000,  // 0
    Monday    = 0b_0000_0001,  // 1
    Tuesday   = 0b_0000_0010,  // 2
    Wednesday = 0b_0000_0100,  // 4
    Thursday  = 0b_0000_1000,  // 8
    Friday    = 0b_0001_0000,  // 16
    Saturday  = 0b_0010_0000,  // 32
    Sunday    = 0b_0100_0000,  // 64
    Weekend   = Saturday | Sunday
}
```

`System.Enum` 类型是所有枚举类型的抽象基类。可在基类约束中使用 `System.Enum`（称为枚举约束），以指定类型参数为枚举类型。对于任何枚举类型，都存在分别与 `System.Enum` 类型的装箱和取消装箱的相互转换。

对于任何枚举类型，枚举类型与其基础整型类型之间存在显式转换。使用 `Enum.IsDefined` 方法来确定枚举类型是否包含具有特定关联值的枚举成员。

```csharp
Console.WriteLine(1.ConvertEnum<Season>());     // Summer
Console.WriteLine((-1).IsDefinedByEnum<Season>());  // False

Season val = (Season)1;     // 强制转换

public enum Season
{
    Spring,
    Summer,
    Autumn,
    Winter
}
public static class EnumExt
{
    public static T ConvertEnum<T>(this int eVal) where T : Enum
        => (T)Enum.ToObject(typeof(T), eVal);
    public static bool IsDefinedByEnum<T>(this int eVal) where T : Enum 
        => Enum.IsDefined(typeof(T), eVal);
}
```

>---
#### ValueTuple

元组类型表示具有可选名称和单独类型的有序、固定长度的值序列。元组类型写为 `(T1 I1, ... , Tn In)`，n ≥ 2，标识符 `I1, ..., In` 是可选的元组元素名。

`(T1, ..., Tn)` 这种构造语法是 `System.ValueTuple<...>` 的简写，它是一组泛型结构类型。能够直接表示 2 ~ 7 数目之间的任意元组类型。数量大于 7 的元组用泛型 `ValueTuple<T1, ..., T7, TRest>` 表示，其中 `TRest` 包含一个嵌套其余元素的值，由另一个 `ValueTuple<...>` 表示。

元组的值可以通过元组表达式创建，也可以是 `new ValueTuple<...>`。

```csharp
using Point = (int, int);

Point p1 = (1, 2);  // 元组表达式
Point p2 = new ValueTuple<int, int>(1, 2);
Point p3 = new(1, 2);
Point p4 = ValueTuple.Create(1, 2);
```

元组类型中的元素名称必须不同，未提供显式名称的元素根据其元素顺序命名为 `ItemX`，`X` 是从 1 开始的序列。可选元素名不在 `ValueTuple<...>` 类型中，并且不会存在元组值得运行时表示形式中。`ItemX` 的显式定义名称只能用在相应的 `X` 位置。

```csharp
using Point = (int x, int y);

Point p1 = (1, 2);
Console.WriteLine(p1.Item1);  // 使用默认的元素名称
Console.WriteLine(p1.y);    // 使用显式提供的元素名称

(int Item1, string Item2) pair1 = (5, "Five");  
(int Item2, string) pair2 = (5, "Five");  // err, Item2 只能用于 2 位置
```

元组类型支持相等运算符 `==` 和 `!=`。

```csharp
(double x, double y) Point1 = new(1, 1);
(double, double) Point2 = new();
Point2.Item1 = Point1.x;
if(Point2 != Point1)
    Console.WriteLine(Point2);  // (1,0)
```

元组最常见的用例之一是作为方法返回类型，可以将方法结果分组为元组返回类型，而不是定义 `out` 方法参数。可以使用赋值运算符 `=` 在单独的变量中析构元组实例，析构元组时可以使用弃元。

```csharp
var (X, Y, _) = GetRandomPoint();   // 析构元组
Console.WriteLine("The Point2D = ({0},{1})", X, Y);
static (int, int, int) GetRandomPoint()
{
    Random rand = new Random(DateTime.Now.Millisecond);
    return (rand.Next(-128, 128), rand.Next(-128, 128), rand.Next(-128, 128));
}
```

> 元组解构

可以在 `struct`、`class`、`record`、`interface` 中声明名为 `Deconstruct` 的方法，该方法返回 `void`，且拥有至少两个 `out` 参数。该方法为这些类型提供解构为元组的功能支持，`Deconstruct` 方法支持重载。

在声明主构造函数的记录中，编译器会为其自动生成一个 `Deconstruct` 方法，其参数列表对照位置记录中的位置参数。

```csharp
 // 为 class 定义解构函数
var (fname, lname) = new Person("Hello", "World");
class Person(string firstName, string lastName)
{
    public string FirstName { get; } = firstName;
    public string LastName { get; } = lastName;
    public void Deconstruct(out string firstName, out string lastName)
        => (firstName, lastName) = (FirstName, LastName);
}

// 解构一个位置记录
var (fname, lname) = new Person("Hello", "World");
record Person(string firstName, string lastName);
```

解构函数也可以是扩展方法，可以为指定类型提供额外的 `Deconstruct` 扩展方法。

```csharp
public static void Deconstruct(this <Type> destTypeObj, out <Type1> val, out <Type2> val2[, out < Type3 > val3...]0) { }

var (<Type1> rt1, <Type2> rt2[, ...]) = destTypeObj;
```

为了方便起见，某些系统类型提供 `Deconstruct` 方法。例如 `System.Collections.Generic.KeyValuePair<TKey,TValue>` 类型提供此功能，循环访问 `Dictionary` 时，每个元素都是 `KeyValuePair<TKey,TValue>`。

```csharp
Dictionary<string, int> snapshotCommitMap = new(StringComparer.OrdinalIgnoreCase)
{
    ["https://github.com/dotnet/docs"] = 16_465,
    ["https://github.com/dotnet/runtime"] = 114_223,
    ["https://github.com/dotnet/installer"] = 22_436,
    ["https://github.com/dotnet/roslyn"] = 79_484,
    ["https://github.com/dotnet/aspnetcore"] = 48_386
};
foreach (var (repo, commitCount) in snapshotCommitMap)
    Console.WriteLine($"The {repo} repository had {commitCount:N0} commits as of November 10th, 2021.");
```

---
### Struct

结构体类似于类，可以包含数据成员和函数类成员。结构是值类型。对于在构造函数返回后未显式初始化的结构字段都将零初始化。

结构成员可以是常量、字段、方法、属性、事件、索引器、运算符、实例构造函数、静态构造函数和嵌套类型。

```csharp
public struct Coords(double x, double y)
{
    public double X => x;
    public double Y => y;
    public override string ToString() => $"({X}, {Y})";
}
// 记录结构声明
public record struct Data<T> where T : class
{
    public T Bindings;
    public readonly int GUI { get; init; }
}
```

所有结构类型都隐式继承类 `System.ValueType`。结构声明可以实现接口，但不能指定基类。结构总是隐式密封的，因此没有 `abstract` 和 `sealed` 修饰的方法。结构体无法被继承，它的成员不能是 `protected`、`internal protected`、`private protected`。

结构体中的方法不能是 `virtual` 或 `abstract`，但是可以重写从 `System.ValueType` 继承的虚方法。

```csharp
struct Person(string name) : ICloneable
{
    public object Clone() => new Person(name);
    public override string ToString() => name ?? "";
}
```

当结构成员中不包含构造函数时，编译器为其提供一个默认的公共无参实例构造函数；结构体中的实例字段和默认实现的属性具有初始值设定项时，必须同时包含显式声明的构造函数。

```csharp
struct Sample(string first, string last)
{
    public string Name { get; set; } = first + " " + last;
    public string FirstName = first;
    public string LastName = last;
}
```

>---
#### readonly struct

`readonly struct` 结构类型表明实例不可变，它的实例字段都应声明为 `readonly`；实例属性为只读；不能声明字段形式的事件。

当一个只读结构的实例被传递给一个方法时，被视为一个 `in` 参数，它禁止对任何实例字段进行写访问（自身构造函数除外）。

```csharp
readonly struct Sample
{
    public readonly string FirstName;
    public readonly string LastName;
    public string Name => FirstName + " " + LastName;
}
```

>---
#### ref struct

`ref struct` 被称为引用结构，它的实例在执行堆栈上分配，不能转义到托管堆，因此无法被函数闭包捕获（例如匿名函数和 Lambda 表达式）。

`ref struct` 有以下限制：
  - 不能是数组的元素类型、元组的元素类型、不能实现接口、不能是类型参数、不能在迭代器中使用。
  - `ref struct` 不能是类或非 `ref struct` 的字段的声明类型。
  - `ref struct` 不能被装箱为 `System.ValueType` 或 `System.Object`。
  - `ref struct` 变量不能由 Lambda 表达式或局部函数捕获。
  - `ref struct` 变量不能在 `async` 方法中使用，但可以在同步方法中使用 `ref struct` 变量。例如，在返回 `Task` 或 `Task<TResult>` 的同步方法中。
  - `ref struct` 中不能声明异步实例方法、迭代器实例方法。

`ref` 字段有以下限制：
- `ref` 字段只能在 `ref struct` 内部声明。
- `ref` 字段不能声明为 `static`、`volatile`、`const`。
- `ref` 字段的类型不能是 `ref struct`。
- 引用程序集生成过程必须在 `ref struct` 中保留 `ref` 字段的存在。
- `readonly ref struct` 必须将其 `ref` 字段声明为 `readonly ref`。

```csharp
interface ISample { }
interface ISample<T> { }
public ref struct Point(double x, double y) //:ISample  // err: 不能实现接口
{
    public static Point Origin => default;
    public double X { get => x; set => x = value; }
    public double Y { get => y; set => y = value; }
}
class Sample
{
    //Point[] points;   // err: 不能构造数组
    //ISample<Point> sample;    // err: 不能是类型参数
    //Point Origin;   // err: 不能是类或非 ref 结构的字段
    //object origin = (object)Point.Origin;  // err: ref 结构无法装箱成 object
    async void AsyncTest()
    {
        // Point Origin = new(0, 0); // err: async 方法中无法使用 ref 结构
    }
}
```

`ref struct` 可以使用 `default` 表达式进行初始化，但是它的所有 `ref` 字段被初始化为 `null`，因此直接访问这些字段将引发 `NullReferenceException`。可以在调用 `ref` 字段或变量前，使用 `Unsafe.IsNullRef<T>(ref T t)` 检查变量值的引用是否为空。

```csharp
ref struct Sample
{
    private ref int Value;
    public int GetValue()
    {
        if (System.Runtime.CompilerServices.Unsafe.IsNullRef(ref Value))
            throw new InvalidOperationException(message);
        return Value;
    }
}
```

`ref struct` 结构的 `ref` 字段可以与 `readonly` 组合：
- `readonly ref` 字段不能在构造函数或 `init` 属性访问器之外重新 `= ref` 赋值，但是可以在此之外的任何上下文中作为一个值进行 `=` 赋值（注意查 `null`）。
- `ref readonly` 字段可以被 `= ref` 赋值，但是不能 `=` 赋值。
- `readonly ref readonly` 是 `readonly ref` 和 `ref readonly` 的组合，即仅能在构造函数或 `init` 属性访问器中初始化，在其他任何上下文均不能通过 `= ref` 或 `=` 改变字段的状态。 

```csharp
ref struct ReadOnlyExample
{
    ref readonly int Field1;
    readonly ref int Field2;
    readonly ref readonly int Field3;

    void Uses(int[] array)
    {
        Field1 = ref array[0];  // Okay
        Field1 = array[0];      // Error: can't assign ref readonly value (value is readonly)

        Field2 = ref array[0];  // Error: can't repoint readonly ref
        Field2 = array[0];      // Okay
        
        Field3 = ref array[0];  // Error: can't repoint readonly ref
        Field3 = array[0];      // Error: can't assign ref readonly value (value is readonly)
    }
}
```

>---
#### struct this

`this` 在结构体中的含义不同于 `this` 在类中的含义。当结构类型覆盖从 `System.ValueType` 继承的虚方法时（如 `Equals`、`GetHashCode` 或 `ToString`），通过结构类型的实例调用虚拟方法不会导致装箱。即使将结构用作类型参数并且通过类型参数类型的实例调用也是如此。

```csharp
class Sample
{
    struct Counter
    {
        int value;
        public override string ToString() => value++.ToString();
    }
    static void Test<T>() where T : new()
    {
        T x = new T();
        Console.WriteLine(x.ToString());    // 0
        Console.WriteLine(x.ToString());    // 1
        Console.WriteLine(x.ToString());    // 2
    }
    static void Main() => Test<Counter>();
}
```

>---
#### 固定大小的缓冲区

可以使用 `fixed` 关键字来创建在数据结构中具有固定大小的数组的缓冲区。当编写与其他语言或平台的数据源进行互操作的方法时，固定大小的缓冲区很有用。

固定大小的缓冲区可以采用允许用于常规结构成员的任何属性或修饰符。唯一的限制是数组类型必须为 `bool`、`byte`、`char`、`short`、`int`、`long`、`sbyte`、`ushort`、`uint`、`ulong`、`float` 或 `double`。
  
```csharp
internal unsafe struct Buffer
{
    public fixed char fixedBuffer[128];
}
```

在安全代码中，包含数组的 C# 结构不包含该数组的元素，而是包含对该数组的引用。当在不安全的代码块中使用数组时，可以在结构中嵌入固定大小的数组。使用 `fixed` 语句获取指向数组第一个元素的指针，通过此指针访问数组的元素。`fixed` 语句将 `fixedBuffer` 实例字段固定到内存中的特定位置。

```csharp
internal unsafe struct Buffer
{
    public fixed char fixedBuffer[128];
}
internal unsafe class Example
{
    public Buffer buffer = default;
}
private static void AccessEmbeddedArray()
{
    var example = new Example();
    unsafe
    {
        // Pin the buffer to a fixed location in memory.
        fixed (char* charPtr = example.buffer.fixedBuffer)
        {
            *charPtr = 'A';
        }
        // Access safely through the index:
        char c = example.buffer.fixedBuffer[0];
        Console.WriteLine(c);

        // Modify through the index:
        example.buffer.fixedBuffer[0] = 'B';
        Console.WriteLine(example.buffer.fixedBuffer[0]);
    }
}
```

固定大小的缓冲区使用 `System.Runtime.CompilerServices.UnsafeValueTypeAttribute` 进行编译，它指示公共语言运行时 CLR 某个类型包含可能溢出的非托管数组。

```csharp
internal unsafe struct Buffer
{
    public fixed char fixedBuffer[128];
}
// 为 Buffer 生成 C# 的编译器的特性如下
internal struct Buffer
{
    [StructLayout(LayoutKind.Sequential, Size = 256)]
    [CompilerGenerated]
    [UnsafeValueType]
    public struct <fixedBuffer>e__FixedBuffer
    {
        public char FixedElementField;
    }

    [FixedBuffer(typeof(char), 128)]
    public <fixedBuffer>e__FixedBuffer fixedBuffer;
}
```

与固定缓冲区不同的是，使用 `stackalloc` 分配的内存还会在 CLR 中自动启用缓冲区溢出检测功能。

```csharp
unsafe
{
    int* pSafe = stackalloc int[10];
    for (int i = 0; i < 100; i++)
        *(pSafe + i) = i;
    // 进行缓冲区溢出检查，溢出时引发异常 System.AccessViolationException

    Example ex = new Example();
    fixed (int* pUnsafe = ex.buffer.fixedBuffer)
    {
        for (int i = 0; i < 100; i++)
            *(pUnsafe + i) = i;   // 不进行缓冲区溢出检查
    }
}
internal unsafe struct Buffer
{
    public fixed int fixedBuffer[10];
}
internal unsafe class Example
{
    public Buffer buffer = default;
}
```


>---
#### 内联数组

从 C#12 开始，可以声明结构类型的内联数组。内联数组是包含相同类型的 N 个元素的连续块的结构，它是一个安全代码，等效于仅在不安全代码中可用的固定缓冲区声明，编译器可以利用有关内联数组的已知信息。内联数组是仅包含单个字段、且未指定其他任何的显式布局的结构类型。

使用 `System.Runtime.CompilerServices.InlineArrayAttribute` 特性修饰 `struct` 类型，并指定一个大于零的值。

```csharp
[System.Runtime.CompilerServices.InlineArray(10)]
public struct Buffer<T>
{
    private T Elem;
}
// 类似于固定缓冲区
public struct Buffer
{
    public unsafe fixed int buffer[1024]; 
}
```

内联数组是一种高级语言功能。它们适用于高性能方案，在这些方案中，内联的连续元素块比其他替代数据结构速度更快。可以像访问数组一样访问内联数组，可以使用范围和索引运算符。

内联数组对单个字段的类型有最低限制：它不能是指针类型，但可以是任何引用类型或任何值类型。几乎可以将内联数组与任何 C# 数据结构一起使用。

运行时团队和其他库作者使用内联数组来提高应用的性能。内联数组使开发人员能够创建固定大小的 `struct` 类型数组。具有内联缓冲区的结构应提供类似于不安全的固定大小缓冲区的性能特征。

```csharp
var buffer = new Buffer<int>();
for (int i = 0; i < 10; i++)
    buffer[i] = i;
foreach (var i in buffer)
    Console.WriteLine(i);
```

---
### Class 

`class` 类型定义了一个数据结构，其中包含了数据成员（常量和字段）、函数成员（方法、属性、事件、索引器、运算符、实例构造函数、静态构造函数和终结器）和嵌套成员。类类型支持继承，这是一种派生类可以扩展和专门化基类的机制。

预定义的类类型在 C# 中具有特殊含义：
- `System.Object`：所有其他类型的最终基类。
- `System.String`：C# 字符串类型。
- `System.ValueType`：所有值类型的基类。
- `System.Enum`：所有枚举类型的基类。
- `System.Array`：所有数组类型的基类。
- `System.Delegate`：所有委托类型的基类。
- `System.Exception`：所有异常类型的基类。
- `System.Attribute`：所有特性类型的基类。

>---
#### Object 对象类型


`object` 类型是 `System.Object` 在 .NET 中的别名。在 C# 的统一类型系统中，所有类型（预定义类型、用户定义类型、引用类型和值类型）都是直接或间接从 `System.Object` 继承的。可以将任何类型的值赋给 `object` 类型的变量。

引用类型的值可以直接隐式转换成 `object`。值类型的值需要经过装箱操作后隐式转换为 `object`。将 `object` 类型的变量转换为值类型的过程称为拆箱。装箱是隐式的，拆箱是显式的。装箱和拆箱的概念是类型系统 C# 统一视图的基础。

```csharp
string str = "Hello World";
object obj = str;  // implicit
string s_str = (string)str;  

int num = 10010;
obj = num;      // implicit boxing
int s_num = (int)num;  // unboxing
```

>---
#### 类声明

类的声明中可以包含一组可选的 `Attribute` 特性、一组可选的类修饰符（访问修饰符，`abstract`、`static`、`sealed` 等）、分部修饰 `partial`、`class` 关键字、一个可选的类型参数列表和类型参数约束、类的标识符、类的主体。

- `public`、`protected`、`internal`、`private` 修饰符控制类类型的可访问性。在顶级类中只能使用 `public` 和 `internal`。
- `partial` 修饰符用以声明分部类。
- `abstract` 声明抽象类，`static` 声明静态类，`sealed` 声明密封类。 

```csharp
public sealed class SampleClass<T> where T : notnull
{
    // ... Members
}
```

>---
#### Abstract Class

抽象类代表抽象实体。其抽象成员定义了从抽象实体派生的对象应包含什么，抽象成员不包含实现。抽象类的大多数功能通常都没有实现。从抽象类派生的子类，必须为抽象基类的抽象方法提供实现。


`abstract` 修饰符用于指示类是不完整的，并打算作为基类。抽象类不能直接实例化为对象，但可以包含派生自抽象类的非抽象类实例的引用。

在抽象类中定义抽象方法，目的是将抽象方法的具体实现（`override`）延迟到派生类。抽象方法是没有实现的特殊虚方法。在基类中也可以声明 `virtual` 虚方法并提供缺省实现，派生类可以重写（`override`）虚方法以扩展或重新定义派生类的行为。

```csharp
interface ISample       // 接口
{
    void Debug(string message);
}
abstract class BaseSample : ISample     // 继承接口并定义抽象方法
{
    public abstract void Debug(string mess);
    public virtual void Error(string mess) => Debug(mess);
}
internal class Sample : BaseSample      // 为抽象类和接口提供方法实现
{
    public override void Debug(string mess) => Console.WriteLine(mess);
    public sealed override void Error(string mess) => base.Error("ERROR : " + mess);
}
```

>---
#### Sealed Class

`sealed` 定义密封类或密封成员，密封类防止被继承，密封成员防止被派生类重写。因此密封类不能是抽象类。这些密封类也支持运行时优化，可以将密封类对象上的虚函数成员的调用转换为非虚调用。

```csharp
using System.Text;

PointArray ps = new((0, 0), (1, 1), (2, 2));
Console.WriteLine(ps);
// Output : (0, 0), (1, 1), (2, 2)

// 定义抽象记录防止被继承
sealed record PointArray(params (int, int)[] points)
{
    // 重写 ToString 方法
    public override string ToString()
    {
        if (points.Length > 0)
        {
            StringBuilder sb = new StringBuilder(points[0].ToString());
            foreach (var p in points[1..])
                sb.Append(", " + p);
            return sb.ToString();
        }
        else return string.Empty;
    }
}
class Point3D: PointArray;  // err: 无法派生密封类
```

>---
#### Generic Class  

类的声明中可以包含若干的类型参数，和一组可选的类型参数约束。具有类型参数的构造类未指定约束时，默认约束为 `object`。声明泛型构造类的实例时，必须指定类型参数的具体类型。

```csharp
Sample<int> Si = new();
Si.Value = 99;

Sample<string> Ss = new();
Ss.Value = "Hello"; 

class Sample<T> where T : struct // T 约束为结构类型
{
    public T Value { get; set; }
}
```

>---
#### Static Class

`static` 修饰符用以声明静态类。静态类不能被实例化，它的成员必须显式地包含静态修饰符（常量和嵌套类型除外）。静态类中可以声明静态扩展方法。

静态类不能被用作类型，无法用作是基类、成员的组成类型、泛型类型参数或类型约束，也不能用于数组类型、`new()`、强制转换、模式匹配、`sizeof`、`default` 表达式等。

加载引用静态类的程序时，.NET 运行时会加载该静态类的类型信息，并在程序中首次引用类之前初始化其字段并调用其静态构造函数。静态构造函数只调用一次，在程序所驻留的应用程序域的生存期内，静态类会保留在内存中。

```csharp
public static class EnumExt
{   
    // 扩展方法
    public static T? ConvertEnum<T>(this int eVal) where T : Enum
        => (T)Enum.ToObject(typeof(T), eVal);  // int 转换为 enum
    public static bool IsDefinedByEnum<T>(this int eVal) where T : Enum
        => Enum.IsDefined(typeof(T), eVal);    // 检查 enum 是否关联整数值
}
```

>---
#### Class Members

一个类可包含的成员有：常量、字段、方法、属性、索引器、运算符、事件、终结器、实例构造函数、静态构造函数和嵌套类型（类、接口、结构、枚举、委托）。

```csharp
class MyClass
{
    // 实例构造函数
    public MyClass() { S_OnDestroy = static delegate { Console.WriteLine("MyClass Destroyed"); }; }
    // 常量
    public const string Version = "0.0.1";
    // 枚举
    public enum Day { workDay, weekDay }
    // 字段
    private readonly static MyClass s_default = new MyClass();
    // 静态属性
    public static MyClass Default => s_default;
    // 实例方法
    public Data CreateData(byte[] data, int id) => new Data(data, id);
    // 索引器
    public int this[int index] => index;
    // 运算符
    public static bool operator ==(MyClass left, MyClass right) => left.Equals(right);
    public static bool operator !=(MyClass left, MyClass right) => !left.Equals(right);
    // 委托
    delegate void OnDestroy();
    // 事件
    event OnDestroy S_OnDestroy;
    // 终结器
    ~MyClass() => S_OnDestroy?.Invoke();
    // 嵌套接口
    public interface INested { }
    // 嵌套类
    sealed class NestedClass : INested { }
    // 嵌套结构
    struct NestedStruct : INested { }
    // 记录
    public readonly record struct Data(byte[] data, int gui);
}
class Sample
{
    static void Main(string[] args)
    {
        MyClass.Data d1 = MyClass.Default.CreateData("Hello"u8.ToArray(), "Hello".GetHashCode());
    }
}
```

>---
#### 基类规范和类继承


类声明中可以包含一个 *class_base* 规范，该规范定义了类的直接基类和类直接实现的接口。若规范中只列出了接口类型，则直接基类是 `object`。C# 类仅支持单一线性继承（不能循环依赖），因此除了 `object` 每个类都仅有一个直接基类。

类从其直接基类继承成员。若直接基类是构造类型，则必须指定构造类型的类型参数（不能是直接基类类型），也可是类本身作为构造类型的类型参数。

```csharp
class Sample<T>;
class DerivedSample : Sample<int>;
class DerivedSample<U> : Sample<U>;
```

*class_base* 中可能包含接口类型的列表，类可以直接实现给定的接口类型。

```csharp
interface ISample
{
    void Fun();
}
class Sample : ISample
{
    public void Fun() => Console.WriteLine("Hello World");
}
```

类继承其直接基类的成员。继承意味着类隐式地包含其直接基类的所有成员，但基类的实例构造函数、终结器和静态构造函数除外。

继承的一些重要方面是:
- 继承是可传递的。如果 c 从 x 派生，x 派生自 A，则 c 继承 B 中声明的成员和 A 中声明的成员。
- 派生类继承其直接基类。派生类可以向其继承的成员添加新成员，但不能删除继承成员的定义。
- 实例构造函数、终结器和静态构造函数不被继承，但所有其他成员都可以继承，不管它们声明的可访问性如何。
- 派生类可以通过声明具有相同名称或签名的新成员来隐藏继承的成员。但是，隐藏继承的成员并不会删除该成员，它只是使该成员无法通过派生类直接访问。
- 类的实例包含在类及其基类中声明的所有实例字段的集合，并且存在从派生类类型到其任何基类类型的隐式转换。因此，对某个派生类实例的引用可以被视为对其任何基类实例的引用。
- 类可以声明虚方法、属性、索引器和事件，派生类可以重写这些函数成员的实现。这使类能够显示多态行为，其中函数成员调用执行的操作取决于调用该函数成员的实例的运行时类型。

>---
#### 类和结构的区别

结构是值类型，具有值语义。类是引用类型，具有引用语义。类实例之间可以相互依赖。但结构体之间相互依赖会导致编译时错误。结构体所依赖的结构体的完整集合是直接依赖关系的传递闭包（值包含值）。

```csharp
// 自我依赖
struct Node
{
    int data;
    Node next;  // 导致闭包循环
}
// 相互依赖
struct A { B b; }
struct B { A a; }
// ===================================
class NodeClass
{
    int data;
    NodeClass next; 
}
class AClass { BClass b;  }
class BClass { AClass b; }
```

> *装箱与拆箱*

只需在编译时将引用视为另一种类型，就可以将类类型的值转换为类型对象或由类实现的接口类型。同样，对象类型的值或接口类型的值可以在不更改引用的情况下转换回类类型（在这种情况下需要进行运行时类型检查）。

```csharp
interface ISample
{
    string Name { get; }
}
class Sample(string name) : ISample
{
    public string Name { get; set; } = name;
    static void Main(string[] args)
    {
        Sample S = new Sample("Hello");
        ISample id = S;             // Sample -> ISample
        Console.WriteLine(id.Name); // Hello
        S.Name = "World";
        Console.WriteLine(id.Name); // World

        Sample S2 = id as Sample;   // ISample -> Sample
    }
}
```

由于结构体不是引用类型，当结构类型的值转换为某些引用类型时，将发生装箱操作。同样，当某个引用类型的值被转换回结构类型时，将发生拆箱操作。与类类型上的相同操作的一个关键区别是，装箱和拆箱将结构体值复制到或复制到已装箱的实例之外。

在装箱或拆箱操作之后，对未装箱结构体所做的更改不会反映在装箱结构体中。

```csharp
interface ISample
{
    string Name { get; set; }
}
struct Sample(string name) : ISample
{
    public string Name { get; set; } = name;
    static void Main(string[] args)
    {
        Sample S = new Sample("Hello");
        ISample id = S;             // Sample -> ISample
        Console.WriteLine(id.Name); // Hello
        S.Name = "World";
        Console.WriteLine(id.Name); // Hello
        S.Name = id.Name;
        Console.WriteLine(((Sample)id).Equals(S));  // True, 值相等性

        id.Name = "World";
        if (id is Sample S2)    // ISample -> Sample
            Console.WriteLine(S2.Name);  // World
    }
}
```

>---
#### Boxing & unboxing

装箱和拆箱的概念提供了值类型和引用类型之间的桥梁。允许值类型的任何值和 `object` 之间进行转换。拆箱和装箱支持对类型系统的统一视图，任何类型的值最终都可以被视为对象。

装箱用于在垃圾回收堆中存储值类型。装箱是值类型到引用类型的隐式转换。对值类型装箱会在堆中分配一个对象实例，并将该值复制到新的对象中。对于可空值类型，若 `HasValue` 为 `false`，装箱时将产生空引用，否则将展开并装箱其基础类型的值。

> *装箱*

装箱转换意味着对被装箱的值做一个副本。存在以下装箱转换：

- 从任意值类型到 `object`。
- 从任意值类型到 `System.ValueType`。
- 从任意枚举类型到 `System.Enum`。
- 从任意非空值类型到其实现的接口类型 `I`，包含协变接口。
- 从任意可空值类型到引用类型，其中存在 `T?` 的底层类型 `T` 到引用类型的装箱转换。

> *装箱模拟*

- 假设每个值类型存在一个对应的装箱类来模拟装箱过程。

```csharp
interface ISample
{
    void Fun();
}
struct S : ISample
{
    public void Fun() { }
}
sealed class S_Boxing<T>(T value) : ISample where T : ISample
{
    T Value = value;
    public void Fun() => Value.Fun();
}
```

- 装箱一个值类型。

```csharp
S s = new S();
object box = s;

// 可以想象为
S s = new S();
object box = new S_Boxing<S>(s);
```

- 实际上假象的 `S_Boxing` 并不存在，类型 `S` 的装箱值具有运行时类型，可以使用类型测试左操作数是否为右操作数的装箱版本。

```csharp
int i = 123;
object box = i;
if(box is int)
    Console.WriteLine("Box contains an int");
```

> *拆箱*

取消装箱（拆箱）是从引用类型到值类型的显式转换。拆箱操作首先要检查对象实例的运行时类型，以确保它是给定目标值类型的装箱值，然后再将该值从实例复制到值类型变量中。

被取消装箱的项必须是对一个对象的引用，该对象是先前通过装箱该值类型的实例创建的。目标类型是非空值类型时，尝试取消装箱 `null` 会导致 `NullReferenceException`。若是可空值类型，包含 `null` 的引用类型可以拆箱到该目标类型，否则拆箱到其基础值类型。尝试取消装箱对不兼容值类型的引用会导致 `InvalidCastException`。

如果值类型必须被频繁装箱，那么在这些情况下最好避免使用值类型。可通过使用泛型集合（例如 `System.Collections.Generic.List<T>`）来避免装箱值类型。

装箱和取消装箱过程需要进行大量的计算。对值类型进行装箱时，必须创建一个全新的对象，这可能比简单的引用赋值用时最多长 20 倍。取消装箱的过程所需时间可达赋值操作的四倍。

```csharp
int i = 123;
object o = i;  // implicit boxing
try
{
    int j = (short)o;  // attempt to unbox
    System.Console.WriteLine("Unboxing OK.");
}
catch (System.InvalidCastException e)
{
    System.Console.WriteLine("Error: Incorrect unboxing. \n{0}", e.Message);
    int j = (int)o;
    System.Console.WriteLine("Correct unboxing.");
}
/**
    Error: Incorrect unboxing.
    Unable to cast object of type 'System.Int32' to type 'System.Int16'.
    Correct unboxing.
 */
```

---
### Interface

`interface` 定义了一个协议，实现接口的类型必须遵循它的协议。一个接口可以继承多个基接口，一个类或结构可以实现多个接口。

接口类型可以包含方法、属性、事件、索引器，也可以包含静态构造函数、静态成员、常量、运算符、嵌套类型等，这些成员默认的可访问性是 `public`。

```csharp
interface ISample
{
    // 实例成员
    void FunA();
    int Value { get; set; }
    event Action MEvent;
    int this[int index] { get; set; }

    // 静态成员
    static ISample() { Console.WriteLine("Static ISample"); }
    static int GUI => 10010;
    static Action StaticEvent;
    const string TypeName = nameof(ISample);
    static ISample operator ++(ISample s)
    {
        s.Value++;
        return s;
    }

    // 嵌套类型
    delegate void OnInvoke();
    class Nested;
    interface INestedSample;
}
class Sample : ISample
{
    public int this[int index] { get => throw new NotImplementedException(); set => throw new NotImplementedException(); }
    public int Value { get => throw new NotImplementedException(); set => throw new NotImplementedException(); }
    public event Action MEvent;
    public void FunA() => throw new NotImplementedException();
}
```

类的属性和索引器可以为接口中定义的属性或索引器定义额外的访问器。若接口属性或索引器使用显式接口实现而不是派生类型隐式实现时，访问器必须匹配。

```csharp
interface ISample
{
    int Value { get; }
    string Name { get; }
}
class Sample : ISample
{
    public int Value { get; set; }  // 额外的 set 访问器
    string ISample.Name { get; /* set; // err */ }
}
```

>---
#### 隐式实现与显式接口实现

类或结构应提供继承接口中未实现成员的实现定义，在实现类或结构中定位接口成员的实现的过程称为接口映射。可以以隐式或显式接口方式实现继承的接口成员。隐式实现的成员只能声明为 `public` 且无法修改访问修饰符，但可以声明为 `abstract` 或 `virtual`。显式接口实现的方法无法添加访问修饰符或 `abstract`、`virtual`、`sealed`。

```csharp
interface ISample
{
    void FunA();
    void FunB();
}
class Sample : ISample
{
    public virtual void FunA() { /* ... */ }  // 隐式实现，添加 virtual
    async void ISample.FunB() { /* ... */ }  // 显式接口实现，声明为异步方法
}
```

若当接口方法映射到类中的虚方法（使用隐式实现）时，派生类则可能重写虚方法并更改接口的实现和映射关系。

```csharp
interface ISample
{
    void Fun();
}
class Sample  : ISample
{
    public virtual void Fun() => Console.WriteLine("Sample Fun");
}
class Derived : Sample
{
    public override void Fun() => Console.WriteLine("Derived Fun");
    static void Main(string[] args)
    {
        Sample s = new Sample();
        Derived d = new Derived();
        ISample Is = s;
        ISample Id = d;
        s.Fun();    // Sample Fun
        d.Fun();    // Derived Fun
        Is.Fun();   // Sample Fun
        Id.Fun();   // Derived Fun
    }
}
```

对于多继承接口，当两个或多个不相关的基接口声明具有相同名称或签名的成员时，可能会出现歧义。

```csharp
interface ICounter
{
    void Count(int c);
    int Value { get; set; }
    void Fun();
}
interface IList
{
    int Count { get; set; }
    int Value { get; set; }
    void Fun();
}
interface IListCounter : ICounter, IList;

class Sample
{
    public void Test(IListCounter x)
    {
        x.Value = 100;  // 歧义
        x.Fun();        // 歧义

        x.Count(1);
        x.Count = 1;   // 被隐藏，
        ((IList)x).Count = 1;
        ((ICounter)x).Count(1);
    }
}
```

为消除接口之间的歧义，类或接口可以声明显式接口成员实现，用以调用限定于接口的成员。类或结构的显式接口实现不包含任何修饰符，它不作为实现类型的成员，只能通过接口实例调用。

```csharp
Sample logger = new Sample();
string mess = "Hello World";
logger.Print(mess);
((IDebug)logger).Print(mess);
((IError)logger).Print(mess);
/* Output
 Hello World
 DEBUG : Hello World
 ERROR : Hello World
*/

interface IDebug{
    void Print(string mess);
}
interface IError{
    void Print(string mess);
}
class Sample : IDebug, IError
{
    // 显式接口实现
    void IDebug.Print(string mess) => Console.WriteLine("DEBUG : " + mess);
    void IError.Print(string mess) => Console.WriteLine("ERROR : " + mess);
    // 默认实现
    public void Print(string mess) => Console.WriteLine(mess);
}
```

若接口函数成员具有一个参数数组，末位排序的参数数组在派生类型中实现时可以在类或结构中可选地附加 `params` 修饰。若接口方法的参数是一个数组，隐式实现时可选地附加 `params` 修饰，显式接口实现时不能附加。

```csharp
interface ISample
{
    void Fun(params int[] arr);
    void FunB(int[] arr);
}
class Sample : ISample
{
    public void Fun(params int[] arr) { }  // 默认实现
    public void FunB(params int[] arr) { }

    // or
    void ISample.Fun(params int[] arr) { }     // 显式接口实现
    void ISample.FunB(int[] arr) { }
}
```

> 显式接口实现的目的

- 由于显式接口成员不能通过类或结构实例访问，因此它们允许将接口实现排除在类或结构的公共接口之外。
- 显式接口成员实现允许消除具有相同签名成员的歧义。若没有显式接口成员实现，类和结构就不可能具有相同签名和返回类型的接口成员的不同实现。


>---
#### 接口成员默认实现

一般而言，接口不提供其成员的实现，仅用来指定实现接口的类或结构应提供实现的成员。接口可为成员定义默认实现，以便提供常见功能的默认实现。接口成员中提供的默认实现等效于派生类型中的显式接口实现，只能通过接口实例进行访问。

```csharp
interface ISample
{
    void FunA();
    void FunB() => Console.WriteLine("ISample.FunB");  // 默认实现的接口方法
}
class Sample : ISample
{
    public void FunA() => Console.WriteLine("Sample.FunA");
    static void Main(string[] args)
    {
        Sample s = new Sample();
        s.FunA();       // Sample.FunA

        ISample s2 = s; 
        s2.FunA();      // Sample.FunA
        s2.FunB();      // ISample.FunB
        // 接口实例访问显式实现的成员
    }
}
```

具有默认实现的接口方法不要求其派生类型显式接口重定义，接口实现类型可以重定义具有默认实现（非 `sealed` 或 `private`）的接口成员，以改变派生继承的接口映射关系：
- 派生接口只能通过显式接口方式重写基接口方法，可以将基接口方法重新声明为抽象 `abstract`。
- 派生类型可以通过显式接口方式或隐式方式实现继承的接口方法，并改变派生类型与基接口的映射关系。

```csharp
interface ISampleA
{
    void FunA();
    void FunB() => Console.WriteLine("ISample.FunB");  // 默认实现的接口方法
}
interface ISampleB : ISampleA
{
    abstract void ISampleA.FunB();   // 重新声明为 abstract
}
class Sample : ISampleA, ISampleB
{
    public void FunA() => Console.WriteLine("Sample.FunA From ISampleA");
    public void FunB() => Console.WriteLine("Sample.FunB From ISampleB");  
    // 覆盖继承的接口映射, 可以是隐式或显式实现
    static void Main(string[] args)
    {
        Sample s = new Sample();
        s.FunA();       // Sample.FunA From ISampleA

        ISampleA s2 = s;
        s2.FunA();      // Sample.FunA From ISampleA
        s2.FunB();      // Sample.FunB From ISampleB

        ISampleB s3 = s;
        s3.FunA();      // Sample.FunA From ISampleA
        s3.FunB();      // Sample.FunB From ISampleB
    }
}
```

没有默认实现的接口成员是隐式公共抽象的，可以显式指定可访问性修饰符。其中 `private`、`virtual`、`sealed` 修饰的成员必须有默认实现。具有默认实现的非私有成员，是隐式 `virtual` 的，可以显式指定为 `virtual`。声明为 `sealed` 的接口成员无法被派生接口或派生类型通过显式接口重定义的方式改变从基接口继承的接口映射关系，即使是在派生类或接口中使用隐式方式实现，但是可以在派生接口中使用 `new` 隐藏继承的成员。

```csharp
interface ISampleA
{
    void FunA();
    private void FunInline() => Console.WriteLine("ISampleA.FunInline");
    sealed void FunB() => Console.WriteLine("ISampleA.FunB");  // 默认实现的接口方法
    virtual void FunC() => FunInline();  // virtual,sealed,private 方法需要有方法主体
}
interface ISampleB : ISampleA
{
    //void ISampleA.FunB() { }   // err, 无法通过显式实现改变继承的接口映射
    new void FunB();  // new 隐藏 ISampleA.FunB 并成为 ISampleB 的成员
}
class Sample : ISampleA, ISampleB
{
    public void FunA() => Console.WriteLine("Sample.FunA From ISampleA");
    public void FunB() => Console.WriteLine("Sample.FunB From ISampleB");
    static void Main(string[] args)
    {
        Sample s = new Sample();
        s.FunA();       // Sample.FunA From ISampleA

        ISampleA s2 = s;
        s2.FunA();      // Sample.FunA From ISampleA
        s2.FunB();      // ISampleA.FunB     
        s2.FunC();      // ISampleA.FunInline

        ISampleB s3 = s;
        s3.FunA();      // Sample.FunA From ISampleA
        s3.FunB();      // Sample.FunB From ISampleB
        s3.FunC();      // ISampleA.FunInline
    }
}
```

密封或私有的接口方法无法在派生中通过显式接口实现的方式进行重定义以改变从基接口继承的接口映射。即使在派生类型中声明为 `public` 方法，也无法覆盖继承的接口映射关系。接口的 `private` 方法是隐式密封的。

```csharp
interface ISample
{
    private void Fun(int a) => Console.WriteLine($"ISample.Fun({a})");
    // private >> protected 或其他访问修饰符
    // protected void Fun(int a) => Console.WriteLine($"ISample.Fun({a})");  // Output: Sample.Fun(10)
    sealed void Output(int a)
    {
        Console.Write("ISample.Output : ");
        Fun(a);
    }
}
class Sample : ISample
{
    public void Fun(int a) => Console.WriteLine($"Sample.Fun({a})");
    public void Output(int a)
    {
        Console.Write("Sample.Output : ");
        Fun(a);
    }
    static void Main(string[] args)
    {
        Sample s = new Sample();
        s.Output(10010);  // Sample.Output : Sample.Fun(10010)  // 无法改变接口映射

        ISample sample = s;
        sample.Output(10010);  // ISample.Output : ISample.Fun(10010)
    }
}
```

>---
#### 泛型方法的实现

当泛型方法隐式实现接口方法时，为每个方法类型参数给出的约束在两个声明中应该是等效的（在任何接口类型参数被适当的类型参数替换之后），其中方法类型参数由从左到右的顺序位置标识。隐式实现的方法必须显式指定约束（类型参数是 `object` 的约束不需要显式指定约束），而显式接口实现的方法隐式继承类型参数约束，不能显式声明约束。当隐式实现的约束声明不合法时，只能通过显式方式实现接口成员。

```csharp
interface ISample<X, Y, Z>
{
    void FunA<T>(T t) where T : X?;
    void FunB<T>(T t) where T : Y;
    void FunC<T>(T t) where T : Z;
}

class C : ISample<object, C, string>
{
    public void FunA<T>(T t) { }                  // Ok，`FunA` 不需要指定 `where T:object` 约束，因为 `object` 是所有类型参数的隐式约束。
    public void FunB<T>(T t) where T : C { }      // Ok，`FunB` 指定的约束和接口中的约束匹配
//  public void FunC<T>(T t) where T : string { } // Error，只能显式接口实现
    void ISample<object, C, string>.FunC<T>(T t) { }
}
```

>---
#### 接口重实现

在类中显式方式实现的接口无法在派生类中重写接口映射，除非在子类中添加接口到 *class_base* 以进行接口的重实现。派生类的隐式或显式重实现的接口成员将覆盖从基类继承的接口映射关系。

```csharp
interface ISample
{
    void Fun();
}
class Sample : ISample
{
    void ISample.Fun() => Console.WriteLine("Sample Fun");
}
class Derived : Sample, ISample
{
    public void Fun() => Console.WriteLine("Derived Fun");  // 接口重新映射
    static void Main(string[] args)
    {
        Sample s = new Sample();
        Sample sd = new Derived();
        Derived d = new Derived();
        ISample Is = s;
        ISample Isd = sd;
        ISample Id = d;
        Is.Fun();   // Sample Fun
        Isd.Fun();  // Derived Fun
        Id.Fun();   // Derived Fun
    }
}
```

>---
#### 抽象类与接口

与非抽象类一样，抽象类应提供在类的基类列表中列出的所有接口成员的实现。但是，允许抽象类将接口方法映射到抽象方法上。显式接口实现的成员不能是抽象的。

```csharp
interface ISample
{
    void Fun();
    int Value { get; }
}
abstract class AbSample : ISample
{
    public abstract int Value { get; }
    void ISample.Fun() => Console.WriteLine(Value);
}
```

>---
#### 接口的静态抽象和虚拟成员

从 C# 11 开始，接口可以声明除静态字段之外的所有静态成员类型的 `static abstract` 和 `static virtual` 成员。

```csharp
interface ISample
{
    static abstract void Func();
    static abstract event Action E;
    static abstract object Proper { get; set; }
}
interface ISample<T> where T : ISample<T>
{
    static abstract void Func();
    static abstract event Action E;
    static abstract T P { get; set; }
    static abstract object Proper { get; set; }
    static abstract T operator +(T l, T r);
    static abstract bool operator ==(T l, T r);
    static abstract bool operator !=(T l, T r);
    static abstract implicit operator T(string s);
    static abstract explicit operator string(T t);
}
```

接口指定静态抽象成员，然后要求类和结构为接口抽象静态成员提供显式或隐式实现，静态虚成员具有默认实现。显式实现的接口静态 `abstract` 或 `virtual` 成员只能从受接口约束的类型参数上访问，隐式实现的接口静态 `abstract` 或 `virtual` 成员可以通过派生类型直接访问。

```csharp
interface ISample
{
    static abstract void FunA();
    static abstract void FunB();
    static virtual void FunC() => Console.WriteLine("Static ISample.FunC");
}
class Sample : ISample
{
    public static void FunA() => Console.WriteLine("Static Sample.FunA");
    static  void ISample.FunB() => Console.WriteLine("Sample: Static ISample.FunB");
    static void Main(string[] args)
    {
        // 派生类直接访问
        Sample.FunA();   // Static Sample.FunA

        Test<Sample>();
    }
    static void Test<T>() where T : ISample
    {
        // 通过类型参数访问接口成员
        T.FunA();    // Static Sample.FunA
        T.FunB();    // Sample: Static ISample.FunB
        T.FunC();    // Static ISample.FunC
    }

    // public static void FunC() => Console.WriteLine("Static Sample.FunC");  // 隐式重定义
    // Test<Sample>: T.FunC();   // Static Sample.FunC
    // Sample.FunC();   // 隐式方式实现的静态虚成员可以直接通过派生类型访问
}
```

派生接口同样可以重新定义从基接口继承静态抽象或静态虚成员。

```csharp
interface ISample
{
    static abstract void FunA();
    static abstract void FunB();
    static virtual void FunC() => Console.WriteLine("Static ISample.FunC");
}
interface IDerivedSample: ISample
{
    static void ISample.FunA() => Console.WriteLine("IDerivedSample : Static ISample.FunA");  // 接口重定义
    static abstract void ISample.FunC();  // 重新定义为 static abstract
}
```

接口中声明的 `static virtual` 和 `static abstract` 方法没有类似于类中声明的 `virtual` 或 `abstract` 方法的运行时调度机制。相反，编译器使用编译时可用的类型信息，即调用基（编译时）类型的静态方法。`static virtual` 和 `static abstract` 方法几乎完全是在泛型接口中声明的。

```csharp
interface ISample<T> where T : ISample<T>, new()
{
    static virtual void Fun() { }
    static virtual T Value { get; } = new T();
    static abstract event Action E;
    static abstract T operator ++(T t);
}

struct Sample : ISample<Sample>
{
    public int Value { get; set; } = 0;
    public Sample(int value)
    {
        this.Value = value;
    }
    static void ISample<Sample>.Fun() { }  // 显式重定义
    public static event Action E;  // 隐式实现

    // 显式实现，无法从 Sample 访问, 只能通过类型参数访问
    static Sample ISample<Sample>.operator ++(Sample s)
    {
        s.Value++;
        return s;
    }
    static void Main(string[] args)
    {
        Sample s = new Sample(99);
        s.Increment(ref s);
        Console.WriteLine(s.Value);  // 100
    }
    void Increment<T> (ref T t) where T : ISample<T>,new()
    {
        t++;  // 类型参数访问
    }
}
```

对于与非虚实例成员的对称，静态非字段成员允许使用可选的 `sealed` 修饰符，即使它们默认是非虚的：

```csharp
interface ISample
{
    static sealed void M() => Console.WriteLine("Default behavior");

    static int f = 0;
    static sealed int P1 { get; set; }
    static sealed int P2 { get => f; set => f = value; }

    static sealed event Action E1;
    static sealed event Action E2 { add => E1 += value; remove => E1 -= value; }
    static sealed ISample operator +(ISample l, ISample r) => l;
}
```

---
### String

`string` 类型是直接从 `object` 继承的密封类类型，它的实例表示一段 Unicode 字符序列。`string` 是预定义类 `System.String` 的别名。相等运算符 `==` 和 `!=` 用以比较 `string` 对象的值，而不是比较 `string` 对象的引用。

```csharp
string str1 = "hello";
string str2 = "h";
str2 += "ello";
Console.WriteLine(str1 == str2);  // true
Console.WriteLine(object.ReferenceEquals(str1, str2)); // false
```

`+` 用于拼接两个字符串片段。字符串是不可变的，每次赋值时，编译器实际上会创建一个新的字符串对象来保存新的字符序列，并将新对象赋值给目标，并将之前的内存用于垃圾回收。

```csharp
string str = "Hello " + "World!";
```

`[]` 运算符可用于访问字符串字符序列中的指定索引位置的字符。

```csharp
string str = "test";
for (int i = 0; i < str.Length; i++)
  Console.Write(str[i] + " ");
// Output: t e s t
```

>---
#### 内插字符串

`$` 字符将字符串字面量标识为内插字符串，内插字符串是可能包含内插表达式的字符串文本。将内插字符串解析为结果字符串时，带有内插表达式的项会替换为表达式结果的字符串表示形式。大括号转义序列（`{{` 和 `}}`）表示为 `{` 和 `}` 的字符串形式。

```csharp
$"{<interpolationExpression>[,<alignment>][:<formatString>]}"
// - interpolationExpression     生成需要设置格式的结果的表达式
// - alignment                   常数表达式，定义对齐方式和最小字符宽度，负值表示左对齐，正值表示右对齐
// - formatString                受表达式结果类型支持的格式字符串，例如 DateTime 格式化输出

Console.WriteLine($"|{"Left",-7}|{"Right",7}|");
// |Left   |  Right|

const int FieldWidthRightAligned = 20;      // $"{{" 打印 {
Console.WriteLine($"{{{Math.PI,FieldWidthRightAligned}}} - default formatting of the pi number");
Console.WriteLine($"{{{Math.PI,FieldWidthRightAligned:F3}}} - display only three decimal digits of the pi number");
//{   3.141592653589793} - default formatting of the pi number
//{               3.142} - display only three decimal digits of the pi number

string message = $"The usage policy for {safetyScore} is {
    safetyScore switch
    {
        > 90 => "Unlimited usage",
        > 80 => "General usage, with daily safety check",
        > 70 => "Issues must be addressed within 1 week",
        > 50 => "Issues must be addressed within 1 day",
        _ => "Issues must be addressed before continued use",
    }}";
```

内插字符串初始化常量时，所有的内插表达式也必须是常量字符串。

```csharp
public class Sample
{
    const string S1 = $"Hello world";
    const string S2 = $"Hello{" "}World";
    const string S3 = $"{S1} Kevin, welcome to the team!";
}
```

C# 11 起内插表达式支持使用换行，以使表达式更具有可读性。

```csharp
var v = $"Count is\t: {this.Is.A.Really(long(expr))
                            .That.I.Should(
                                be + able)[
                                    to.Wrap()]}.";
```

>---
#### 逐字字符串

`@` 指示将原义解释字符串。简单转义序列（如代表反斜杠的 `"\\"`）、十六进制转义序列（如代表大写字母 A 的 `"\x0041"`）和 Unicode 转义序列（如代表大写字母 A 的 `"\u0041"`）都将按字面解释。引号转义 `""` 不会按字面解释。

逐字内插字符串中，大括号转义序列（`{{` 和 `}}`）不按字面解释。

```csharp
string filename1 = @"c:\documents\files\u0066.txt";
string filename2 = "c:\\documents\\files\\u0066.txt";
Console.WriteLine(filename1);
Console.WriteLine(filename2);
// The example displays the following output:
//     c:\documents\files\u0066.txt
//     c:\documents\files\u0066.txt

string str = $@"{{{Math.PI,20}}} >> ""default formatting of the pi number""";
Console.WriteLine(str);
//{   3.141592653589793} >> "default formatting of the pi number"
```

>---
#### 原始字符串

原始字符串字面量从 C# 11 开始可用。字符串字面量可以包含任意文本，而无需转义序列，字符串字面量可以包括空格和新行、嵌入引号以及其他特殊字符。原始字符串字面量用至少三个双引号（`"""`）的分隔符括起来。

```csharp
var message = """
This is a multi-line
    string literal with the second line indented.
""";
// 原始字符串的起始、结束引导序列长度要超过字符串中最长的引号序列长度
"""""
This raw string literal has four """", count them: """" four!
embedded quote characters in a sequence. That's why it starts and ends
with five double quotes.

You could extend this example with as many embedded quotes as needed for your text.
"""""
```

原始字符串支持单行形式，分隔符和字符串内容在同一行。单行形式不参与行首空格缩进。

```csharp
var str = """This is a single line""";
```

多行原始字符串的字面量分隔符必须位于自己的行，末尾分隔符的右侧决定了原始字符串的行缩进。

```csharp
var str = """
    This is a multi-line
        string literal with the second line indented.
""";
Console.WriteLine(str);
/* output
    This is a multi-line
        string literal with the second line indented.
| <--- 行缩进位置
*/

var str2 = """
    This is a multi-line
        string literal with the second line indented.
    """;
/* output
This is a multi-line
    string literal with the second line indented.
| <--- 行缩进位置
*/
```

原始字符串也支持内插表达式，字符串指定开始插值所需的大括号数目（由开头的内插字符 `$` 数目决定），任何少于这个数的大括号序列都被视为字符串内容。

```csharp
string value = "text";
var str =
    $$"""
    {
        "Summary": {{value}},
        "length": {{value.Length}}
    }
    """;
string value2 = $$"""{{
    1
    + 2
    + 3}}""";  // 被视为单行原始字符串
```

>---
####  UTF-8 字符串

.NET 中的字符串是使用 UTF-16 编码存储的。UTF-8 是 Web 协议和其他重要库的标准。从 C# 11 开始，可以将 `u8` 后缀添加到字符串以指定 UTF-8 编码。UTF-8 字符串存储为 `ReadOnlySpan<byte>` 对象，两个 `UTF-8` 字符串之间可以拼接。UTF-8 字符串不支持字符串内插，但可以是 `@` 逐字字符串。

```csharp
using System.Text;

// u8 to u16
ReadOnlySpan<byte> strU8 = @"Hello world!"u8;
string strU16 = Encoding.UTF8.GetString(strU8);
Console.WriteLine(strU16);

// u16 to u8
string str = "Hello world!";
ReadOnlySpan<byte> bytes = Encoding.UTF8.GetBytes(str);

// u8 + u8
ReadOnlySpan<byte> str1 = "Hello"u8 + " World"u8;
```

---
### Array

数组是一种包含零个到多个变量的数据结构，通过索引访问数字元素，它们具有相同的类型。类型 `System.Array` 是所有数组类型的抽象基类型。

数组具有确定与每个元素相关联的索引的秩，数组的秩也被称为数组的维数。秩为一的数组称为一维数组，秩大于一的数组称为多维数组，特定尺寸的多维数组通常被称为二维数组、三维数组等。

数组的每个维度都有一个相关联的长度，该长度是一个大于等于零的整数。维度长度不是数组类型的一部分，而是在运行时创建数组类型的实例时建立的。维度的长度决定了该维度索引的有效范围：对于长度为 N 的维度，索引的范围可以从 0 到 N-1。数组中元素的总数是数组中每个维度长度的乘积。如果数组的一个或多个维度的长度为零，则称该数组为空。

> *数组声明*

```csharp
// 几种声明数组的形式
int[] arr1 = new int[10];        // 元素均初始化为 0
int[] arr2 = { 0, 1, 2, 3 };     // 初始化构造
int[] arr3 = new int[] { 1, 2, 3 };
int[] arr4 = new int[3] { 1, 2, 3 };
int[] arr5 = new[] { 1, 2, 3 };
int[] arr6 = [10, 20, 30];       // 集合表达式

// 多维数组的声明
int[] a1 = new int[10];             // 一维数组
int[,] a2 = new int[10, 5];         // 二维数组
int[,,] a3 = new int[10, 5, 2];     // 三维数组
```

数组的元素类型本身也可以是数组类型，这类数组不同于多维数组，被称为交错数组。

```csharp
int[][] pascals = 
{
    new int[] {1},
    new int[] {1, 1},
    new int[] {1, 2, 1},
    new int[] {1, 3, 3, 1}
};
```

> *数组访问*

```csharp
// 一维数组
int[] arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
for (int i = 0; i < arr.Length; i++)
    arr[i] *= arr[i];
Console.WriteLine(arr.Rank); // 数组的秩
Console.WriteLine(string.Join(",", arr));

// 多维数组
int[,] Matrix3_4 = new int[3, 4] {
    { 31, 32, 33, 34 },
    { 24, 25, 26, 27 },
    { 19, 18, 17, 16 }
};
Console.WriteLine(Matrix3_4.Rank);
for (int L = 0, r = 0, i = 0; L < Matrix3_4.Length; L++)
{
    (r, i) = Math.DivRem(L, Matrix3_4.GetLength(0) + 1);
    Console.WriteLine($"Matrix3_4[{r},{i}] = {Matrix3_4[r, i]}");
}
```

> *匿名类型的数组*

```csharp
var arr = new[] {
    new{ name = "Hello", Id = 1 },
    new{ name = "World", Id = 2 },
    new{ name = "Empty", Id = 3 },
};
```


>---
#### 数组和泛型集合接口

一个单维数组 `T[]` 实现了 `System.Collections.Generic.IList<T>` 接口，因此存在从 `T[]` 到 `IList<T>` 及其基接口的隐式转换。同样 `T[]` 也实现了 `System.Collections.Generic.IReadOnlyList<T>` 接口。

```csharp
class Test
{
    static void Main()
    {
        int[] arr = new int[] { 0, 1, 2, 3, 4 };
        IList<int> list = arr;
        IReadOnlyList<int> rolist = arr;
    }
}
```

若 `S` 到 `T` 存在引用隐式转换，则 `S[]` 也可以隐式转换为 `IList<T>` 或 `IReadOnlyList<T>`。

```csharp
class Test
{
    static void Main()
    {
        string[] sa = new string[5];
        object[] oa1 = new object[5];
        object[] oa2 = sa;

        IList<string> lst1 = sa;  // Ok
        IList<string> lst2 = oa1; // Error, cast needed
        IList<object> lst3 = sa;  // Ok
        IList<object> lst4 = oa1; // Ok

        IList<string> lst5 = (IList<string>)oa1; // Exception
        IList<string> lst6 = (IList<string>)oa2; // Ok

        IReadOnlyList<string> lst7 = sa;        // Ok
        IReadOnlyList<string> lst8 = oa1;       // Error, cast needed
        IReadOnlyList<object> lst9 = sa;        // Ok
        IReadOnlyList<object> lst10 = oa1;      // Ok
        IReadOnlyList<string> lst11 = (IReadOnlyList<string>)oa1; // Exception
        IReadOnlyList<string> lst12 = (IReadOnlyList<string>)oa2; // Ok
    }
}
```

---
### Delegate

委托是引用一个或多个方法的数据结构。委托的声明定义了一个从 `System.Delegate` 派生的类。委托实例封装了一个调用列表，该列表是一个或多个方法的列表，每个方法都是一个可调用实体。对于实例方法，可调用实体由实例和该实例上的方法组成。对于静态方法，可调用实体仅由一个方法组成。调用委托时，将导致调用这个列表上的每个可调用实体。

在 C/C++ 中，与委托最接近的等效项是函数指针。C# 的函数指针只能引用静态函数，而委托可以引用静态和实例方法，并且委托还存储了对方法入口点的引用和对调用方法的对象实例引用。

委托类型的声明与方法签名相似，它有一个返回值和任意数目任意类型的参数。委托类型是一种可用于封装命名方法或匿名方法的引用类型，是面向对象的、类型安全的和可靠的。

使用 `delegate` 关键字声明委托类型，编译器将委托相关的操作代码的调用映射到 `System.Delegate` 和 `System.MulticastDelegate` 类成员的方法调用。必须使用具有兼容返回类型和输入参数的方法或 Lambda 表达式实例化委托。在实例化委托时，可以将委托的实例与任何兼容的方法相关联，并可以通过委托实例调用方法。

在构造委托时，编译器会为委托类型生成四个方法：
- 一个实例构造函数；
- 一个用于同步调用的 `Invoke` 实例方法，它的参数和委托类型的签名一致；
- （可选的）两个用于异步调用的 `BeginInvoke` 和 `EndInvoke` 方法：
  - `BeginInvoke` 除了具有 `Invoke` 相同位置的参数外，还有两个额外的参数（`System.AsyncCallback` 和 `System.Object`）。`BeginInvoke` 方法返回一个 ``System.IAsyncResult`` 类型。
  - `EndInvoke` 返回类型和委托类型定义中的返回类型相同。若委托签名中包含输出参数 `out`，则在 `EndInvoke` 中包含这些 `out` 参数；它还有一个额外的和 `BeginInvoke` 方法的返回值类型相同的参数。

```csharp
// 委托的定义
delegate void StartStopEventHandler(int action);
// 假设编译器为委托对象生成的类声明和成员声明
sealed class StartStopEventHandler : System.Delegate // or System.MulticastDelegate
{
    public StartStopEventHandler(object @object, IntPtr method) { }

    public void Invoke(int action) { }
    public IAsyncResult BeginInvoke(int action, AsyncCallback callback, object @abject) { }
    public void EndInvoke(IAsyncResult asyncResult) { }
}
```

将方法作为参数进行引用的能力使委托成为定义回调方法的理想选择。委托类似于 C++ 函数指针，但委托面向对象，会同时封装对象实例和方法，因此委托允许将方法作为参数进行传递。

```csharp
MessageDelegate debug = Console.WriteLine;
if (debug is MulticastDelegate or Delegate)
    debug("Hello World >>> " + debug.Method.Name);

public delegate void MessageDelegate(string message);
public delegate int AnotherDelegate(int num1, int num2);
```

在 .NET 中，`System.Action`、`System.Func`、`System.Predicate` 类型为许多常见委托提供泛型定义。

```csharp
Action<string> MessagePrint = null;
// 方法
void Print(string mess) => Console.WriteLine("Function : " + mess);
MessagePrint += Print; 
// delegate 匿名方法
MessagePrint += delegate (string mess){
    Console.WriteLine("Delegate : " + mess);
};
// Lambda 表达式
MessagePrint += message => Console.WriteLine("Lambda : " + message);

// 委托调用
MessagePrint("Hello World!"); 
MessagePrint?.Invoke("Hello World!"); // 等效写法
```

委托创建表达式的参数应该是一个方法组、一个匿名函数或编译时类型 `dynamic` 或委托类型的值。

委托的调用列表在实例化委托时确定，然后在委托的整个生命周期内保持不变。一旦创建了委托，就不可能更改委托的可调用实体 `Target`。当两个委托合并或从另一个委托中删除一个委托时，将产生一个新的委托，现有委托的内容没有更改。

不能创建引用属性、索引器、用户定义运算符、实例构造函数、终结器或静态构造函数的委托。 

```csharp
class Sample
{
    delegate double DoubleFunc(double x);
    DoubleFunc f = new DoubleFunc(Square);
    static double Square(double x) => x * x;
}
```

> `delegate` *匿名方法*

`delegate` 运算符创建一个可以转换为委托类型的匿名方法。匿名方法可以转换为 `System.Action` 和 `System.Func<TResult>` 等类型，用作许多方法的参数。

```csharp
// delegate 匿名方法
Func<int, int, int> sum = delegate (int a, int b) { return a + b; };
// lambda 匿名方法
var _Debug = (string message) => MessagePrint?.Invoke(message);
```

>---
#### 多播委托

可以通过使用 `+` 组合多个委托对象分配到一个委托实例中。多播委托中包含已分配委托列表，此多播委托被调用时会按照添加的先后顺序依次调用列表中的委托。`-` 用于从多播委托中删除组件委托。

`+=` 可以将方法或匿名方法构造为委托对象并分配到多播委托中，`-=` 则表示从多播委托中移除该方法的委托实例。`+`、`-` 运算符支持委托对象和方法组之间的运算。

一个委托可以多次出现在调用列表中，这样的委托被删除时，总是删除调用列表的最后一个。删除委托对象时，若右操作数是 Lambda 表达式或匿名方法（非匿名类型）时，此操作无效。

```csharp
class Sample
{
    delegate void SampleDelegate();
    private static void Function_1() => Console.WriteLine("Function_1");
    private static void Function_2() => Console.WriteLine("Function_2");

    static SampleDelegate Action_1 = delegate { Console.WriteLine("Action_1"); };
    static SampleDelegate Action_2 = delegate { Console.WriteLine("Action_2"); };

    static SampleDelegate Lambda_1 = () => Console.WriteLine("Lambda_1");
    static SampleDelegate Lambda_2 = () => Console.WriteLine("Lambda_2");

    static void Main(string[] args)
    {
        SampleDelegate MultoDel_1 = Function_1;
        MultoDel_1 += Action_1;
        MultoDel_1 += Lambda_1;
        MultoDel_1?.Invoke();
        // Function_1   Action_1    Lambda_1
        var MultoDel_2 = Action_2 + Function_2 + Lambda_2;
        MultoDel_2?.Invoke();
        // Action_2     Function_2  Lambda_2
        MultoDel_1 = MultoDel_1 + MultoDel_2 - Function_1 - Lambda_2;
        MultoDel_1?.Invoke();
        // Action_1     Lambda_1    Action_2    Function_2
    }
}
```

>---
#### 委托的同步调用

对委托的同步调用方式对应于常规的方法调用，通过在委托上调用名为 `Invoke` 的实例方法来执行。进行此调用时，调用方将阻塞，直到被调用的方法返回。被调用的方法应在与调用方相同的线程上执行。

```csharp
// vs csharp interactive
delegate void StartStopEventHandler(int action);

StartStopEventHandler dele = x => Console.WriteLine(x);
dele.Invoke(10010);  
// 10010
```

>---
#### 委托的异步调用 (NET Framework)

在异步模式下，调用被分派，调用方将继续执行而不等待方法返回。被调用的方法将在一个单独的线程上执行。使用 `BeginInvoke` 和 `EndInvoke` 方法异步调用委托。如果调用方线程在被调用方完成之前终止，被调用方线程不受影响。被调用方线程继续执行并静默终止。被调用方可以抛出异常，任何未处理的异常通过 `EndInvoke` 方法传播到调用方。

```csharp
// 预定义
delegate void StartStopEventHandler(int action);
static StartStopEventHandler dele = delegate (int x)
{
    Thread.Sleep(1000);
    Console.WriteLine(x);
};
```

对委托的异步调用应该从对 `BeginInvoke` 方法调用开始。与同步调用不同，异步调用应该为调用方提供一种确定调用何时完成的方式。通过两种方式来等待异步计算结果：
- 第一种是通过调用返回的结果对象，这个对象是接口 `System.IAsyncResult` 的一个实例，通过调用 `EndInvoke` 检查该结果值以获取方法调用的当前状态，并在完成计算时返回结果。

    ```csharp
    var rt = dele.BeginInvoke(10010, null, dele);
    dele.EndInvoke(rt);  // maybe have a return
    ```

- 第二种机制是通过传递给 `BeginInvoke` 的 `System.AsyncCallback` 委托。当计算完成或者已经引发了异常致使结果不可用时，VES 将调用这个委托。传递给这个回调委托的值与调用 `BeginInvoke` 返回的值相同。

    ```csharp
    dele.BeginInvoke(10010, (rt) => dele.EndInvoke(rt), dele);
    ```

---
### Record 

从 C# 9 开始，可以使用 `record` 修饰符定义一个引用类型，用来提供用于封装数据的内置功能。C#10 允许 `record class` 语法作为同义词来阐明引用类型，并允许 `record struct` 使用相同功能定义值类型。

```ANTLR
// 记录
record_class_declaration
    : [ attributes ]? class_modifier* partial? record_type identifier <type_parameter_list>? ( parameter_list? )? 
      record_bases?  type_parameter_constraints* { record_body }
record_type
    : record 'or' record class  
record_bases
    | record <class>? identifier : record_class_base, interface_bases 
    ;

// 记录结构
record_struct_declaration
    : [ attributes ]? struct_modifier* partial? record_type identifier <type_parameter_list>? ( parameter_list? )? 
      record_bases?  type_parameter_constraints* { record_body }
record_type
    : record struct
record_bases
    | record struct identifier : interface_bases
    ;
```

记录不能从类继承，除非是 `object`，而类不能从记录继承。记录可以从其他记录继承。记录的定义声明中可以包含一组参数列表（主构造函数），以构造位置记录。该记录参数不能使用 `ref`、`out`、`this` 修饰，可以使用 `in` 或 `params` 修饰。

```csharp
// 记录
abstract record BaseRecord;  
record Sample<T>(int X, in T Y) : BaseRecord, IDisposable where T : unmanaged
{
    public void Dispose() { }
}

// 记录结构
record struct Sample(params int[] Values) : IEnumerable<int>
{
    public IEnumerator<int> GetEnumerator() => Values.AsEnumerable().GetEnumerator();
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
}
```

>---
#### 位置记录

位置记录：在记录上声明主构造函数时，编译器会为记录类型自动生成一个位置构造函数，同时根据位置参数自动生成一个解构函数 `Deconstruct` 以支持将位置记录解构为元组，并在该位置记录中为主构造函数的参数生成公共属性：
- 对于 `record`，编译器为位置参数生成 `get/init` 公共属性。
- 对于 `record struct`，编译器为位置参数生成 `get/set` 公共属性。
- 对于 `readonly record struct`，编译器为位置参数生成 `get/init` 公共属性。

```csharp
public record Person(string FirstName, string LastName);
// 相当于
public record Person{
    public string FirstName { get; init; }
    public string LastName { get; init; }
    // 结构函数在记录中自动生成，可以声明方法重载或显式声明默认的 Deconstruct
    public void Deconstruct(out string firstName, out string lastName) 
        => (firstName, lastName) = (FirstName, LastName);
}

public record struct Point(int x, int y);
// 相当于
public record struct Point{
    public int x {get; set;}
    public int y {get; set;}
}

public readonly record struct Score(int Math, int English);
// 相当于
public readonly record struct Score{
    public int Math { get; init; }
    public int English { get; init; }
}
```

若要覆盖编译器自动生成的属性，可以在源中自行定义同名的属性，并从记录的位置参数初始化该属性。

```csharp
public record Person(string FirstName, string LastName, string Id)
{
    internal string Id { get; init; } = Id;
}
```

>---
#### 位置记录中的解构函数

为了支持将 `record` 对象能解构成元组，我们给 `record` 添加解构函数 `Deconstruct`。声明主构造函数的记录定义为位置记录，该位置记录会为主构造函数中的位置参数自动生成一个解构函数。

- 显式声明一个解构函数。

```csharp
record Person
{
    public string FirstName { get; init; }
    public string LastName { get; init; }
    public Person(string firstName, string lastName) 
        => (FirstName, LastName) = (firstName, lastName);
    public void Deconstruct(out string firstName, out string lastName) 
        => (firstName, lastName) = (FirstName, LastName);
}
// 相当于
record Person(string FirstName, string LastName);
```

- 解构记录为元组。

```csharp
var (first, last) = new Person("Hello", "World");
record Person(string FirstName, string LastName);
```

> 重定义解构函数或重载解构函数 `Deconstruct`

```csharp
using System.Diagnostics;

var (first, last) = new Person("Hello", "World");
var (firstName, _, Number) = new Person("Hello", "World") { PhoneNumber = "5566-6655" };

record Person(string FirstName, string LastName)
{
    public string PhoneNumber { get; set; } = "";
    // 重定义
    public void Deconstruct(out string firstName, out string lastName)
    {
        Console.WriteLine("Use Deconstruct >> " + new StackFrame(0, true));
        (firstName, lastName) = (FirstName, LastName);
    }
    // 重载
    public void Deconstruct(out string firstName, out string lastName, out string PhoneNumber)
    {
        firstName = FirstName;
        lastName = LastName;
        PhoneNumber = this.PhoneNumber;
    }
}
```

>---
#### 记录相等性

对于 `class` 类型，两个对象引用内存中的同一对象，则这两个对象相等。
对于 `struct` 类型，两个对象是相同的类型并且存储相同的值，则这两个对象相等。
对于 `record` 类型，如果两个对象是相同的类型且存储相同的值，则这两个对象相等。

```csharp
class Sample
{
    public record Person(string FirstName, string LastName, string[] PhoneNumbers);

    static void Main()
    {
        var phoneNumbers = new string[2];
        Person person1 = new("Nancy", "Davolio", phoneNumbers);
        Person person2 = new("Nancy", "Davolio", phoneNumbers);

        Console.WriteLine(person1 == person2); // output: True
        person1.PhoneNumbers[0] = "555-1234";
        Console.WriteLine(person1 == person2); // output: True
        Console.WriteLine(ReferenceEquals(person1, person2)); // output: False
    }
}
```

为实现值相等性，编译器为记录类型合成了几种方法：
  - `Object.Equals(Object)` 的替代，无法显式声明此替代。
  - 运算符 `==` 和 `!=` 的替代，无法显式声明这些运算符。
  - `virtual` 或 `sealed` 的 `Equals(R? other)`，其中 `R` 是记录类型。此方法实现 `IEquatable<T>`，可以显式声明此方法，还应该提供 `GetHashCode` 的实现。
  - `Object.GetHashCode()` 的替代，可以显式声明此方法。
  - 提供返回 `Type` 的 `EqualityContract` 只读属性的实现，可以显式声明此属性。该属性在密封记录中是 `private` 的，在可继承的记录中是 `protected virtual` 的。由于在默认实现的 `GetHashCode` 方法中调用了 `EqualityContract`，因此不建议在此属性中调用 `GetHashCode` 方法。  

```csharp
using System.Diagnostics;

Person p1 = new("Hello", "World");
Person pClone = p1;
pClone.PhoneNumber = "6666-5555";
Console.WriteLine(p1);
Console.WriteLine(Object.ReferenceEquals(p1, pClone));   // true

var p2 = p1 with { PhoneNumber = "5566-6655" };         // with 调用复制构造函数
Console.WriteLine(p2);
Console.WriteLine(Object.ReferenceEquals(p1, p2));      // false

var p3 = p1 with { };               // with 调用复制构造函数
Console.WriteLine(p3 == p1);        // 调用 Person.Equals, true
Console.WriteLine(Object.ReferenceEquals(p1, p3));      // false

record Person(string FirstName, string LastName) : IEquatable<Person>
{
    protected virtual Type EqualityContract
    {
        get
        {
            Console.WriteLine("Use EqualityContract at " + new StackFrame(1).GetMethod().Name);
            return this.GetType();
        }
    }
    public override int GetHashCode()
    {
        Console.WriteLine("Use GetHashCode");
        return unchecked((EqualityComparer<Type>.Default.GetHashCode(EqualityContract) * -1521134295
               + EqualityComparer<string>.Default.GetHashCode(FirstName)) * -1521134295
               + EqualityComparer<string>.Default.GetHashCode(LastName));
    }
    public virtual bool Equals(Person? other)
    {
        Console.WriteLine("Use Equals");
        return (object)other != null
                && EqualityContract == other.EqualityContract
                && EqualityComparer<string>.Default.Equals(FirstName, other.FirstName)
                && EqualityComparer<string>.Default.Equals(LastName, other.LastName);
    }
    protected Person(Person origin)
    {
        Console.WriteLine("Use Clone");
        (FirstName, LastName) = origin;
        PhoneNumber = origin.PhoneNumber;
    }
    public string PhoneNumber { get; set; } = "";
}
/*
Person { FirstName = Hello, LastName = World, PhoneNumber = 6666-5555 }
True
Use Clone
Person { FirstName = Hello, LastName = World, PhoneNumber = 5566-6655 }
False
Use Clone
Use Equals
Use EqualityContract at Equals
Use EqualityContract at Equals
True
False
*/
```

>---

#### 记录复制与克隆

若需要复制包含一些修改的实例，可以使用 `with` 表达式来实现非破坏性变化。`with` 表达式创建一个新的记录实例，该实例是现有记录实例的一个副本，并修改了指定的属性或字段。

```csharp
class Sample
{
    public record Person(string FirstName, string LastName)
    {
        public string[] PhoneNumbers { get; init; }
    }
    public static void Main()
    {
        Person person1 = new("Nancy", "Davolio") { PhoneNumbers = new string[1] };
        Console.WriteLine(person1);
        // output: Person { FirstName = Nancy, LastName = Davolio, PhoneNumbers = System.String[] }

        Person person2 = person1 with { FirstName = "John" };
        Console.WriteLine(person2);
        // output: Person { FirstName = John, LastName = Davolio, PhoneNumbers = System.String[] }
        Console.WriteLine(person1 == person2);
        // output: False

        person2 = person1 with { PhoneNumbers = new string[1] };
        Console.WriteLine(person2);
        // output: Person { FirstName = Nancy, LastName = Davolio, PhoneNumbers = System.String[] }
        Console.WriteLine(person1 == person2); 
        // output: False

        person2 = person1 with { };
        Console.WriteLine(person1 == person2); 
        // output: True
    }
}
```

`with` 表达式可以设置位置属性或使用标准属性语法创建的属性。显式声明属性必须有一个 `init` 或 `set` 访问器才能在 `with` 表达式中进行更改。`with` 表达式的结果是一个浅的副本，这意味着对于引用属性，只复制对实例的引用。原始记录和副本最终都具有对同一对象的引用。

记录类型包含两个复制成员：
- 接受记录类型的单个参数的构造函数 `recordType(recordType origin)`，它被称为 “复制构造函数”。
- 具有编译器保留名称的合成公共无参实例 `Clone` 方法。

复制构造函数的目的是将状态从目标源对象复制到正在创建的新实例，这个构造函数不运行记录声明中存在的任何实例字段或属性的初始值项。若没有显式声明复制构造函数，则编辑器将自动合成。密封记录的复制构造函数为 `private`，可继承的记录则是 `protected`。

虚拟克隆方法返回由复制构造函数初始化的新记录。用户不能替代克隆方法，也不能在任意记录类型中创建名为 `Clone` 的成员。`Clone` 方法是由编译器自动合成的，当使用 `with` 表达式时，编译器将创建调用克隆方法的代码，而 `Clone` 方法将返回调用复制构造函数的结果。

```csharp
Person p1 = new("Hello", "World");
Person pClone = p1;
pClone.PhoneNumber = "6666-5555";
Console.WriteLine(p1);
Console.WriteLine(Object.ReferenceEquals(p1, pClone));   // true

var p2 = p1 with { PhoneNumber = "5566-6655" };
Console.WriteLine(p2);
Console.WriteLine(Object.ReferenceEquals(p1, p2));      // false

var p3 = p1 with { };
Console.WriteLine(Object.ReferenceEquals(p1, p3));      // false, 值相等性

sealed record Person(string FirstName, string LastName)
{
    private Person(Person origin)
    {
        Console.WriteLine("Use Clone");
        (FirstName, LastName) = origin;
        PhoneNumber = origin.PhoneNumber;
    }
    public string PhoneNumber { get; set; } = "";
}
```

>---
#### 记录格式化

记录类型具有编译器生成的 `ToString` 方法，可显式公共属性和字段的名称和值。`ToString` 方法返回一个格式如下的字符串：`<record type name> { <property name> = <value>, <property name> = <value>, ...}`，其中每个 `<value>` 打印的字符串是属性或字段对应类型的 `ToString()`。

为了实现此功能，编译器在 `record class` 类型中合成了一个 `PrintMembers` 方法和一个 `ToString` 替代，此成员在 `record struct` 类型中为 `private`。

```csharp
using System.Runtime.CompilerServices;
using System.Text;

Console.WriteLine(new Point(0,0));  // Point { x = 0, y = 0 }
public record struct Point(int x, int y)
{
    [CompilerGenerated]
    public override readonly string ToString()
    {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.Append("Point");
        stringBuilder.Append(" { ");
        if (PrintMembers(stringBuilder))
        {
            stringBuilder.Append(' ');
        }
        stringBuilder.Append('}');
        return stringBuilder.ToString();
    }

    [CompilerGenerated]
    private readonly bool PrintMembers(StringBuilder builder)
    {
        builder.Append("x = ");
        builder.Append(x.ToString());
        builder.Append(", y = ");
        builder.Append(y.ToString());
        return true;
    }
}
```

> 自定义 ToString

```csharp
using System.Text;

PointArray X = new((0, 0), (1, 1), (2, 2), (3, 3), (4, 4));
Console.WriteLine(X);   // Output: (0,0),(1,1),(2,2),(3,3),(4,4)

public record struct Point(int x, int y)
{
    public static implicit operator Point((int, int) p) => new Point(p.Item1, p.Item2);
    public override string ToString() => $"({this.x},{this.y})";
}
public readonly record struct PointArray(params Point[] points)
{
    public override string ToString()
    {
        StringBuilder sb = new StringBuilder();
        if (points.Length > 0)
        {
            sb = new StringBuilder(points[0].ToString());
            foreach (Point p in points[1..points.Length])
                sb.Append("," + p.ToString());
        }
        return sb.ToString();
    }
}
```

> 自定义 PrintMembers

```csharp
using System.Text;

PointArray X = new((0, 0), (1, 1), (2, 2), (3, 3), (4, 4));
Console.WriteLine(X);   
// Output: PointArray { points = { (0,0), (1,1), (2,2), (3,3), (4,4) } }

public record struct Point(int x, int y)
{
    public static implicit operator Point((int, int) p) => new Point(p.Item1, p.Item2);
    public override string ToString() => $"({this.x},{this.y})";
}
public readonly record struct PointArray(params Point[] points)
{
    public readonly int Length => points.Length;
    private bool PrintMembers(StringBuilder sb)
    {
        if (points.Length == 0)
            return false;
        else
        {
            sb.Append($"points = {{ {points[0].ToString()}");
            foreach (Point p in points[1..points.Length])
                sb.Append(", " + p.ToString());
            sb.Append(" }");
            return true;
        }
    }
}
```

>---
#### 记录继承

一条记录可以从另一条记录继承。派生记录为基记录主构造函数中的所有参数声明位置参数，基记录声明并初始化这些属性；派生记录不会隐藏它们，而只会创建和初始化未在其基记录中声明的参数的属性。

要使两个记录变量相等，运行时类型必须相等。包含变量的类型可能不同，但相等性测试依赖于实际对象的运行时类型，而不是声明的变量类型。

`with` 表达式结果的运行时类型与表达式操作数相同：运行时类型的所有属性都会被复制，但用户只能设置编译时类型的属性。

派生记录类型的合成 `PrintMembers` 方法并调用基实现 `base.PrintMembers()`。结果是派生类型和基类型的所有公共属性和字段都包含在 `ToString` 输出中。派生记录也会重新合成基记录的 `EqualityContract`、`GetHashCode`、`Deconstruct` 方法。 

```csharp
class Sample
{
    public abstract record Person(string FirstName, string LastName);
    public record Teacher(string FirstName, string LastName, int Grade)
        : Person(FirstName, LastName);
    public record Student(string FirstName, string LastName, int Grade)
        : Person(FirstName, LastName);

    public static void Main()
    {
        Person teacher = new Teacher("Nancy", "Davolio", 3);
        Console.WriteLine(teacher);
        // output: Teacher { FirstName = Nancy, LastName = Davolio, Grade = 3 }

        /* 相等性测试 */
        Person student = new Student("Nancy", "Davolio", 3);
        Console.WriteLine(teacher == student);       // output: False
        Student student2 = new Student("Nancy", "Davolio", 3);
        Console.WriteLine(student2 == student);      // output: True

        /* with 表达式 */
        Person clone_teacher = teacher with { FirstName = "Tom" }; // 无法定义 Grade，虽然在运行时类型包含此属性
        Teacher teacher2 = (Teacher)teacher with { Grade = 6 };
        Console.WriteLine(teacher2);
        // output: Teacher { FirstName = Nancy, LastName = Davolio, Grade = 6 }

        /* 解构函数 */
        var (first, second) = (Teacher)teacher;       // 支持基记录的解构函数
        var (first2, second2, grade) = (Teacher)teacher; // 在 Teacher 重新生成的解构函数
    }
}
```

---
### Dynamic

`dynamic` 类型可以引用任何对象，当运算符应用于动态类型的表达式时，操作解析被延迟到程序运行时。非法的操作应用到动态类型时，编译期间不会给出任何错误，当操作在运行时失败，将引发异常。

编译器不会对包含类型 `dynamic` 的表达式的操作进行解析或类型检查，编译器将有关该操作信息打包在一起，之后这些信息会用于在运行时求值操作，因此 `dynamic` 类型只在编译时存在，在运行时则不存在。

在大多数情况下，`dynamic` 类型与 `object` 类型的行为类似。由于 `dynamic` 和 `object` 之间存在隐式转换，两者在函数上被认为是具有相同的签名。若两者都可作为类型推断的目标类型时，类型推断的结果更倾向于 `dynamic` 而不是 `object`。

无法在动态类型上使用索引和范围运算 `dynamicObj[a..b]` 或 `dynamicObj[^a]`。

```csharp
using System;
class Program
{
    static void Main(string[] args)
    {
        ExampleClass ec = new ExampleClass();
        Console.WriteLine(ec.ExampleMethod(10));
        Console.WriteLine(ec.ExampleMethod("value"));
        /* The following line causes a compiler error because ExampleMethod takes only one argument. */
        //Console.WriteLine(ec.ExampleMethod(10, 4));

        dynamic dynamic_ec = new ExampleClass();
        Console.WriteLine(dynamic_ec.ExampleMethod(10));
        /* Because dynamic_ec is dynamic, the following call to ExampleMethod
           with two arguments does not produce an error at compile time.
           However, it does cause a run-time error. */
        //Console.WriteLine(dynamic_ec.ExampleMethod(10, 4));
    }
}
class ExampleClass
{
    static dynamic _field;
    dynamic Prop { get; set; }
    public dynamic ExampleMethod(dynamic d)
    {
        dynamic local = "Local variable";
        int two = 2;
        if (d is int)
            return local;
        else
            return two;
    }
}
// Results:
// Local variable
// 2
// Local variable
```

>---
#### CIL 中的动态类型

在 CIL 中，`dynamic` 类型实际上是一个 `System.Object`，当没有任何调用时，它的声明和 `object` 没有任何区别。为调用成员，编译器要声明 `System.Runtime.CompilerServices.CallSite<T>` 类型的一个变量，`T` 视成员签名而变化。

如 `ToString()` 这样的调用，也需实例化 `CallSite<Func<CallSite,object,string>>` 类型。另外还会动态定义一个方法，该方法可通过参数 `CallSite site`，`object dynamicTarget` 和 `string result` 进行调用。其中，`site` 是调用点本身。 `dynamicTarget` 是要在上面调用方法的 `object`，而 `result` 是 `ToString()` 方法调用的基础类型的返回值。注意不是直接实例化 `CallSite<Func<CallSite _site, object dynamicTarget, string result>>`，而是通过一个 `Create()` 工厂方法来实例化它。这个方法接受一个 `Microsoft.CSharp.RuntimeBinder.CSharpConvertBinder` 类型的参数。在得到 `CallSite<T>` 的一个实例后，最后一步是调用 `CallSite<T>.Target()` 来调用实际的成员。

在执行时，框架会在底层用反射来查找成员并验证签名是否匹配。然后，CLR 生成一个表达式树，它代表由调用点定义的动态表达式。表达式树编译好后，就得到了和本来应由编译器生成的结果相似的 CIL。这些 CIL 代码在调用点缓存下来，并通过一个委托调用来实际地触发调用。由于 CIL 现已缓存于调用点，所以后续调用不会再产生反射和编译的开销。

> C# 调用

```csharp
class Sample
{
    static void Main(string[] args)
    {
        dynamic dy = 0;
        string str = dy.ToString();
    }
}
```

> CIL To C#

```csharp
internal class Sample
{
	[CompilerGenerated]
	private static class <>o__0   // 生成一个动态绑定关联对象
	{
		public static CallSite<Func<CallSite, object, object>> <>p__0;
		public static CallSite<Func<CallSite, object, string>> <>p__1;
	}

	[System.Runtime.CompilerServices.NullableContext(1)]
	private static void Main(string[] args)
	{
		object dy = 0;   // 被视为 `object` 的 `dynamic dy = 0;`
		if (<>o__0.<>p__1 == null)
		{
			<>o__0.<>p__1 = CallSite<Func<CallSite, object, string>>
                .Create(Binder.Convert(CSharpBinderFlags.None, typeof(string), typeof(Sample)));
		}
		Func<CallSite, object, string> target = <>o__0.<>p__1.Target;
		CallSite<Func<CallSite, object, string>> <>p__ = <>o__0.<>p__1;
		if (<>o__0.<>p__0 == null)
		{
			<>o__0.<>p__0 = CallSite<Func<CallSite, object, object>>
            .Create(Binder.InvokeMember(CSharpBinderFlags.None, "ToString", null, typeof(Sample), 
                    new CSharpArgumentInfo[1] { CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, null) }));
		}
		string str = target(<>p__, <>o__0.<>p__0.Target(<>o__0.<>p__0, dy));  // 调用 CallSite<T>.Target
	}
}
```




---
### Nullable Types

#### 可空值类型

可空值类型 `T?` 表示其基础值类型 `T` 的所有值及额外的 `null` 值，其默认值为 `null`。任何可为空的值类型都是泛型 `System.Nullable<T>` 结构的实例。当 `t.HasValue` 为 `false` 时，`v.Value` 为 `null` 值。

访问可空值类型变量的 `Value` 属性的过程称为展开（*unwrapping*）；为给定值类型创建可空值类型的过程称为包装（*wrapping*） 

```csharp
int num = 0;
int? n_num = num;  // wrapping

int? nullNumble = 10010;
// num = (int)nullNumble; // 可能出现 null 引用异常
num = nullNumble ?? default;  // unwrapping
Console.WriteLine(num);  // 10010
```

可为空值类型拥有预定义的一元或二元运算符时，若至少存在一个 `null` 值时，运算结果也为 `null`。对于比较运算符 `<`、`>`、`<=` 和 `>=`，如果一个或全部两个操作数都为 `null`，则结果为 `false`。`null == null` 返回 `true`。

可以将 `is` 运算符与类型模式结合使用，既检查 null 的可空值类型的实例，又检索基础类型的值。或使用 `Nullable<T>.HasValue` 指示可为空值类型的实例是否有基础类型的值，如果 `HasValue` 为 `true`，则 `Nullable<T>.Value` 获取基础类型的值。也可以使用空合并操作符将可空类型转换为其基础类型。

```csharp
void NullCheck<T>(T? n) where T : struct
{
    // 几种空判定s
    if (n != null)
        Console.WriteLine("The input is " + n.Value);
    if (n is int temp)
        Console.WriteLine("The input is " + temp);
    if (n.HasValue)
        Console.WriteLine("The input is " + n.Value);
    Console.WriteLine("The input is " + (n ?? default(T)));
}
```

> *确定可空值类型*

```csharp
Console.WriteLine($"int? is {(IsNullable(typeof(int?)) ? "nullable" : "non nullable")} value type");
Console.WriteLine($"int is {(IsNullable(typeof(int)) ? "nullable" : "non-nullable")} value type");

bool IsNullable(Type type) => Nullable.GetUnderlyingType(type) != null;

// Output:
// int? is nullable value type
// int is non-nullable value type
```

>---
#### 可空引用类型

由于在可为 `null` 的感知上下文选择加入了代码，可以使用可为 `null` 的引用类型、`null` 静态分析警告和空包容运算符（`!`）是可选的语言功能。在可为 `null` 的感知上下文中：
  - 引用类型 `T` 的变量必须用非 `null` 值进行初始化，并且不能为其分配可能为 `null` 的值。
  - 引用类型 `T?` 的变量可以用 `null` 进行初始化，也可以分配 `null`，但在取消引用之前必须对照 `null` 进行检查。
  - 类型为 `T?` 的变量 `m` 在应用空包容运算符时被认为是非空的，如 `m!` 中所示。

类型为 `T` 的变量和类型为 `T?` 的变量由相同的 .NET 类型表示。可为 `null` 的引用类型不是新的类类型，而是对现有引用类型的注释。编译器使用这些注释来帮助你查找代码中潜在的 `null` 引用错误。不可为 `null` 的引用类型和可为 `null` 的引用类型在运行时没有区别。

可以通过两种方式控制可为 null 的上下文。在项目级别，可以添加 `<Nullable>enable</Nullable>` 项目设置。在单个 C# 源文件中，可以添加 `#nullable enable` 来启用可为 null 的上下文。在 .NET 6 之前，新项目使用默认值 `<Nullable>disable</Nullable>`。从 .NET 6 开始，新项目将在项目文件中包含 `<Nullable>enable</Nullable>`。

可空引用类型不能出现在：
- 作为基类或接口。
- 作为对象构造表达式（`new()`）中的类型。
- 作为委托构造表达式（`new delegateType()`）中的 `delegateType` 类型。
- 作为 `is` 表达式、`catch` 子句、类型模式中的类型。


---
### Anonymous Types

匿名类型提供了一种方便的方法，可用来将一组只读属性封装到单个对象中，而无需首先显式定义一个类型，每个属性的类型由编译器推断。类型名由编译器生成，并且不能在源代码级使用，可结合使用 `new` 运算符和对象初始值设定项创建匿名类型。

匿名类型包含一个或多个公共只读属性。无法包含其他种类的类成员（如方法或事件）。用来初始化属性的表达式不能为 null、匿名函数或指针类型。

```csharp
var v = new { Amount = 108, Message = "Hello" };
Console.WriteLine(v.Amount + v.Message);
```

匿名类型是 `class` 类型，它们直接派生自 `object`，并且无法强制转换为除 `object` 外的任何类型。匿名类型的成员是从用于创建该类型实例的匿名对象初始化设定项中推断出的只读属性序列 `new {p1 = e1, p2 = e2, ... , pv = ev }`。

如果程序集中的两个或多个匿名对象初始值指定了属性序列，这些属性采用相同顺序且具有相同的名称和类型，则编译器将对象视为相同类型的实例，它们共享同一编译器生成的类型信息。

无法将字段、属性、时间或方法的返回类型声明为具有匿名类型。同样，也不能将方法、属性、构造函数或索引器的形参声明为具有匿名类型。要将匿名类型或包含匿名类型的集合作为参数传递给某一方法，可将参数作为类型 `object` 进行声明。

```csharp
var p1 = new { Name = "Lawnmower", Price = 495.00 };
var p2 = new { Name = "Shovel", Price = 26.95 };
p1 = p2;
```

> *应用*

- 匿名类型通常用在查询表达式的 `select` 子句中，以便返回源序列中每个对象的属性子集。

```csharp
var productQuery =
    from prod in products
    select new { prod.Color, prod.Price };

foreach (var v in productQuery)
    Console.WriteLine("Color={0}, Price={1}", v.Color, v.Price);
```

- 还可以按另一种类型（类、结构或另一个匿名类型）的对象定义字段。它通过使用保存此对象的变量来完成。

```csharp
var product = new Product();
var bonus = new { note = "You won!" };
var shipment = new { address = "Nowhere St.", product };
var shipmentWithBonus = new { address = "Somewhere St.", product, bonus };
```

- 可通过将隐式键入的本地变量与隐式键入的数组相结合创建匿名键入的元素的数组。

```csharp
var anonArray = new[] { new { name = "apple", diam = 4 }, new { name = "grape", diam = 1 }};
```

- 匿名类型支持采用 `with` 表达式形式的非破坏性修改。

```csharp
var apple = new { Item = "apples", Price = 1.35 };
var onSale = apple with { Price = 0.79 };
Console.WriteLine(apple);
Console.WriteLine(onSale);
```

---
### Generic Types

泛型类型声明本身表示一个未绑定的构造类型，使用类型参数为其构造形成许多不同类型的 “蓝图”。使用泛型构造时，需要为类型参数绑定具体类型名称。

借助泛型，可以根据要处理的精确数据类型设计方法、委托、类、结构或接口，以提高代码的可重用性和类型安全性。泛型是为所存储或使用的一个或多个类型具有占位符（类型形参）的类、结构、接口、方法和委托。例如泛型集合类可以将类型形参用作其存储的对象类型的占位符，泛型方法可将其类型形参用作其返回值的类型或用作其形参之一的类型。

```csharp
abstract class GenericSample
{
    // 泛型方法
    public abstract T GetGenericValue<T>();
    // 泛型类
    class GenericClass<T>;
    // 泛型结构
    struct GenericStruct<T>;
    // 泛型接口
    interface IGenericInterface<T>;
    // 泛型委托
    delegate void GenericDelegate<T>();
    // 泛型记录
    record GenericRecordClass<T>;
    record struct GenericRecordStruct<T>;
}
```

未绑定泛型类型本身不是类型，仅作为创建绑定的构造类型提供模板而存在，因此不能作为变量、参数、返回类型、或其他类的基类型。未绑定的泛型类型只能在 `typeof` 中使用。

```csharp
Sample s = new(); // 非泛型
Sample<int> s2 = new();  // 泛型 

class Sample;
class Sample<T>;
```

在泛型类型中声明的嵌套类型即使不直接指定类型参数，嵌套类型也被认为是泛型构造类型。

```csharp
class Sample<T>
{
    public class Nested;
}
class Sample: Sample<int>.Nested;
```

>---
#### 封闭类型和开放类型

所有类型都可以分为开放式类型或封闭式类型。开放式类型是包含类型参数的类型，具体含义为：
- 类型参数定义开放式类型。
- 当前仅当数组的元素类型是开放式类型时，该数组为开放式类型。
- 当前仅当一个或多个类型参数是开放式类型时，构造类型才是开放式类型。

在运行时，泛型类型声明中的所有代码在通过将类型自变量应用于泛型声明而创建的封闭式构造类型的上下文中执行。泛型类型中的每个类型形参都绑定到特定的运行时类型。所有语句和表达式的运行时处理始终出现在封闭式类型中，并且开放式类型仅在编译时处理期间出现。

每个封闭式构造类型都有自己的静态变量集，它们不与任何其他封闭构造类型共享。由于开放式类型在运行时不存在，因此没有与开放式类型关联的静态变量。如果两个封闭式构造类型是从同一个未绑定的泛型类型构造的，则这两个封闭式构造类型都是相同的类型，并且其对应的类型参数是相同的类型。

作为一种类型，类型参数纯粹是编译时构造。在运行时，每个类型参数都绑定到泛型类型的类型参数来指定的运行时类型。因此，在运行时，用类型参数声明的变量的类型将是封闭构造类型。所有涉及类型参数的语句和表达式的运行时执行都使用作为该参数的类型实参提供的类型。

```csharp
Generic<string> g_string = new Generic<string>();
g_string.Field = "A string";
Console.WriteLine("Generic.Field           = \"{0}\"", g_string.Field);
Console.WriteLine("g_string.GetType() = {0}", g_string.GetType().FullName);
/*
Generic.Field           = "A string"
g_string.GetType() = Generic`1[[System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]
*/

record struct Generic<T>(string Field);   // 泛型记录
```

>---
#### 类型约束

只要引用构造类型或泛型方法，就会根据泛型类型或方法上声明的类型参数约束检查所提供的类型实参。约束告知编译器类型参数必须具备的功能。在没有任何约束的情况下，类型参数可以是任何类型。约束指定类型参数的功能和预期，声明这些约束意味着可以使用约束类型的操作和方法调用。

可以在泛型的定义中使用 `where` 子句指定对类型参数的参数类型约束。对于每个 `where` 子句，根据每个约束检查类型形参对应的类型实参。如果给定的类型参数不满足一个或多个类型参数的约束，则会发生编译时错误。

```csharp
interface ISample<T> where T : class;
// 指定类型参数必须是引用类型
```

可以对类型参数指定的约束有：
  - `struct`、`class`、`unmanaged`、`notnull`、`default` 约束不能组合或重复，且必须先在约束列表中指定。
  - `new()` 不能和 `unmanaged` 和 `struct` 一起使用，且只能是约束列表中的最后一个。

```csharp
interface ISample1<T> where T : struct;     // 不可为 null 的值类型
interface ISample2<T> where T : class;      // 不可为 null 的引用类型
interface ISample3<T> where T : class?;     // 可为 null 的引用类型
interface ISample4<T> where T : notnull;    // 不可为 null 的类型
interface ISample5<T> where T : unmanaged;  // 不可为 null 的非托管类型
interface ISample6<T> where T : new();      // 具有公共无参构造函数的类型
interface ISample7<T> where T : Base;       // 指定的基类或其派生类型
interface ISample8<T> where T : Base?;      // 可为 null 的指定基类或其派生类型
interface ISample9<T> where T : IBase;      // 指定的接口或实现接口的类型
interface ISample10<T> where T : IBase?;    // 可为 null 的指定接口或实现接口的类型
interface ISample11<T, U> where T : U;      // 指定 T 是 U 或 U 的派生类型

class Base;
interface IBase;
```

>---
#### 无约束的类型参数注释 `?` 和 default 约束

在 C# 8 中，`?` 批注只能用于显式约束为值类型或引用类型的类型参数。在 C#9 中，`?` 批注可应用于任何类型参数，而不受约束。除非在类型参数中显式地约束为 `struct`，否则注释只能在 `#nullable enable` 的上下文中使用。

```csharp
static T? FirstOrDefault<T>(this IEnumerable<T> collection) { ... };   // 不受约束的类型参数批注
```

如果类型参数 `T` 替换为引用类型，则 `T?` 表示该引用类型的可空实例。

```csharp
var s1 = new string[0].FirstOrDefault();  // string? s1
var s2 = new string?[0].FirstOrDefault(); // string? s2
```

如果 `T` 用值类型替换，则 `T?` 表示为 `T` 的一个实例。 

```csharp
var i1 = new int[0].FirstOrDefault();   // int i1
var i2 = new int?[0].FirstOrDefault();  // int? i2
```

如果 `T` 使用批注类型替换 `U?`，则 `T?` 表示批注的类型 `U?` 而不是 `U??`。如果 `T` 将替换为类型 `U`，则 `T?` 表示 `U?`，即使在上下文中也是如此 `#nullable disable`。 

```csharp
var u1 = new U[0].FirstOrDefault();  // U? u1
var u2 = new U?[0].FirstOrDefault(); // U? u2, 例如 T 是 int?, 则 'int?'? 仍表示 int? 
#nullable disable
var u3 = new U[0].FirstOrDefault();  // U? u3, 例如 T 是 int, 则 'int'? 表示 int?
```

对于 `T?` 的返回值，相当于 `[MaybeNull] T`。对于参数 `T?`，相当于 `[AllowNull] T`。

```csharp
using System.Diagnostics.CodeAnalysis;
public abstract class A
{
    [return: MaybeNull] public abstract T F1<T>();
    public abstract void F2<T>([AllowNull] T t);
}
public class B : A
{
    public override T? F1<T>() where T : default { return default; }   // matches A.F1<T>()
    public override void F2<T>(T? t) where T : default { }    // matches A.F2<T>()
}
```

> *default 约束*

- 为了与现有代码兼容，重写和显式接口实现的泛型方法不能包含显式约束子句，而 `T?` 在重写或显式接口实现的方法中被视为 `Nullable<T>`，其中 `T` 是值类型。
  
```csharp
class Base
{
    public virtual void Func<T>(T? t) { }
}
interface ISample
{
    void Func<T>(T? t); // T? 被认为是 Nullable<T>
}
class Derived : Base, ISample
{
    // 找不到合适的方法重写
    public override void Func<T>(T? t) { } // CS0453
    void ISample.Func<T>(T? t) { }   // CS0453
}
```  
  
- 为了允许对约束为引用类型的类型参数进行注释 `?`，C#8 允许在泛型方法上显式地约束 `where T: class` 和 `where T: struct`。

```csharp
class Base
{
    public virtual void Func<T>(T? t) where T : struct { }
    public virtual void Func<T>(T? t) where T : class { }
}
interface ISample
{
    void IFunc<T>(T? t) where T : struct; // T? 被认为是 Nullable<T>
}
class Derived : Base, ISample
{
    public override void Func<T>(T? t) /* where T: struct */{ }  // 重写 struct 约束方法
    public override void Func<T>(T? t) where T : class { }
    void ISample.IFunc<T>(T? t) { }
}
```

- 为了允许对不受引用类型或值类型约束的类型参数进行注释，C#9 允许一个新的 `where T: default` 约束。重写或显式接口实现的方法使用 `default` 约束以外的约束是错误的。

```csharp
class Base
{
    public virtual void Func<T>(T? t) where T : struct { }
    public virtual void Func<T>(T? t) { }
}
interface ISample
{
    void IFunc<T>(T? t);
}
class Derived : Base, ISample
{
    public override void Func<T>(T? t) /* where T: struct */{ }
    public override void Func<T>(T? t) where T : default { }
    void ISample.IFunc<T>(T? t) where T : default { }
}
```

- 当重写方法或接口方法中的相应类型参数被约束为引用类型或值类型时，使用 `default` 约束是错误的。

```csharp
class Base
{
    public virtual void Func<T>(T? t) where T : struct { }
    public virtual void Func<T>(T? t) where T : class { }
}
class Derived : Base
{
    public override void Func<T>(T? t) /* where T: struct */{ }
    //public override void Func<T>(T? t) where T : class{ }
    public override void Func<T>(T? t) where T : default { } // CS8822
}
```

>---
#### 约束继承

对于泛型类型的类型参数和它们的约束，都不会被派生类继承，因为类型参数不是成员。派生泛型的类型参数是其泛型基类的类型参数，因此类型参数必须具有等同（或更强）于基类的约束。 

```csharp
class A;
class B : A;

class A<T>;
class B<T> : A<T> where T : A;
class C<T> : B<T> /* where T : B*/;    
// 类型参数的约束不被继承，可以声明约束为同等或更强的限制
```

而基类的虚泛型方法或接口泛型方法被继承并重写或实现时，重写或显式接口实现方法的约束是从基方法继承的，因此不能直接指定这些约束，除非指定 `class` 或 `struct` 约束。

```csharp
class Sample
{
    public virtual void FunA<T>() where T : Sample { }
    public virtual void FunB<T>() where T : struct { }
}
class Derived : Sample
{
    public override void FunA<T>() where T : Sample // err
        => base.FunA<T>();
    public override void FunB<T>() /*where T : struct*/  // okay
        => base.FunB<T>();
}
```

在泛型类继承的情况下，不仅可以保留基类本来的约束（这是必需的），还可添加额外的约束，从而对派生类的类型参数进行更大的限制。但重写虚泛型方法时，需遵守和基类方法完全一样的约束。额外的约束会破坏多态性，所以不允许新增约束。另外，重写方法的类型参数约束是隐式继承的。

>---
#### 泛型类型中的静态成员

使用泛型类型时指定类型参数时，运行时将创建该类型参数的封闭式构造类型。从同一泛型类型的构建的不同构造类型之间，各构造泛型类型的静态成员（包括静态构造函数、字段、方法、属性等）独立存在。在首次调用该类型时，会首先调用它的静态构造函数。对于泛型接口类型的不能构造类型之间，静态成员（非抽象）也是相互独立的。

```csharp
interface ISample<T>
{
    static ISample() => Console.WriteLine($"Static ISample() >> {typeof(T).Name}");
    public static T? Default { get; set; } = default;
}
class Sample<T>
{
    static Sample() => Console.WriteLine($"Static Sample() >> {typeof(T).Name}");
    public static T? Default { get; set; } = default;
}
class Program
{
    static void Main(string[] args)
    {
        var I1 = ISample<int>.Default;
        Console.WriteLine("-------------");
        var I2 = ISample<string>.Default;
        Console.WriteLine("-------------");
        var s1 = Sample<float>.Default;
        Console.WriteLine("-------------");
        var s2 = Sample<object>.Default;
    }
    /*
    Static ISample() >> Int32
    -------------
    Static ISample() >> String
    -------------
    Static Sample() >> Single
    -------------
    Static Sample() >> Object
    */
}
```

>---
#### 协变与逆变

借助泛型类型参数的协变和逆变，可以使用类型自变量的派生程度比目标构造类型更高（协变）或更低（逆变）的构造泛型类型。协变和逆变统称为 “变体”，未标记为协变或逆变的泛型类型参数称为 “固定参数” 。

协变和逆变类型参数仅限于泛型接口和泛型委托类型，变体仅适用于与引用类型。当类型参数指定为值类型时，该类型参数对于生成的构造类型是不可变的。

使用 `in` 关键字指定类型参数是逆变的，逆变的类型参数可以用作泛型接口的方法或泛型委托的参数类型。`out` 关键字指定类型参数是协变的，协变的类型参数可用作接口方法的返回类型。

```csharp
delegate TResult GenericDelegate<in T, out TResult>(T arg);
interface IGeneric<in T, out TResult>
{
    TResult GetResult(T arg);
}
```

协变和逆变能够实现委托类型、泛型接口类型和泛型类型参数的隐式引用转换。

```csharp
class VariantSample
{
    delegate A DCovariant<out A>();             // 协变泛型委托
    delegate void DContravariant<in A>(A a);    // 逆变泛型委托

    interface ICovariant<out A> { }         // 协变泛型接口
    interface IContravariant<in A> { }      // 逆变泛型接口

    class Base;
    class Derived : Base;
    class Sample<T> : ICovariant<T>, IContravariant<T>;
    static T SampleFunc<T>() => default;
    static void SampleFunc<T>(T t) { }

    static void Main(string[] args)
    {
        // 泛型接口中的协变
        ICovariant<Base> I_B = new Sample<Base>();
        ICovariant<Derived> I_D = new Sample<Derived>();
        I_B = I_D;  // 协变

        // 泛型接口中的逆变
        IContravariant<Base> I_B2 = new Sample<Base>();
        IContravariant<Derived> I_D2 = new Sample<Derived>();
        I_D2 = I_B2;  // 逆变

        // 泛型委托中的协变
        DCovariant<Base> D_B = SampleFunc<Base>;
        DCovariant<Derived> D_D = SampleFunc<Derived>;
        D_B = D_D;  // 协变

        // 泛型委托中的逆变
        DContravariant<Base> D_B2 = SampleFunc<Base>;
        DContravariant<Derived> D_D2 = SampleFunc<Derived>;
        D_D2 = D_B2;  // 逆变
    }
}
```

> 扩展变体泛型接口

- 扩展变体泛型接口时，必须使用 `in` 和 `out` 关键字来显式指定派生接口是否支持变体。编译器不会根据正在扩展的接口来推断变体。

```csharp
interface ICovariant<out T> { }
interface IInvariant<T> : ICovariant<T> { }
interface IExtCovariant<out T> : ICovariant<T> { }
```

- 如果泛型类型参数 `T` 在一个接口中声明为协变，则无法在扩展接口中将其声明为逆变。

```csharp
interface ICovariant<out T> { }
interface IContravariant<in T> { }
interface IInvariant<T> : ICovariant<T>, IContravariant<T> { }  // 无法声明逆变或协变
```

> 避免多义性 

- 实现变体泛型接口时，变体有时可能会导致多义性。应避免这样的多义性。如果在一个类中使用不同的泛型类型参数来显式实现同一变体泛型接口，便会产生多义性。在这种情况下，编译器不会产生错误，但未指定将在运行时选择哪个接口实现。这种多义性可能导致代码中出现小 bug。

```csharp
// Simple class hierarchy.
class Animal;
class Cat : Animal;
class Dog : Animal;

// This class introduces ambiguity
// because IEnumerable<out T> is covariant.
class Pets : IEnumerable<Cat>, IEnumerable<Dog>
{
    IEnumerator<Cat> IEnumerable<Cat>.GetEnumerator()
    {
        Console.WriteLine("Cat");
        // Some code.
        return null;
    }
    IEnumerator IEnumerable.GetEnumerator()
    {
        // Some code.
        return null;
    }
    IEnumerator<Dog> IEnumerable<Dog>.GetEnumerator()
    {
        Console.WriteLine("Dog");
        // Some code.
        return null;
    }
}
class Program
{
    public static void Test()
    {
        IEnumerable<Animal> pets = new Pets();
        pets.GetEnumerator();  // Cat ? Dog ? 
    }
}
```

> *数组的协变*

数组的协变使派生程度更大的类型的数组能够隐式转换为派生程度更小的类型的数组。

```csharp
IEnumerable<object> e = new List<string>();
IEnumerable<object> e2 = new List<int>();  // CS0266，值类型不支持协变
IEnumerable<object>[] enumerables = new List<string>[] { }; // 数组的协变
```

>---
#### 泛型的内部机制

泛型类的类型参数成了元数据，CLR 在需要时会利用它们构造恰当的类。所以，泛型支持继承、多态性以及封装。可用泛型定义方法、属性、字段、类、接口和委托。泛型类编译后与普通类无太大差异，编译结果无非就是元数据和参数化的 CIL。

```csharp
// csharp
class Sample<T> where T : ISample
{
    private T[] _items;
    // rest ...
}
// MSIL
.class private auto ansi beforefieldinit 
    Sample`1<(ISample) T>     // 约束，`1 表示类型参数的数目，表示一个占位
	extends [System.Runtime]System.Object
{
    // rest ...
    .field private !T[] _items   // ! 标记占位的位置
    // ...
}
```

用值类型作为类型参数首次构造一个泛型类型时，CLR 会将指定的类型参数放到 CIL 中合适的位置，从而创建一个具体化的泛型类型。CLR 会针对每个新的 “参数值类型” 创建一个新的具体化泛型类型。使用具体化值类型的类，好处在于能获得较好的性能。代码能避免转换和装箱，因为每个具体的泛型类都原生包含值类型。

对于引用类型，泛型的工作方式稍有不同。使用引用类型作为类型参数首次构造一个泛型类型时，CLR 会在 CIL 代码中用 `object` 引用替换类型参数来创建一个具体化的泛型类型（而不是基于所提供的类型实参来创建一个具体化的泛型类型）。之后每次用引用类型参数实例化一个构造好的类型，CLR 都重用之前生成好的泛型类型的版本，即使提供的引用类型与第一次不同。

---
### Pointer

C# 的核心语言与 C/C++ 的显著区别在于它没有将指针作为数据类型。相反，C# 提供了引用和创建由垃圾收集器管理的对象的能力。这种设计加上其他特性，使 C# 成为一种比 C/C++ 更安全的语言。在核心 C# 语言中，不可能有未初始化的变量、“悬空” 指针（被释放或删除的内存区域）或超出数组边界的索引表达式。因此，经常困扰 C/C++ 程序的所有类型的 bug 都被消除了。

尽管实际上 C/C++ 中的每个指针类型结构在 C# 中都有对应的引用类型，但在某些情况下，必须访问指针类型。例如，如果不访问指针，与底层操作系统接口、访问内存映射设备或实现时间关键型算法可能是不可能或不实际的。为了满足这种需求，C# 提供了编写不安全代码的能力。

在不安全代码中，可以声明和操作指针，执行指针和整型之间的转换，获取变量的地址，等等。从某种意义上说，编写不安全代码很像在 C# 程序中编写 C 代码。从开发人员和用户的角度来看，

不安全代码实际上是一个 “安全” 的特性。不安全的代码应该用 `unsafe` 标记清楚，这样开发人员就不可能不小心使用不安全的特性，并且执行引擎的工作是确保不安全的代码不能在不受信任的环境中执行。

>---
#### 不安全上下文

C# 支持不安全上下文，用户可在其中编写不可验证的代码。在不安全的上下文中，代码可使用指针、分配和释放内存块，以及使用函数指针调用方法。可以将方法、类型和代码块定义为不安全。

通过在类型、成员或局部函数的声明中包含不安全修饰符 `unsafe`，或使用 `unsafe { ... }` 语句引入不安全上下文。

`unsafe` 修饰符可以标记类型声明（类、结构、接口、委托）和成员声明（字段、方法、属性、事件、索引器、运算符、实例构造函数、终结器、静态构造函数、局部函数）的整个文本范围为不安全上下文。也可以在函数成员的块中使用 `unsafe { ... }` 语句引入不安全上下文块。

调用需要指针的本机函数时，需使用不安全代码，因此可能会引发安全风险和稳定性风险。在某些情况下，通过移除数组绑定检查，不安全代码可提高应用程序的性能。

```csharp
unsafe {
    int* p;         // p 是指向整数的指针。
    int** p;        // p 是指向整数的指针的指针。
    int*[] p;       // p 是指向整数的指针的一维数组。
    char* p;        // p 是指向字符的指针。
    void* p;        // p 是指向未知类型的指针。

    int* p1, p2, p3;    // Ok
    int *p1, *p2, *p3;  // illegal in C#
}
```

>---
#### 指针声明

在不安全的上下文中，可以声明指针类型或指针类型的数组：

```ANTLR
pointer_type
    : value_type (*)+
    | void (*)*
```

与引用（引用类型的值）不同，指针不受垃圾收集器的跟踪，垃圾收集器不知道指针和它们所指向的数据。因此，不允许指针指向引用或包含引用的结构体。指针类型本身是非托管类型，因此一个指针类型可以指向另一个指针类型。

指针类型是一种单独的类型。与引用类型和值类型不同，指针类型不从对象继承，并且指针类型和对象之间不存在转换。特别是，指针不支持装箱和拆箱。但是，允许在不同指针类型之间以及指针类型与整型之间进行转换。

```csharp
unsafe struct Sample
{
    byte* pb;
    char* pc;
    int** pptr;
    int*[] parr;
    void* p;

    Sample* pS;
}
```

类型为 `T*` 的指针的值表示 `T` 类型变量的地址。地址运算符 `&` 用于获取类型变量的地址，指针间接操作符 `*` 可用于访问该变量。

```csharp
int[] arr = [10, 20, 30, 40, 50];

unsafe
{
    // 必须将对象固定在堆上，这样它在使用时，垃圾回收器不会移动它
    fixed (int* p = arr) // 或 &arr[0]. &arr[index]
    {
        // 固定指针无法移动, 无法赋值
        //  p++;  // CS1656
        // 所以创建另一个指针来显示它的递增。
        int* p2 = p;
        Console.WriteLine(*p2);  // 10
        // 由于指针的类型，增加 p2 会使指针增加其基础类型大小的字节：4
        p2 += 1;
        Console.WriteLine(*p2);  // 20
        p2 += 1;
        Console.WriteLine(*p2);  // 30

        Console.WriteLine("--------");
        // 对 p 解引用并递增会改变 arr[0] 的值
        Console.WriteLine(*p);   // 10
        *p += 1;
        Console.WriteLine(*p);   // 11
        *p += 1;
        Console.WriteLine(*p);   // 12
    }
    Console.WriteLine(arr[0]);  // 12
}
```

`void*` 类型表示指向未知类型的指针。由于指向的类型未知，间接操作符不能应用于 `void*` 类型的指针，也不能在这种指针上执行任何算术运算。但是，`void*` 类型的指针可以被强制转换为任何其他指针类型，并与其他指针类型的值进行比较。

指针类型不能用作类型参数，不能用作动态绑定操作的子表达式的类型，不能则用作扩展方法的第一个形参的类型，不能是匿名类型的元素的值。但是可以用作是 `volatile` 字段的类型，动态类型的指针。

```csharp
unsafe class Sampple
{
    void* unknown;
    volatile dynamic* pd;
}
```

指针类型可以作为 `in`、`ref`、`out` 的参数传递，但是可能会导致未定义行为。指针可能被设置为指向一个局部变量，而该局部变量在被调用的方法返回时不再存在，或者指针指向的固定对象不再固定。

```csharp
class Sample
{
    static int value = 20;
    unsafe static void F(out int* pi1, ref int* pi2)
    {
        int i = 10;
        pi1 = &i;       // return address of local variable
        fixed (int* pj = &value)
            pi2 = pj;   // return address that will soon not be fixed
    }
    static void newFunInStack()
    {
        float i = 3.1415f;
    }
    static void Main()
    {
        int i = 15;
        unsafe
        {
            int* px1;
            int* px2 = &i;
            F(out px1, ref px2);
            newFunInStack();
            int v1 = *px1; // undefined
            Console.WriteLine(v1);  
            int v2 = *px2; // undefined
            Console.WriteLine(v2);
        }
    }
}
```

> *指针操作*

在不安全的上下文中，有几种方式可用于操作所有 **非函数指针的指针类型**：
- 指针间接操作符 `*` 用于访问指针类型指向的值。
- 指针成员访问 `->` 用于通过指针访问结构体的成员。
- `[]` 操作符用于索引指针。
- 地址运算符符 `&` 可用于获取变量的地址。
- `++` 和 `--` 运算符可用于指针的自增和自减操作。
- 二元 `+` 和 `-` 运算符用于执行指针和整数的算数。
- `==`、`!=`、`<=` 和 `>=` 操作符可用于比较指针。
- 可以使用 `stackalloc` 操作符从调用堆栈中分配内存，并赋值给指针类型或 `Span<T>` 和 `ReadOnlySpan<T>`。
- `fixed` 语句可以用来临时固定一个变量，以便获得它的地址。

>---
#### 固定与可移动变量

地址运算符 `&` 和固定 `fixed` 语句将变量分为两类：固定变量和可移动变量：
- 固定变量驻留在不受垃圾收集器操作影响的存储位置（固定变量的例子包括局部变量、值形参和通过解引用指针创建的变量）。
- 可移动变量驻留在由垃圾收集器重新定位或处理的存储位置中（可移动变量的例子包括对象中的字段、数组中的元素、引用传递的参数）。

`&` 运算符允许不受限制地获取固定变量的地址。由于可移动变量会被垃圾回收器重新定位或处理，因此只能通过固定语句获得可移动变量的地址，并且该地址仅在该固定语句的持续时间内有效。

```csharp
class Sample
{
    static unsafe void Fun(int len, int[] arr)
    {
        int * plen = &len; // 固定变量
        fixed (int* p = arr)  // 可移动变量
        {
            int * pArr = p;
            for (int i = 0;i < len; i++)
                Console.WriteLine(pArr[i]); ;
        }
    }
    static void Main(string[] args)
    {
        Fun(10, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
    }
}
```

>---
#### 结构成员访问

对于指向结构体的指针，可以通过 `->` 访问结构体的成员。`p->M` 的等价于 `(*p).M`。 

```csharp
class Test
{
    struct Point
    {
        public int x;
        public int y;
        public override string ToString() => $"({x},{y})";
    }
    static void Main()
    {
        Point point;
        unsafe
        {
            Point* p = &point;
            p->x = 10;
            //  (*p).x = 10;
            p->y = 20;
            //  (*p).y = 20;
            Console.WriteLine(p->ToString());
        }
    }
}
```

>---
#### 数组元素访问

对于指向数组类型的指针，可以像数组元素访问一样，通过索引器语法使用指针访问数组元素。形式为 `P[E]` 的指针元素访问被精确地求值为 `(P + E)`。

指针元素访问操作符不检查越界错误，并且访问越界元素时的行为未定义。

```csharp
class Test
{
    static void Main()
    {
        unsafe
        {
            char* p = stackalloc char[256];
            for (int i = 0; i < 256; i++)
            {
                p[i] = (char)i;
                //  *(p + i) = (char)i;
            }
        }
    }
}
```

>---
#### 指针算数

给定一个指针类型为 `T*` 的表达式 `p` 和一个类型为整数类型的表达式 `N`，表达式 `p + N` 计算类型为 `T*` 的指针值，该指针值是由 `p` 给出的地址加上 `N * sizeof(T)` 得到的。表达式 `p - N` 计算类型为 `T*` 的指针值，该指针值是由 `p` 给出的地址减去 `N * sizeof(T)` 得到的。

给定指针类型为 `T*` 的两个表达式 `P` 和 `Q`，表达式 `P - Q` 计算 `P` 和 `Q` 给出的地址之差，然后将该差除以 `sizeof(T)`。结果的类型总是 `long`。实际上，`P - Q` 计算为 `((long)(P) - (long)(Q)) / sizeof(T)`。

如果指针算术操作溢出指针类型的域，则以实现定义的方式截断结果，但不会产生异常。

```csharp
class Sample
{
    static unsafe void Main()
    {
        int* values = stackalloc int[20];
        int* p = &values[1];
        int* q = &values[15];
        Console.WriteLine($"p - q = {p - q}");  // -14
        Console.WriteLine($"q - p = {q - p}");  // 14
    }
}
```

>---
#### 指针比较

比较运算符比较两个操作数给出的地址，就像它们是无符号整数一样。指向高位地址的指针大于指向低位地址的指针。

```csharp
class Sample
{
    static unsafe void Main()
    {
        int* values = stackalloc int[20];
        int* p = &values[1];
        int* q = &values[15];
        Console.WriteLine(p > q); // false
    }
}
```

>---
#### fixed 语句

在不安全的上下文中，固定语句允许使用一个额外的构造，即 `fixed` 语句，它用于 “固定” 一个可移动的变量，使其地址在语句期间保持不变。

每个固定指针声明给定指针类型的一个局部变量，并用相应计算的地址初始化该局部变量。由固定语句声明的局部变量被认为是只读的。如果内嵌语句试图修改该局部变量（通过赋值或 `++` 和 `--` 运算符）或将其作为引用（`ref`、`ref readonly`、`in`、`out`）参数传递，则会发生编译时错误。

`fixed` 语句可防止垃圾回收器重新定位可移动变量，并声明指向该变量的指针。固定变量的地址在语句的持续时间内不会更改。只能在相应的 `fixed` 语句中使用声明的指针，且声明的指针是只读的，无法修改。

`fixed` 而可初始化声明使用数组的指针、使用变量的地址、使用实现名为 `ref [readonly] T GetPinnableReference()` 的可访问方法或可扩展方法表达式结果，例如 .NET 类型 `System.Span<T>` 和 `System.ReadOnlySpan<T>`）、使用字符串、使用固定大小的缓冲区（堆栈上声明的 `stackalloc` 内存不需要固定）。

> 使用数组

```csharp
unsafe
{
    int[] arr = [10, 20, 30, 40, 50];
    fixed (int* p = arr)
    {
        int index = 0;
        foreach (int i in arr)
        {
            p[index] = i * i; 
            index++;
        }
        Console.WriteLine(string.Join(", ", arr));
        // Output: 100, 400, 900, 1600, 2500
    }
}
```

> 使用变量的地址

```csharp
unsafe
{
    int[] numbers = { 10, 20, 30 };
    fixed (int* toFirst = &numbers[0], toLast = &numbers[^1])
        Console.WriteLine(toLast - toFirst);  // output: 2
}
```

> 使用实现名为 `GetPinnableReference` 的方法的类型实例

```csharp
NumberArray arr = new(1, 2, 3, 4, 5, 6);
unsafe
{
    fixed(int* p = arr)
        for(int i = 0;i< 6; i++)
            Console.WriteLine(p[i]);
}
record NumberArray(params int[] arr)
{
    public ref int GetPinnableReference() => ref arr[0];
}
```

> 使用字符串

```csharp
ToUpper("Hello, World"); // Output: HELLO, WORLD

unsafe static void ToUpper(string str)
{
    fixed(char* f = str)
    {
        int index = 0;
        foreach (char c in str)
            f[index] = char.ToUpper(f[index++]);
    }
    Console.WriteLine(str);
}
```

--- 
### Function Pointer

C# 提供 `delegate` 委托类型来定义安全函数指针对象。调用委托时，需要实例化从 `System.Delegate` 派生的类型并对其 `Invoke` 方法进行虚拟方法调用，该虚拟调用使用 IL 指令 `callvirt`

可以使用 `delegate*` 语法声明函数指针。编译器将使用 IL 指令 `calli` 指令来调用函数，而不是实例化为委托对象并调用 `Invoke`。在性能关键的代码路径中，使用 IL 指令 `calli` 效率更高。

```csharp
// 委托定义参数
public static T Combine<T>(Func<T, T, T> combinator, T left, T right) => combinator(left, right);
// 函数指针定义参数
public static T UnsafeCombine<T>(delegate*<T, T, T> combinator, T left, T right) => combinator(left, right);
```

函数指针只能在 `unsafe` 上下文中声明，只能在静态成员方法或静态本地方法使用地址运算符 `&`。

```csharp
unsafe
{
    // 函数指针声明和调用
    delegate*<int, int> pAbs = &Abs;
    Console.WriteLine(pAbs(-999));  // 999
    // 本地静态方法
    static int Abs(int val) => Math.Abs(val);
}
```

>---
#### 函数指针语法

```ANTLR
delegate* calling_convention_specifier? <parameter_list, return_type> 

calling_convention_specifier? : 可选的调用约定说明符, 默认为 managed
    managed : 默认调用约定
    unmanaged : 非托管调用约定, 未显式指定调用约定类别, 则使用运行时平台默认语法
    unmanaged [ Calling_convertion <,Calling_convertion ...>? ] : 指定特定的非托管调用约定, 一到若干个进行组合

Calling_convertion : 调用约定
    Cdecl : 调用方清理堆栈
    stdcall : 被调用方清理堆栈, 这是从托管代码调用非托管函数的默认约定
    Thiscall : 指定方法调用的第一个参数是 this 指针, 该指针存储在寄存器 ECX 中
    Fastcall : 调用约定指定在寄存器中传递函数的参数 (如果可能), NET 可能不支持 
    MemberFunction : 指示调用函数变体
    SuppressGCTransition : 指示抑制 GC 转换作为调用约定的一部分
```

ECMA-335 将 `Calling_convertion` *调用约定* 定义为函数指针类型签名的一部分。默认的调用约定是 `managed`，非托管调用约定可以通过在 `delegate*` 语法后放置一个 `unmanaged` 关键字来指定，该关键字将使用运行时平台默认的调用约定类别。

```csharp
unsafe
{
    // 此方法具有托管调用约定。managed 可省略
    delegate* managed<int, int> pManagedFun;

    // 此方法将使用运行时平台上的默认非托管调用约定。这取决于平台和体系结构，并由 CLR 在运行时确定。
    delegate* unmanaged<int, int> pUnmanagedFun;
}
```

如果没有提供 `calling_convention_specifier`，则使用默认值 `managed`。

```csharp
delegate int Func1(string s);
delegate Func1 Func2(Func1 f);

// Function pointer equivalent without calling convention
delegate*<string, int>;
delegate*<delegate*<string, int>, delegate*<string, int>>;

// Function pointer equivalent with calling convention
delegate* managed<string, int>;
delegate*<delegate* managed<string, int>, delegate*<string, int>>;
```

可以为 `unmanaged` 非托管调用指定特定的约定类别：通过在 `System.Runtime.CompilerServices` 命名空间中以 `CallConv` 开头的任何类型并去掉去掉 `CallConv` 前缀后的名称，做为 `unmanaged [Calling_convertion <,Calling_convertion>]` 声明的 `Calling_convertion`。

```csharp
using System.Runtime.CompilerServices;

// 非托管调用约定类别
CallConvCdecl Cdecl;
CallConvFastcall Fastcall;
CallConvStdcall Stdcall;
CallConvThiscall Thiscall;
CallConvMemberFunction MemberFunction;
CallConvSuppressGCTransition SuppressGCTransition;

unsafe
{
    // 此方法将使用 Cdecl 调用约定,
    // Cdecl 映射到 System.Runtime.CompilerServices.CallConvCdecl
    delegate* unmanaged[Cdecl]<int, int> pFunCdecl;

    // 此方法将使用 Stdcall 调用约定，并抑制 GC 转换,
    // Stdcall 映射到 System.Runtime.CompilerServices.CallConvStdcall
    // SuppressGCTransition 映射到 System.Runtime.Compilerservices.Callconvsuppressgctransition
    delegate* unmanaged[Stdcall, SuppressGCTransition]<int, int> pFunStdcall;
}
```

函数指针类型之间的转换是基于它们的签名（包括调用约定）完成的。

```csharp
unsafe class Example
{
    void Conversions()
    {
        delegate*<int, int, int> p1 = ...;
        delegate* managed<int, int, int> p2 = ...;
        delegate* unmanaged<int, int, int> p3 = ...;

        p1 = p2; // okay : p1, p2 具有相同的签名 
        Console.WriteLine(p2 == p1); // True
        p2 = p3; // error : 调用约定不兼容
    }
}
```

`delegate*` 类型是指针类型，这意味着它具有标准类型的所有功能和限制：
- 功能：
  - 指针仅在不安全的上下文中有效。
  - 包含 `delegate*` 参数或返回类型的方法只能从不安全的上下文中调用。
  - 不能转换为 `object`。
  - 不能用作泛型类型参数。
  - 可以隐式转换 `delegate*` 到 `void*`。
  - 可以显式转换 `void*` 到 `delegate*`。
- 限制：
  - 自定义特性不能应用于 `delegate*` 或它的其任何元素。
  - 不能将 `delegate*` 参数标记为 `params`。
  - `delegate*` 类型具有普通指针类型的所有限制。
  - 指针运算不能直接在函数指针类型上执行。
  - 仅 `==`、`!=`、`<`、`>`、`<=`、`>=` 运算符可用于比较函数指针。

>---
#### 函数指针的目标方法

允许将方法组作为 `&` 地址运算符的操作数，表达式返回类型是一个函数指针类型 `delegate*`，它具有与目标方法相同的签名和托管调用约定。

在不安全的上下文中，如果满足以下所有条件，则方法 `M` 与函数指针类型 `F` 兼容：
- `M` 和 `F` 具有相同数量的参数，并且 `M` 中的每个参数与 `F` 中对应的参数具有相同的 `ref`、`out` 或 `in` 修饰符。
- 对于每个值形参，存在从 `M` 中的形参类型到 `F` 中相应形参类型的恒等转换、隐式引用转换或隐式指针转换。
- 对于每一个 `ref`、`out` 或 `in` 形参，`M` 中的形参类型与 `F` 中对应的形参类型相同。
- 如果返回类型是按值返回（无 `ref` 或 `ref readonly`），则存在从 `F` 的返回类型到 `M` 的返回类型的恒等、隐式引用或隐式指针转换。
- 如果返回类型是引用（`ref` 或 `ref readonly`），则 `F` 的返回类型和修饰符与 `M` 的返回类型和修饰符相同。
- `M` 的调用约定与 `F` 的调用约定相同。这既包括调用约定位（`unmanaged` 或 `managed`），也包括在非托管标识符中指定的任何调用约定类别。
- `M` 是静态方法。

```csharp
unsafe class Util
{
    public static void Log() => Console.WriteLine("Log");
    public static void Log(string mess) => Console.WriteLine(mess);
    public static void Log(int i) => Console.WriteLine(i);

    static void Main()
    {
        delegate*<void> a1 = &Log; // Log()
        delegate*<int, void> a2 = &Log; // Log(int i)

        // Error: 从方法组 Log 到 void* 的模糊转换
        void* v = &Log;
    }
}
```

>---
#### 调用约定的元数据表示

调用约定通过签名中的 `CallKind` 标志和签名开头的零个或多个 `modopts` 的组合在元数据中的方法签名中进行编码。ECMA-335 目前在 `CallKind` 标志中声明了以下元素。其中，C# 中的函数指针将支持除 `varargs` 以外的所有变量：

```ANTLR
CallKind
   : default
   | unmanaged cdecl
   | unmanaged fastcall
   | unmanaged thiscall
   | unmanaged stdcall
   | varargs
   ;
```

> 从 `calling_conventions_specifier` 映射到 `CallKind`

省略的 `calling_convention_specifier` 或指定为 `managed` 的 `calling_convention_specifier` 映射到默认的 `CallKind`。这是任何未归属于 `UnmanagedCallersOnlyAttribute` 的方法的默认 `CallKind`。

```csharp
unsafe class Sample
{
    public static delegate* managed<string, void> pWriteLine = &WriteLine;

    static void WriteLine(string mess) => Console.WriteLine(mess);
}
```

标记有 `UnmanagedCallersOnlyAttribute` 的任何方法均可从 `Native` 代码中直接调用。可以使用 C# 的 address-of 运算符 `&` 将函数加载到局部变量，并作为回调传递给 `Native` 方法。

```csharp
unsafe class Sample
{
    public static delegate* unmanaged[Cdecl]<int, int> pFun1;

    // Target will be invoked using the cdecl calling convention
    [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvCdecl) })]
    public static int Fun(int val) => val;

    [DllImport("NativeLibrary", EntryPoint = "NativePointer")]
    internal static extern void NativeMethod(delegate* unmanaged[Cdecl]<int, int> pFun);

    static void Main()
    {
        pFun1 = &Fun;
        // Calling in C#
        Console.WriteLine(pFun1(1000));  
        // or Callback of Native Method 
        NativeMethod(pFun1);
    }
}
```

C# 识别 4 种特殊标识符，并映射到 ECMA-335 中特定的现有非托管 `CallKind`。为了实现这种映射，必须单独指定这些标识符，不能指定其他标识符，并且将此标识编码到 `unmanaged` 的 `Calling_convertion` 规范中。这些标识符是 `Cdecl`、`Thiscall`、`Stdcall` 和`Fastcall`，它们分别对应于 `unmanaged Cdecl`、`unmanaged Thiscall`、`unmanaged Stdcall` 和 `unmanaged Fastcall`。

如果指定了多个标识符，或者单个标识符不是特殊标识符（例如 `MemberFunction`、`SuppressGCTransition`），则在标识符上加上 `CallConv` 前缀，并在 `System.Runtime.CompilerServices` 查找相应的类型定义（例如 `CallConvMemberFunction`）。这些类型必须来自程序的核心库，有效组合的集合依赖于平台。

>---
#### UnmanagedCallersOnlyAttribute

`UnmanagedCallersOnlyAttribute` 是 CLR 使用的一个特性，用来指示一个方法应该用特定的调用约定来调用。编译器对该特性有以下支持和限制：
- 在 C# 中直接调用带有此特性标记的方法是错误的。用户必须获得一个指向该方法的函数指针，然后调用该指针。
- 将特性应用于普通静态方法或普通静态局部函数以外的任何程序元素都是错误的。C# 编译器会将从带有此特性的元数据中导入的任何非静态或静态非普通方法标记为语言不支持。
- 如果特性标记的方法具有非 `unmanaged` 类型的参数或返回类型，则会产生错误。
- 用特性标记泛型类型的方法是错误的。
- 将标记有该特性的方法转换为委托类型是错误的。
- 不满足在元数据中调用约定模块要求的 `UnmanagedCallersOnly.CallConvs` 的类型都是错误的。

当确定用有效的 `UnmanagedCallersOnly` 特性标记的方法的调用约定时，编译器对 `CallConvs` 属性中指定的类型执行以下检查，以确定应该用于确定调用约定的有效 `CallKind` 和 `modopt`：

- 如果没有指定类型，`CallKind` 将被视为非托管默认调用约定。在函数指针类型的开始处没有调用约定 `modopt`。

  ```csharp
  unsafe class Sample
  {
      public static delegate* unmanaged <int, int> pFun;>
  
      [UnmanagedCallersOnly()]
      public static int Fun(int val) => val;
      static void Main()
      {
          pFun = &Fun;
          Console.WriteLine(pFun(10010)); 
      }
  }
  ```

+ 如果指定了一种类型，并且该类型为 `CallConvCdecl`、`CallConvThiscall`、`CallConvStdcall` 或 `CallConvFastcall` 中的一个，那么 `CallKind` 将分别被视为 `unmanaged Cdecl`、`unmanaged Thiscall`、`unmanaged Stdcall` 和 `unmanaged Fastcall`。在函数指针类型的开始处没有调用约定 `modopt`。
  - `CallConvCdecl` 指示调用者清理堆栈。这允许调用带有 `varargs` 的函数。
  - `CallConvThiscall` 指示使用 `ThisCall` 调用约定时，方法调用的第一个参数是 `this` 指针，该指针存储在寄存器 `ECX` 中。方法调用的其他参数将推送到堆栈上。此调用约定用于对从非托管 DLL 导出的类调用方法。
  - `CallConvStdcall` 指示被调用者清除堆栈。这是从托管代码调用非托管函数的默认约定。
  - `CallConvFastcall` 指示使用 `Fastcall` 调用约定时，指定函数的参数在可能的情况下通过寄存器传递。`CallConvFastcall` 调用在当前 `.NET` 不受支持。

  ```csharp
  unsafe class Sample
  {
      public static delegate* unmanaged[Cdecl]<int, int> pFun;
  
      [UnmanagedCallersOnly(CallConvs = new[] {typeof(CallConvCdecl) })]
      public static int Fun(int val) => val;
      static void Main()
      {
          pFun = &Fun;
          Console.WriteLine(pFun(10010));
      }
  }
  ```

- 如果指定了多个类型，或者单个类型没有被命名为上面特别调用的类型之一（例如 `MemberFunction`、`SuppressGCTransition`），那么 `CallKind` 将被视为非托管默认调用约定，指定的类型的联合将被视为函数指针类型开头的 `modopt`。
  - `SuppressGCTransition` 指示方法应禁止 GC 转换作为调用约定的一部分。该方法只能在非托管代码中使用。 
  - `MemberFunction` 指示所使用的调用约定是成员函数变体。

  ```csharp
  unsafe class Sample
  {
      public static delegate* unmanaged[Cdecl, MemberFunction]<int, int> pFun;
  
      [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvCdecl), typeof(CallConvMemberFunction) })]
      public static int Fun(int val) => val;
      static void Main()
      {
          pFun = &Fun;
          Console.WriteLine(pFun(10010));
      }
  }
  ```

+ 最终，编译器查看这个有效的 `CallKind` 和 `modopt` 集合，并使用正常的元数据规则来确定函数指针类型的最终调用约定。

>---
#### UnmanagedCallConvAttribute 

`UnmanagedCallConvAttribute` 指定 ·NET 调用非托管代码中实现的 P/Invoke 方法（本机函数）所需的调用约定。这些方法的调用约定为 `managed`。

当此特性应用于带有 `DllImportAttribute` 的方法，其中 `CallingConvention` 设置为 `Winapi` 时，.NET 运行时将使用 `UnmanagedCallConvAttribute.CallConvs` 来确定 P/Invoke 的调用约定。如果应用于没有 `DllImportAttribute` 或 `CallingConvention` 设置为 `Winapi` 以外的其他内容的方法，则忽略此特性。

```csharp
unsafe class Sample
{
    public static delegate*<int, int> pFun;
    public static delegate*<int, int> pFun2;

    // Target will be invoked using the stdcall calling convention
    [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall) })]
    [DllImport("NativeLibrary", EntryPoint = "native_function_stdcall")]
    // 上述特性组合等效于 [DllImport("NativeLibrary", EntryPoint = "native_function_stdcall", CallingConvention = CallingConvention.StdCall)]
    internal static extern int NativeFunction(int arg);

    // Target will be invoked using the stdcall calling convention and with the GC transition suppressed
    [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvStdcall), typeof(CallConvSuppressGCTransition) })]
    [DllImport("NativeLibrary", EntryPoint = "native_function_stdcall", CallingConvention = CallingConvention.Winapi)]
    internal static extern int NativeFunction_NoGCTransition(int arg);

    static void Main()
    {
        pFun = &NativeFunction;
        pFun2 = &NativeFunction_NoGCTransition;

        pFun(10010);
        pFun2(10086);
    }
}
```

---
###  Anonymous Functions

匿名函数是一个表示 “内联” 方法定义的表达式。匿名函数本身没有值或类型，但可以转换为兼容的委托或表达式树类型。匿名函数转换的求值取决于转换的目标类型：
- 如果是委托类型，则转换的求值为引用匿名函数定义的方法的委托值。
- 如果是表达式树类型，则转换的计算结果为表达式树，该表达式树将方法的结构表示为对象结构。

有两种形式的匿名方法表示方法，一种使用 `delegate` 声明匿名方法表达式（块主体），另一种使用简洁的 Lambda 表达式或语句（块或表达式主体）。

>---
#### delegate 匿名方法表达式

使用 `delegate` 声明匿名函数表达式，函数体仅支持语句块主体。

```ANTLR
anonymous_method_expression
    : delegate ()? { <sequence-of-statements> }
    | delegate ( parameters? ) { <sequence-of-statements> }
```

匿名函数表达式的参数列表是可选的，如果给出了参数，则必须显式声明参数类型。匿名函数不能是动态绑定操作的接收方、参数或是操作数。

```csharp
var fun = delegate (int x) { return x + 1; };      // Anonymous method expression
Func<int, int> fun1 = delegate { return 1 + 1; };  // Parameter list omitted
Func<int, int> fun2 = static delegate { return 1 + 1; };        // static
var fun3 = async delegate (int sec){ await Task.Delay(sec); };  // async
```

>---
#### Lambda 表达式

使用 Lambda 表达式来创建匿名函数：

```ANTLR
lambda_expression
    : async? <return_type>? ( input_parameters? ) => expression ;

lambda_statement
    : async? <return_type>? ( input_parameters? ) => { <sequence-of-statements> } ;
```

Lambda 表达式的参数可以声明隐式参数，若无法推断参数的类型时，则需要显式指定类型。隐式变量只有一个时，括号可以省略。

```csharp
Func<int,int> Square = x => x * x;
var Sum = (int x, int y) => x + y;
var Iterator = (params IEnumerable[] arr) =>
{
    foreach (var item in arr)
        Console.WriteLine(item);
};
```

通过使用 `async` 和 `await` 关键字，可以创建包含异步处理的 Lambda 表达式和语句。

```csharp
var asyncAction = async (Action ac) => await Task.Run(ac);
await asyncAction(() => Console.WriteLine("Hello, World"));
```

从 C#9 开始，可以使用弃元指定 Lambda 表达式中不使用的两个或更多输入参数。如果只有一个输入参数命名为 `_`，则在 Lambda 表达式中，`_` 将被视为该参数的名称。

```csharp
Func<int, int, int> Constant = (_, _) => 99;
```

从 C# 9.0 开始，可以将 `static` 修饰符应用于 Lambda 表达式，以防止由 Lambda 无意中捕获本地变量或实例状态，但可以引用静态成员和常量定义。

```csharp
Func<double, double> square = static x => x * x;
```

从 C#10 开始，可以在输入参数前面指定 Lambda 表达式的返回类型。

```csharp
var Choose = object (bool b) =>  b? 1:"two";
```

从 C#10 开始，可以将特性添加到 Lambda 表达式及其参数。

```csharp
var concat = ([DisallowNull] string a, [DisallowNull] string b) => a + b;
```

从 C#12 开始，可以为 Lambda 表达式上的参数提供默认值。

```csharp
var fun = (string? mess = "") => Console.WriteLine(mess);
```

>---
#### 匿名函数签名

匿名函数的签名定义了匿名函数的形参的名称和可选的类型。如果匿名函数有一个显式类型声明的方法签名，那么兼容的委托类型和表达式树类型也必须具有相同参数类型、参数修饰符和相同的参数顺序的方法签名。与方法组转换委托不同，不支持匿名函数参数类型的协变转换。

若匿名函数没有签名，那么兼容的委托类型和表达式树类型的参数列表中为没有任何 `out` 参数修饰的形参。

```csharp
class Sample
{
    delegate void Fun1(int a);
    delegate void Fun2(float b);
    delegate void Fun3(out int b);
    delegate void Fun4(ref int b, int c, string s);

    static void Main()
    {
        Fun1 f1A = delegate { };
        Fun2 f1B = delegate { };
        Fun3 f1C = delegate { };  // out paramster
        Fun4 f1D = delegate { };

        Fun1 f2A = x => x *= x;    // 自动推断
        Fun2 f2B = x => x *= x;   // 自动推断
        Fun3 f2C = (out int x) => x = 0;  // 需要显式声明类型
        Fun4 f2D = delegate (ref int a, int b, string s) { };
    }
}
```

>---
#### 匿名函数主体

匿名函数主体只能使用自身签名中声明的 `ref`、`in`、`out` 参数，无法使用外部范围的其他应用变量。

```csharp
class Sample
{
    static void Test(ref int val, string s)
    {
        var f = delegate (out int s_val)
        {
            Console.WriteLine(s);
            s_val = val; // err
            return ref s_val;
        };
    }
}
```

匿名函数主体只能使用自身签名中声明的 `ref struct` 类型的参数，不能使用外部范围的 `ref struct` 变量。

```csharp
class Sample
{
    static void Test(Span<int> val, string s)
    {
        var f = delegate(Span<int> s_buff)
        {
            Console.WriteLine(s);
            var buff = val;  // err

            for (int i = 0; i < s_buff.Length; i++)
                s_buff[i] = i;
        };
    }
}
```

如果 `this` 是结构类型，则匿名函数的函数主体无法使用 `this`，可以在外部范围声明一个 `this` 赋值的局部变量。

```csharp
struct Sample
{
    int Value;
    void Test()
    {
        var @this = this;

        Action f = delegate
        {
            int val = this.Value;  // err
            int s_val = @this.Value;
        };
    }
}
```

函数体可以访问匿名函数范围外的外部变量。对外部变量的访问将在调用引用匿名函数的委托时处于活动状态。

```csharp
Action ac = null;
Sample S= new Sample();
S.Fun(ref ac);
if(ac is not null)
{
    for (int i = 0; i < 10; i++)
        ac.Invoke();
}
class Sample
{
    int Counter;
    public void Fun(ref Action ac)
    {
        ac = delegate
        {
            Counter++;
            Console.WriteLine($"Counter : {Counter}");
        };
    }
}
```

>---
#### 外部变量

任何局部变量、值参数、参数数组等的作用域可以覆盖到匿名方法的函数体时，这些变量都被称为匿名函数的外部变量。在类的实例函数成员中，`this` 值被认为是值参数。

当一个外部变量被匿名函数引用时，外部变量就被匿名函数捕获了。通常局部变量的生命周期仅限于与它关联的块或语句的执行，但是作为匿名函数内被捕获的外部变量，局部变量的生命周期至少会延长，直到从匿名函数创建的委托或表达式树符合垃圾回收的条件。

```csharp
class Test
{
    delegate int D();
    static D F()
    {
        int x = 0;
        D result = () => ++x;
        return result;
    }
    static void Main()
    {
        D d = F();
        Console.WriteLine(d());   // 1
        Console.WriteLine(d());   // 2
        Console.WriteLine(d());   // 3
    }
}
```

当局部变量或值参数被匿名函数捕获时，局部变量或形参不再被认为是固定变量，而是可移动变量。但是由于不能获取捕获外部变量的地址，所以这些外部变量不能在 `fixed` 语句中使用。

在将匿名函数转换为表达式树时，对编译器生成的对象引用可以存储在表达式树中，对局部变量的访问可以表示为对这些对象的字段访问。这种方法的优点是，它允许在委托和表达式树之间共享 “提升” 的局部变量。


---
### 变量

C# 定义了 8 种变量：静态变量、实例变量、数组元素、值参数、输入参数、引用参数、输出参数和局部变量。

```csharp
class Sample
{
    static int x;  // 静态变量 
    private int y; // 实例变量
    void Fun(
        int[] v,   // v[0] 数组元素
        int a,     // 值参数
        in int b,  // 输入参数
        ref int c, // 引用参数
        out int d) // 输出参数
    {
        int i = 10;  // 局部变量
        d = a + c++ + b;
    }
}
```

>---
#### 静态变量 

静态变量使用 `static` 声明，静态变量在其包含类型的静态构造函数执行之前存在，并且在关联的零一程序域不存在时停止存在。静态变量的初始值是变量类型的默认值。

由于明确赋值的目的，静态变量被视为初始赋值。

>---
#### 实例字段

未声明静态 `static` 修饰符的字段是实例字段。

类的实例字段在类的新实例创建时存在，当没有对该实例的引用且实例的终结器已经执行时，实例变量停止存在。类的实例变量的初始值是变量类型的默认值。由于明确赋值的目的，也被认为是初始赋值。

结构体的实例变量与它所属的结构体变量具有完全相同的生存期，其实例变量的初始赋值状态与包含结构体变量的初始赋值状态相同。当结构体变量被认为是初始赋值时，它的实例变量也是；若是初始未赋值的，它的实例变量也是为赋值的。

>---
#### 数组元素

数组的元素在创建数组实例时开始存在，在没有对数组实例的引用时停止存在。数组中每个元素的初始值是数组元素类型的默认值。
由于明确赋值的目的，数组元素被认为是初始赋值。

>---
#### 值参数

没有 `ref`、`in`、`out` 修饰的形参是值参数。值参数在调用函数成员或匿名函数时产生，并使用调用
中给出的实参的值进行初始化。当函数体执行完成时，值参数通常不再存在。若值参数被一个匿名函数捕获，它的生命周期至少会延长到从该匿名函数创建的委托或表达式树符合垃圾回收的条件。

由于明确赋值的目的，一个值参数被视为初始赋值。

>---
#### 引用参数

用 `ref` 修饰声明的形参是引用参数。引用参数是在调用函数成员、委托、匿名方法或局部函数时产生的引用变量。引用参数不会创建新的存储位置，它与给定调用中的参数变量表示相同的存储位置。当函数体执行完成时，引用参数也不存在，且引用参数不会被捕获。

变量在作为函数成员或委托调用的引用参数传递之前必须明确赋值。由于明确赋值的目的，引用参数被视为初始赋值。

对于结构类型的实例方法或实例访问器中，`this` 的行为与引用参数完全相同。

>---
#### 输出参数

用 `out` 修饰声明的形参是输出参数。输出参数是在调用函数成员、委托、匿名方法或局部函数时产生的引用变量。当函数体执行完成时，输出参数不再存在，且输出参数不会被捕获。

输出参数的赋值规则：
- 在函数成员或委托调用中将变量作为输出参数传递之前，不需要明确赋值。
- 在函数成员或委托调用正常完成之后，作为输出参数传递的每个变量都被认为是在该执行路径中分配的。
- 在函数成员或匿名函数中，输出参数最初被认为是未分配的。
- 函数成员、匿名函数或局部函数的每个输出参数必须在函数正常返回之前明确赋值。

>---
#### 输入参数

用 `in` 修饰声明的参数是输入参数。输入参数是在调用函数成员、委托、匿名函数或局部函数时产生的引用变量，其引用被初始化该调用中作为实参给出的变量引用。当函数体执行完成时，输入参数不再存在，且输入参数不会被捕获。

变量在作为函数成员或委托调用的输入参数传递之前必须明确赋值。出于明确赋值的目的，输入参数被视为初始赋值。

>---
#### 局部变量

局部变量在函数体、语句块中声明出现。局部变量的生命周期是程序执行期间保证为其保存存储空间的部分。此生命周期从进入与其关联的作用域开始扩展，至少到该作用域的执行以某种方式结束为止。若局部变量被匿名函数捕获，那么它的生命周期至少延续到从匿名函数创建的委托或表达式树，以及引用捕获变量的任何其他对象符合垃圾回收条件为止。

每次进入局部变量的作用域时都会实例化它。对于 `foreach` 的迭代变量，每次迭代都会创建一个新的只读变量。局部变量在使用前必须明确赋值。

> *弃元*

弃元 `_` 是一个没有名称的局部变量，由声明表达式引入。弃元也可以作为 `out` 参数传递。由于弃元没有被明确赋值，所以访问它的值始终是错误的。但有些声明中 `_` 是一个有效的标识符，此时 `_` 是一个明确赋值的变量存在，在其作用域范围内，弃元无法使用。

>---
#### 变量明确赋值

在函数成员或匿名函数的可执行代码中的给定位置，如果编译器可以通过特定的静态流分析，证明该变量已被自动初始化或已成为至少一次赋值的目标，则称该变量已被明确赋值：
- 初始赋值的变量总是被认为是明确赋值的。
- 初始未赋值的变量，如果在指定位置由所有可能的执行路径中包含以下行为之一时，被认为是在给定位置明确赋值：
  - 简单的赋值操作，其中变量是左操作数。
  - 将变量作为输出参数传递的调用表达式或对象创建表达式。
  - 对于局部变量，为变量做一个局部变量声明，并包含变量初始化式。

在以下上下文中，明确赋值是必需的：
- 变量必须在获取其值的每个位置明确赋值。
- 变量必须在作为引用参数、输入参数传递的每个位置进行明确赋值。
- 函数成员的所有输出参数都必须在函数成员通过语句返回前明确赋值。
- 结构类型的实例构造函数 `this` 变量必须在该实例构造函数返回的每个位置明确赋值，结构变量被认为是明确赋值的前提是该实例变量包含的所有结构类型变量都被视为是明确赋值。

> 初始分配的变量

静态变量、类实例变量、初始分配的结构实例变量、数组元素、值参数、引用参数、输入参数、`catch` 或 `foreach` 子句的变量等。

> 初始未分配的变量

初始未分配的结构实例变量、输出参数、局部变量。

>---

#### 隐式变量声明

声明局部变量时，可以让编译器从初始化表达式推断出变量的类型。使用 `var` 关键字隐式声明变量，隐式变量只能应用于局部变量声明。`var` 的常用于接收函数返回、类型推断、模式匹配、匿名类型的声明、隐式变量的声明等。

```csharp
var Ps = new PointArray(PointArray.RandomPoints(50));
Ps.AddPoints(PointArray.RandomPoints(50));
var first_Ps = Ps.GetPointsInQuadrant(1);
var Second_Ps = Ps.GetPointsInQuadrant(2);
var Third_Ps = Ps.GetPointsInQuadrant(3);
var Forth_Ps = Ps.GetPointsInQuadrant(4);

Print(first_Ps);
Print(Second_Ps);
Print(Third_Ps);
Print(Forth_Ps);
// -----------------------------------------------
static void Print<T>(in IEnumerable<T> arr)
{
    foreach (var item in arr)
        Console.WriteLine(item.ToString());
}

record struct PointArray(params (int x, int y)[] points)
{
    public readonly int PointsCount => points.Length;
    private bool PrintMembers(System.Text.StringBuilder sb)
    {
        if (points.Length > 0)
        {
            sb.Append(points[0]);
            foreach (var p in points[1..])
                sb.Append(" ," + p);
            return true;
        }
        return false;
    }
    public static (int, int)[] RandomPoints(int count)
    {
        int seed = DateTime.Now.Microsecond;
        Random r = new Random(seed);
        var ps = new (int, int)[count];
        for (int i = 0; i < count; i++)
            ps[i] = (r.Next(-128, 128), r.Next(-128, 128));
        return ps;
    }

    public void AddPoints(params (int x, int y)[] points)
    {
        (int x, int y)[] newPoints = new (int x, int y)[points.Length + this.points.Length];
        Array.Copy(this.points, newPoints, this.points.Length);
        Array.Copy(points, 0, newPoints, this.points.Length, points.Length);
        this.points = newPoints;
    }
    public (int, int)[] GetPointsInQuadrant(uint order)
    {
        if (order < 0 || order > 4)
            return default;
        var state = static delegate (int x, int y, uint order)
        {
            return order switch
            {
                1 => x > 0 && y > 0,
                2 => x > 0 && y < 0,
                3 => x < 0 && y < 0,
                4 => x < 0 && y > 0,
            };
        };
        var ps = from (int x, int y) p in this.points
                 where state(p.x, p.y, order)
                 select p;
        return ps.ToArray();
    }
}
```

可以使用 `var` 作为 `out` 参数传递。隐式类型输出变量的类型是重载解析选择的方法签名中相应参数的类型。当无法重载决策时（例如发生歧义）需要显式输入变量参数的类型。

```csharp
class Sample
{
    static void Fun(out int num)
    {
        num = 1;
    }
    static void Fun(out string mess)
    {
        mess = "";
    }
    static void Main(string[] args)
    {
        Fun(out var num);  // 隐式声明，歧义
        Fun(out string mess);  // 显式输入类型
    }
}
```

>---

#### 变量引用的原子性

`bool`、`char`、`byte`、`sbyte`、`short`、`ushort`、`int`、`uint`、`float` 和引用类型的读取和写入是原子的，具有前面列表中基础类型的枚举类型的读写也是原子的，本机大小的整数 `nint`、`unint` 的读写也是原子的；`long`、`ulong`、`double`、`decimal` 和用户定义类型的读写不能保证为原子性。

>---

#### 引用变量和引用返回

引用变量是指对另一个变量的变量。引用变量是 `ref` 修饰的局部变量。引用变量存储对变量的引用，而不是变量的值。

当在需要值的地方使用引用变量时，将返回其引用的值。当引用变量是赋值的目标时，它就是被赋值的引用对象。若要更改引用变量的引用对象时，使用 `= ref` 进行更改关联引用。

```csharp
int num1 = 10;
int num2 = 20;

ref int pnum = ref num1;
pnum = 100;
Console.WriteLine(num1);  // 100
Console.WriteLine(num2);  // 20
pnum = ref num2;
pnum = 10010;
Console.WriteLine(num1);  // 100
Console.WriteLine(num2);  // 10010
```

引用返回是由 `return ref` 方法返回的引用变量。

```csharp
int[] arr = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
ref int arr5 = ref Fun();

arr5 = 10086;
Console.WriteLine(arr[5]);  // 10086

ref int Fun()
{
    // element is a reference variable that refers to arr[5]
    ref int element = ref arr[5];
    // return reference to arr[5];
    return ref element; 
}
```

---
### 表达式与运算符

表达式是运算符和操作数的序列，该子句定义了语法、操作数和运算符的求值顺序以及表达式的含义。

>---
#### 静态绑定和动态绑定

*绑定（Binding）* 是根据表达式的类型或值（参数、操作数、接收方）来确定一个操作含义的过程。例如，方法调用的绑定是根据接收方和参数的类型确定的。运算符的绑定是根据其操作数的类型确定的。

在 C# 中，操作的绑定通常是在编译时根据其子表达式的编译时类型确定的。如果表达式包含错误，编译器会检测并报告错误。这种方法被称为 *静态绑定*。

如果表达式是动态表达式（即操作中包含有 `dynamic` 类型），这表明它参与的任何绑定都应该基于其运行时类型，而不是编译时的类型。这种操作的绑定被延迟到程序运行期间执行该操作的时间。这被称为 *动态绑定*。

当一个操作被动态绑定时，编译器通常不会执行类型检查。如果运行时绑定失败，则在运行时抛出异常。

C# 中服从绑定的操作有成员访问、方法调用、委托调用、元素访问、对象创建、重载运算符操作、赋值运算、隐式和显式转换。当不涉及动态表达式时，C# 默认为静态绑定。若其中一个构成的表达式为动态表达式时，将该操作视为动态绑定。

如果方法调用是动态绑定的，并且任何参数（包括接收方）都有 `in` 修饰符，则会导致编译时错误，`in` 参数不能用于动态绑定的表达式。

```csharp
object  o = 5;
dynamic d = 5;

Console.WriteLine(5);  // static  binding to Console.WriteLine(int)  编译时选择重载
Console.WriteLine(o);  // static  binding to Console.WriteLine(object)  编译时选择重载
Console.WriteLine(d);  // dynamic binding to Console.WriteLine(int)  运行时选择重载
```

> *动态绑定*

动态绑定允许 C# 程序与 *动态对象* 交互，包括 C# 类型对象和不遵循 C# 类型系统常规规则的对象。也就是说，动态对象可以是具有不同类型系统的其他编程语言中的对象，也可以是以编程方式实现不同操作的绑定语义的对象。

动态对象实现其自身语义的机制是实现定义的。给定的接口由动态对象实现，以向 C# 运行时发出信号，表明它们具有特殊的语义。每当动态对象上的操作被动态绑定时，它们将接管自己的绑定语义而不是使用 C# 规范中指定的操作。

> *子表达式的类型*

当一个操作被静态绑定时，子表达式的类型（例如，接收者、参数、索引或操作数）总是被认为是该表达式的编译时类型。

当动态绑定操作时，根据子表达式的编译时类型确定子表达式的类型：
- 编译时类型为 `dynamic` 的子表达式被认为具有该表达式在运行时计算得到的实际值的类型。
- 编译时类型是类型参数的子表达式，被认为具有该类型参数在运行时绑定到的类型。
- 否则，子表达式被认为具有其编译时类型。

>---
#### 运算符与优先级

表达式有操作数和运算符构造，表达式的运算符指示对操作数应用哪些操作。包含三种类型的运算符：
- 一元运算符：接受一个操作数，并使用前缀（`-x`）或后缀表示法（`x++`）。
- 二元运算符：接受两个操作数，并且都是用中辍表示法（`x + y`）。
- 三元运算符：仅有一个三元运算符 `?:`，使用中辍表示法（`c?x:y`）。

表达式中运算符的求值顺序由运算符的优先级和结合性决定。

某些运算符可以被重载。运算符重载允许为其中一个或两个操作数为用户定义的类或结构类型指定用户定义的运算符实现。

> 运算符优先级和结合性

优先级从高到底的顺序列举 C# 支持的运算符：

| **Category**                     | **Operators**                                          |
| -------------------------------  | -------------------------------------------------------|
| 基本表达式                          | `x.y` `x?.y` `f(x)` `a[x]` `a?[x]` `x++` `x--` `x!` `new` `typeof` `default` `checked` `unchecked` `delegate` `stackalloc` `nameof` `sizeof` `x->y` |
| 一元                            | `+x` `-x` `!x` `~x` `++x` `--x` `(T)x` `await x` `&x` `*x` `true` `false`| 
|索引与范围 | `^n` `a..b` |
|`switch` 和 `with` 表达式|  `switch {...}` `with {...}` |
| 乘法                   | `x * y` `x / y` `x % y` |
| 加法                         | `x + y` `x - y` |
| 移位                            | `x << y` `x >> y` `x >>> y` |
| 关系和类型测试      | `x < y` `x > y` `x <= y` `x >= y` `is` `as` |
| 相等                      | `x == y` `x != y` |
| 布尔逻辑或按位逻辑 AND                      | `x & y`  |
| 布尔逻辑或按位逻辑 XOR              | `x ^ y`  |
| 布尔逻辑或按位逻辑 OR                       | `x \| y`  |
| 条件 AND                  | `x && y`  |
| 条件 OR                   | `x \|\| y`  |
| 空合并运算或 `throw` 表达式                  | `x ?? y`  `throw x`  |
| 条件运算符                      | `?:`   |
| 赋值与 Lambda 声明 | `x = y` `x = ref y` `x *= y` `x /= y ` `x %= y` `x += y` `x -= y` `x <<= y` `x >>= y` `x >>>= y` `x &= y` `x ^= y` `x \|= y` `=>`   |

当操作数出现在两个具有相同优先级的运算符之间时，运算符的结合性控制运算符的执行顺序：
- 除了赋值运算和空合并运算外，所有的二元运算符都是左结合性的，即操作从左到右执行。如 `a + b - c` 将计算 `(a + b) - c`。
- 右结合运算符从右往左的顺序计算。赋值运算符、null 合并运算符、lambda `=>` 和条件运算符 `?:` 是右结合运算符。 例如，`x = y = z` 将计算为 `x = (y = z)`。

使用括号更改运算符的结合性和优先级：

```csharp
int a = 13 / 5 / 2;
int b = 13 / (5 / 2);
Console.WriteLine($"a = {a}, b = {b}");  // output: a = 1, b = 6
```

>---

#### 运算符重载

用户定义类型可以重载一元和二元运算符。相应的复合运算符也会隐式重载。

从 C# 11 开始，重载 **算术运算符** 时，可以使用 `checked` 关键字定义该运算符的已检查版本。定义已检查的运算符时，还必须定义不带 `checked` 修饰符的相应运算符的未检查版本。

```csharp
record struct Point(double x, double y)
{
    // 二元算数重载
    public static Point operator +(Point lhs, Point rhs) => new Point(lhs.x + rhs.x, lhs.y + rhs.y);
    public static Point operator -(Point lhs, Point rhs) => new Point(lhs.x - rhs.x, lhs.y - rhs.y);
    // 二元 checked - 重载
    public static Point operator checked -(Point lhs, Point rhs) => new Point(lhs.x - rhs.x, lhs.y - rhs.y);

    // 一元重载
    public static Point operator ++(Point lhs) => new Point(++lhs.x, ++lhs.y);
    public static Point operator checked -(Point lhs) => new Point(-lhs.x, -lhs.y);
}
```

> *可重载的运算符*

- 算数运算符：一元 `++`、`--`、`+`、`-` 和二元 `*`、`/`、`%`、`+`、`-` 算术运算符。
- 逻辑运算符：一元 `!` 和二元 `&`、`|`、`^`。
- 比较运算符：二元 `<` 和 `>`、`<=` 和 `>=`、`==` 和 `!=`，成对的运算符需要同时重载。
- 位运算：一元 `~` 和二元 `&`、`|`、`^`。
- 移位运算符：二元 `<<`、`>>`、`>>>`，C#11 之前右操作数必须为 `int`，C#11 开始重载移位运算符的右侧操作数的类型可以是任意类型。
- 一元 `true` 和 `false` 运算符，只能返回 `bool` 类型。用户类型定义了 `&` 或 `|` 运算符重载时，可以使用相应的条件逻辑运算符 `&&` 或 `||`。

---
#### 成员访问

- `.`（成员访问）：用于访问命名空间、类型、对象的成员。
- `[]`（数组元素或索引器访问）：用于访问数组元素或类型索引器。
- `?.` 和 `?[]`（`null` 条件访问）：仅当操作数为非 `null` 时才用于执行成员或元素访问运算，否则返回 `null`。
- `()`（方法调用）：用于调用方法成员、扩展方法或调用委托对象。

```csharp
// . 成员访问
System.Console.WriteLine("Hello, World");

// [] 数组或索引器元素访问
int[] arr = [1, 2, 3, 4, 5, 6, 7];
arr[0] = 1000;

// ?. ?[] Null 条件访问 
double SumNumbers(List<double[]> setsOfNumbers, int indexOfSetToSum)
    => setsOfNumbers?[indexOfSetToSum]?.Sum() ?? double.NaN;
var sum = SumNumbers(null, 0);
Console.WriteLine(sum);  // output: NaN

// () 方法或委托调用
var Print = (string mess) => Console.WriteLine("PRINT : " + mess);
Print("Hello, World");
```

>---

#### this 访问

只能在类或结构的实例构造函数、实例方法、实例访问器或终结器的块中使用 `this`。接口提供实现的实例成员块中也可以使用 `this`。`this` 有以下含义之一：

- 当 `this` 在类的实例构造函数中的表达式中使用时，它被归类为一个值。值的类型是发生使用的类的实例类型，且是对正在构造的对象的引用。

- 当 `this` 在类的实例方法或实例访问器中的表达式中使用时，它被归类为一个值。该值的类型是发生使用的类的实例类型，且是对调用该方法或访问器的对象的引用。
  
- 当 `this` 在结构的实例构造函数中的表达式中使用时，它被归类为变量。变量的类型是发生使用的结构的实例类型，且表示正在构造的结构。如果构造函数声明没有构造函数初始化式，则 `this` 变量的行为与结构类型的 `out` 形参完全相同。这意味着变量必须在实例构造函数的每个执行路径中被明确地赋值。

- 当 `this` 用于结构的实例方法或实例访问器中的表达式中使用时，它会归类为变量。变量的类型是发生使用的结构的实例类型。如果方法或访问器不是迭代器，则该 `this` 变量表示调用了方法或访问器的结构，其行为与 `ref` 结构类型的参数完全相同。否则认为该 `this` 变量表示为其调用了方法或访问器的结构的副本，其行为与结构类型的值参数完全相同。

- 类的 `this` 可以在匿名函数中使用，匿名函数将捕获对类实例对象的引用；结构的 `this` 无法在匿名函数或局部函数中使用，可以在外部范围内先声明一个局部变量并分配 `this`。

- `this` 不能在静态方法、静态属性访问器或字段声明的变量初始化值中引用。

```csharp
class Sample
{
    int Value;
    public Sample(int Value) => this.Value = Value;
}
```

>---

#### base 访问

`base` 通常用于访问当前类或结构中类似命名的被隐藏的基类成员。只能在实例构造函数、实例方法、实例访问器、终结器的块中使用 `base`。在类中充当 `base` 基类对象的引用，对于结构类型则是对其直接基类 `System.ValueType` 的引用。 

当 `base` 引用虚函数成员时，在运行时通过查找函数成员的最派生实现来确定的（非 `this`）。在虚函数成员的重写方法中，可以使用 `base` 调用该函数成员的继承实现。如果 `base` 引用的函数成员是抽象的，则会发生绑定时错误。

```csharp
class Base
{
    public virtual void Fun(string mess) => Console.WriteLine(mess);
}
class Sample : Base
{
    public override void Fun(string mess)
    {
        base.Fun("Output: " + mess);
    }
}
```

>---
#### new

`new` 运算符用于创建类型的新实例，主要是：
- 对象创建表达式用于创建类或值类型的新实例。
- 数组创建表达式用于创建数组类型的新实例。
- 委托创建表达式用于创建委托类型的新实例。
- 匿名对象创建表达式用于构造匿名类型的新实例。

> *对象创建*

```ANTLR
object_creation_expression
    : new <TypeName> (<argument_list>?) { member_initializer_list? }?
    | new <TypeName> { member_initializer_list? }?  
```

对象创建表达式的类型必须是类类型、结构类型、类或结构的构造类型、`using` 声明类型，不能是元组表达式、抽象或静态类。

参数列表仅在类型是类或结构类型时可用（调用对应参数签名的构造函数）。对象创建表达式可以省略构造函数参数列表和括号，前提是它包含对象初始值设定项。

```csharp
using Point = (int x, int y);
class Sample
{
    public int x { get; set; }
    public int y { get; set; }
    public Sample() { }
    public Sample(int x, int y) { }

    static void Main(string[] args)
    {
        // 对象创建表达式
        Sample s1 = new Sample();
        Sample s2 = new();
        Point p1 = new Point();
        Point p2 = new();

        // 使用参数列表的对象创建
        Sample s3 = new Sample(x: 1, y: 2);
        Sample s4 = new(1, 2);
        Point p3 = new(1, 2);


    }
}
class Rectangle
{
    public Point P1 { get; } = new Point();
    public Point P2 { get; } = new Point();
}
```

>---
#### 初始化器

初始化器分为对象初始化器和集合初始化器，分别为创建对象或集合时为其提供初始化设定项。

对象初始值设定项为对象的零个或多个可访问的字段、属性、索引元素指定值。

```csharp
using Point = (int x, int y);
class Sample
{
    public int x { get; set; }
    public int y { get; set; }
    static void Main(string[] args)
    {
        // 使用对象初始化设定项的对象创建
        Sample s5 = new Sample { x = 1, y = 2 };
        Sample s6 = new() { x = 1, y = 2 };
        Point p4 = new() { x = 1, y = 2 };
        Point p5 = new Point { x = 1, y = 2 };

        // 使用索引器
        Dictionary<string, int> Persons = new Dictionary<string, int>
        {
            ["Tom"] = 10,
            ["Mary"] = 13,
            ["Hello"] = 5,
            ["World"] = 12
        };
    }
}
```

`required` 修饰的字段或属性，强制调用方在创建对象时使用对象初始值设定项设置这些 `required` 的值。

```csharp
var person = new Person { FirstName = "Joe", LastName = "Doe" };
public class Person
{
    public required string FirstName { get; set; }
    public required string LastName;
}
```

具有 `init` 访问器的属性，可以在构造函数或对象初始值设定项中设置它们的值。

```csharp
var person = new Person { FirstName = "Joe", LastName = "Doe" };
public class Person
{
    public string? FirstName { get; init; }
    public string? LastName { get; init; }
}
```

集合初始化项指定集合的元素，集合对象必须是实现 `IEnumerable` 的类型，且包含一个可访问的 `Add` 实例方法或扩展方法。集合初始值设定项允许指定一个或多个元素初始值设定项。元素初始值设定项可以是简单的值、表达式或对象初始值设定项。

```csharp
List<int> digits = new List<int> { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };  
Dictionary<string, int> person = new Dictionary<string, int>
{
    { "Tom",10 },
    {"Mary", 13 },
    {"Hello", 5 },
    {"World", 12 }
};

// 用户定义集合类型
SampleList<int> arr = new SampleList<int> { 1, 2, 3, 4, 5 };
class SampleList<T> : IEnumerable<T>
{
    List<T> list = new List<T>(80);
    public void Add(T val) => list.Add(val);
    public IEnumerator<T> GetEnumerator() => list.AsEnumerable().GetEnumerator();
    IEnumerator IEnumerable.GetEnumerator() => list.GetEnumerator();
}
```

具有集合只读属性初始化的对象初始值设定项，由于无法为属性分配新列表，但是可以使用省略列表创建。

```csharp
Persons owner = new Persons
{
    Names = // new List<string> 省略创建
    {
        "Tom", "Jerry", "Hello", "World"
    }
};
public class Persons
{
    public IList<string> Names { get; } = new List<string>();
}
```

>---
#### typeof

`typeof` 操作符用于获取 `System.Type` 的类型对象。运算符的参数可以是类型名称、未绑定的类型名称、`void`，不能是 `dynamic` 类型。`System.Type` 与 `System.Reflection` 中的类能够用来获取有关加载的程序集、`Type` 对象关联类型等的相关信息。

`typeof` 运算符可用于类型参数，结果是绑定到类型参数的运行时类型的 `System.Type`的类型对象。`typeof` 也可用于构造类型会未绑定的泛型类型，其中未绑定泛型对象的 `Type` 类型对象和实例类型的 `Type` 对象不同，实例类型在运行时始终是封闭式构造类型，它的 `Type` 对象依赖于正在使用的运行时类型参数。未绑定的泛型类型没有类型参数。



```csharp
class Sample<T>
{
    public static void PrintTypes()
    {
        Type[] t = {
            typeof(int),                     // System.Int32
            typeof(System.Int32),            // System.Int32
            typeof(string),                  // System.String
            typeof(double[]),                // System.Double[]
            typeof(void),                    // System.Void
            typeof(T),                       // System.Int32
            typeof(Sample<T>),               // Sample`1[System.Int32]
            typeof(Sample<Sample<T>>),       // Sample`1[Sample`1[System.Int32]]
            typeof(Sample<>)                 // Sample`1[T] 
        };
        for (int i = 0; i < t.Length; i++)
            Console.WriteLine(t[i]);
    }
}
```

`object.GetType()` 方法也可以用来获取对象运行时类型的 `Type` 对象。使用 `typeof` 运算符和 `object.GetType()` 来检查表达式结果的运行时类型是否与给定的类型完全匹配。

```csharp
object b = new Giraffe();
Console.WriteLine(b is Animal);  // output: True
Console.WriteLine(b.GetType() == typeof(Animal));  // output: False

Console.WriteLine(b is Giraffe);  // output: True
Console.WriteLine(b.GetType() == typeof(Giraffe));  // output: True

class Animal;
class Giraffe : Animal;
```

>---

#### sizeof 

`sizeof` 运算符用于返回给定类型的变量所占用的 8 位字节数。`sizeof` 运算符的参数通常是一个非托管 `unmanaged` 类型的名称，或是一个限定为非托管类型的类型参数。

对于预定义大小内置类型 `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`char`、`float`、`double`、`decimal`、`bool`，`sizeof` 运算符产生一个常量值。

对于枚举类型 `E`，表达式 `sizeof(E)` 的结果是一个常数值，等于枚举基础类型的大小。

对于所有其他类型，`sizeof` 运算符的结果是实现定义的，并且被归为变量。由于本机整数类型 `nint` 和 `nuint`、任意指针类型、任意托管类型（相当于是指针）、用户定义结构、可空值类型没有预定义的大小，因此 `sizeof` 只能在不安全的上下文中使用。

结构类型的成员的打包顺序未指定，出于对齐的目的，可以在结构体的开头、内部、末尾进行未命名的填充，用作填充的位的内容是不确定的。当 `sizeof` 应用到 `struct` 类型的操作数时，其结果是该类型变量的总字节数，并包括填充在内。


```csharp
Sample<int>.PrintSizes();
struct Sample<T>()
{
    int value = 0;
    int value1 = 0;
    int value2 = 0;
    public unsafe static void PrintSizes()
    {
        int[] sizes = {
            sizeof(sbyte),    sizeof(sbyte?),   // 1,2
            sizeof(byte),     sizeof(byte?),    // 1,2
            sizeof(short),    sizeof(short?),   // 2,4
            sizeof(ushort),   sizeof(ushort?),  // 2,4
            sizeof(int),      sizeof(int?),     // 4,8
            sizeof(uint),     sizeof(uint?),    // 4,8
            sizeof(long),     sizeof(long?),    // 8,16
            sizeof(ulong),    sizeof(ulong?),   // 8,16
            sizeof(float),    sizeof(float?),   // 4,8
            sizeof(double),   sizeof(double?),  // 8,16
            sizeof(decimal),  sizeof(decimal?), // 16,24
            sizeof(bool),     sizeof(bool?),    // 1,2
            sizeof(char),     sizeof(char?),    // 2,4
            sizeof(AttributeTargets),    sizeof(AttributeTargets?),  // 4,8
            sizeof(nint),            sizeof(nint?),       // 8,16
            sizeof(nuint),           sizeof(nuint?),      // 8,16
            sizeof(dynamic),         sizeof(dynamic?),    // 8,8
            sizeof(object),          sizeof(object),      // 8,8
            sizeof(string),          sizeof(string),      // 8,8
            sizeof(int[]),           sizeof(int[]),       // 8,8
            sizeof(int[][]),         sizeof(int[][]),     // 8,8
            sizeof(double[]),        sizeof(double[]),    // 8,8
            sizeof(double[,]),       sizeof(double[,]),   // 8,8
            sizeof(Sample<T>),       sizeof(Sample<T>?),  // 12,16
            sizeof(Sample<T?>),      sizeof(Sample<T?>?), // 12,16
            sizeof(Sample<Sample<T>>),      // 12
            sizeof(void*),                  // 8
            sizeof(int*),              sizeof(int?*),     // 8,8
            sizeof(double*),           sizeof(double?*),  // 8,8
            sizeof(decimal*),          sizeof(decimal?*), // 8,8
            sizeof(string*),           sizeof(object*),   // 8,8
            sizeof(delegate* <void>),                   // 8
            sizeof(delegate* unmanaged<void>),          // 8
            sizeof(delegate* managed<int, void>),       // 8
            sizeof(delegate* unmanaged<int, void>)      // 8
        };
        for (int i = 0; i < sizes.Length; i++)
            Console.Write(sizes[i] + ",");
    }
}
```

>---
#### nameof

`nameof` 表达式用于以常量字符串的形式获取程序实体（可以是命名空间、类型名称、成员名称、变量名、类型参数名称、标识符等程序实体）的名称。`nameof` 表达式在运行时没有作用，它的值是命名实体的最后一个标识符，因此它的程序实体参数不能求值，不能是表达式。

`nameof` 表达式在编译时对实体执行简单的名称和成员访问查找。若实体是方法组，则不需要也不能指定类型参数；命名实体也不能是动态类型的表达式，可以是动态类型的变量标识符；不能是 C# 关键字。

若标识符中包含 `@` 前缀，将被删除；每个 Unicode 序列也被转换成对应的 Unicode 字符；删除任何格式化字符串。

```csharp
using TestAlias = System.String;
class Program
{
    static void Main()
    {
        var point = (x: 3, y: 4);

        string n1 = nameof(System);                      // "System"
        string n2 = nameof(System.Collections.Generic);  // "Generic"
        string n3 = nameof(point);                       // "point"
        string n4 = nameof(point.x);                     // "x"
        string n5 = nameof(Program);                     // "Program"
        string n6 = nameof(System.Int32);                // "Int32"
        string n7 = nameof(TestAlias);                   // "TestAlias"
        string n8 = nameof(List<int>);                   // "List"
        string n9 = nameof(Program.InstanceMethod);      // "InstanceMethod"
        string n10 = nameof(Program.GenericMethod);      // "GenericMethod"
        string n11 = nameof(Program.NestedClass);        // "NestedClass"

        // Invalid
        // string x1 = nameof(List<>);            // Empty type argument list
        // string x2 = nameof(List<T>);           // T is not in scope
        // string x3 = nameof(GenericMethod<>);   // Empty type argument list
        // string x4 = nameof(GenericMethod<T>);  // T is not in scope
        // string x5 = nameof(int);               // Keywords not permitted
        // Type arguments not permitted for method group
        // string x6 = nameof(GenericMethod<Program>);
    }

    void InstanceMethod() { }
    void GenericMethod<T>()
    {
        string n1 = nameof(List<T>); // "List"
        string n2 = nameof(T);       // "T"
    }
    class NestedClass : Program;
}
```

从 C#11 起，`nameof` 表达式允许在方法或参数的特性中使用 `nameof(parameter)`：

```csharp
[MyAttribute(nameof(parameter))] void M(int parameter) { }  // 方法参数

[MyAttribute(nameof(TParameter))] void M<TParameter>() { }  // 方法类型参数

void M(int parameter, [MyAttribute(nameof(parameter))] int other) { }  // 参数特性
```

>---

#### 空合并

`??` 和 `??=` 空合并运算符在左操作数为 `null` 时，返回右操作数。若左操作数计算结果非 `null` 时，运算符不会计算其右操作数。空合并运算符是右结合运算符。

`??=` 用于左操作数为 `null` 时将右操作数赋值给左操作数，它的左操作数必须是变量、属性或索引器元素，类型必须是可以为 `null` 的值类型或引用类型。 

```csharp
int? num = null;
int val = num ?? default;
num ??= default;
```

可在包含 `?.` 和 `?[]` 的表达式中，当表达式结果为 `null` 时，可以使用 `??` 运算符来提供替代表达式用于求值。

```csharp
double SumNumbers(List<double[]> setsOfNumbers, int indexOfSetToSum)
    => setsOfNumbers?[indexOfSetToSum]?.Sum() ?? double.NaN;
```

可为 null 值类型转换为其基础类型时，`??` 可用于空检查并为基础类型提供默认值。

```csharp
int? num = null;
int _num = num ?? -1;

// 等价于
int _num = num.HasValue ? num.Value : -1;
```

可以使用 `throw` 作为 `??` 运算符的右操作符。

```csharp
public string Name
{
    get => name;
    set => name = value ?? throw new ArgumentNullException(nameof(value), "Name cannot be null");
}
```

>---

#### 弃元

弃元（`_`）是一种在应用程序代码中人为取消使用的占位符变量，相当于未赋值的变量，但是它们没有值。弃元将意图传达给编译器和其他读取代码的文件：用户打算忽略表达式的结果。可以使用弃元用来忽略表达式的结果、元组表达式的一个或多个成员、方法的 `out` 参数或模式匹配表达式的目标。

> 弃元的常见应用

- 析构元组和用户类型对象解构：析构元组或解构用户类型对象时，可以使用弃元用以忽略不需要的位置返回值。

```csharp
var (_, _, _, pop1, _, pop2) = QueryCityDataForYears("New York City", 1960, 2010);
Console.WriteLine($"Population change, 1960 to 2010: {pop2 - pop1:N0}");
// The example displays the following output:
//      Population change, 1960 to 2010: 393,149

static (string, double, int, int, int, int) QueryCityDataForYears(string name, int year1, int year2)
{
    int population1 = 0, population2 = 0;
    double area = 0;
    if (name == "New York City")
    {
        area = 468.48;
        if (year1 == 1960)
            population1 = 7781984;
        if (year2 == 2010)
            population2 = 8175133;
        return (name, area, year1, population1, year2, population2);
    }
    return ("", 0, 0, 0, 0, 0);
}
```

- 从 C#9 开始，可以使用弃元指定 Lambda 表达式或匿名函数中不使用的两个或更多输入参数。

```csharp
Func<int, int, int, int> Func = (_, _, val) => val * val;
var Func2 = delegate (int _, int _, int val) { return val * val; };
```

- 对具有 `out` 参数的方法的调用。

```csharp
string[] dateStrings = {"05/01/2018 14:57:32.8", "2018-05-01 14:57:32.8",
                      "2018-05-01T14:57:32.8375298-04:00", "5/01/2018",
                      "5/01/2018 14:57:32.80 -07:00",
                      "1 May 2018 2:57:32.8 PM", "16-05-2018 1:00:32 PM",
                      "Fri, 15 May 2018 20:10:57 GMT" };

foreach (string dateString in dateStrings)
{
    if (DateTime.TryParse(dateString, out _))
        Console.WriteLine($"'{dateString}': valid");
    else
        Console.WriteLine($"'{dateString}': invalid");
}
```

- `switch` 表达式中使用弃元匹配任意的表达式，包括 `null` 在内。

```csharp
static Point Transform(Point point) => point switch
{
    { X: 0, Y: 0 } => new Point(0, 0),
    { X: var x, Y: var y } when x < y => new Point(x + y, y),
    { X: var x, Y: var y } when x > y => new Point(x - y, y),
    _ => new Point(2 * point.X, 2 * point.Y),  // 弃元模式
};
public readonly record struct Point(int X, int Y);
```

- 可使用独立弃元来指示要忽略的任何变量。例如使用弃元来忽略异步操作返回的 `Task` 对象，并忽略该异步操作生成的任何错误。

```csharp
static async Task ExecuteAsyncMethods()
{
    Console.WriteLine("About to launch a task...");
    _ = Task.Run(() =>
    {
        var iterations = 0;
        for (int ctr = 0; ctr < int.MaxValue; ctr++)
            iterations++;
        Console.WriteLine("Completed looping operation...");
        throw new InvalidOperationException();
    });
    await Task.Delay(5000);
    Console.WriteLine("Exiting after 5 second delay");
}
// The example displays output like the following:
//       About to launch a task...
//       Completed looping operation...
//       Exiting after 5 second delay
```

- `_` 也是有效的标识符，因此在支持弃元的上下文之外，若已有名为 `_` 的标识符已在范围内，则无法使用弃元。

```csharp
private static bool RoundTrips(int _)
{
    string value = _.ToString();
    int newValue = 0;
    _ = Int32.TryParse(value, out newValue);
  // error CS0029: Cannot implicitly convert type 'bool' to 'int'
    return _ == newValue;
}
```

>---
#### 空包容

一元后缀 `!` 运算符是 `null` 包容运算符或 `null` 抑制运算符。在已启用的可为空的注释上下文中，使用 `null` 包容运算符来取消上述表达式的所有可为 `null` 警告。`null` 包容运算符在运行时不起作用，它仅通过更改表达式的 `null` 状态来影响编译器的静态流分析。

```csharp
#nullable enable
var person_warning = new Person(null);
// Warning CS8625: Cannot convert null literal to non-nullable reference type
var person1_no_warning = new Person(null!);
public class Person(string name)
{
    public string Name  => name ?? throw new ArgumentNullException(nameof(name));
}
```

> NotNullWhen

- 使用 `NotNullWhen` 属性告知编译器，当方法返回 `true` 时，`IsValid` 方法的参数不能是 `null`。

```csharp
#nullable enable
using System.Diagnostics.CodeAnalysis;
class Sample
{
    public static void Main()
    {
        Person? p = Find("John"); ;
        if (IsValid(p))
            Console.WriteLine($"Found {p.Name}");
    }
    public static bool IsValid([NotNullWhen(true)] Person? person)
    //public static bool IsValid(Person? person)  // p.Name: Dereference of a possibly null reference
        => person is not null && person.Name is not null;
    public class Person(string name)
    {
        public string Name => name ?? throw new ArgumentNullException(nameof(name));
    }
    static Person? Find(string name)
        => name is not null ? new Person(name) : null;
}
```

>---

#### checked, unchecked

`checked` 和 `unchecked` 运算符用于控制整型算数和转换的溢出检查上下文，可以是表达式或语句两种形式。运算符这会对计算结果进行是否溢出检查，而不会对函数调用有影响。

```ANTLR
checked
    : checked ( expr )  
    | checked { <block> }
    ;
unchecked
    : unchecked ( expr )  
    | unchecked { <block> }
    ;
```

在整型算数和转换的过程中，当产生的结果太大而无法在目标整数类型中表示时：
- 在 `checked` 检查的上下文中，如果操作是常量表达式，则会发生编译时错误；否则，在运行时执行该操作时，会引发 `System.OverflowException` 异常。
- 在未检查的上下文中，通过丢弃不适合目标类型的任何高阶位来截断结果。

对于非常量表达式的运算，没有任何 `checked` 或 `unchecked` 的运算符或语句包围时，默认是不检查溢出的，除非是外部因素（例如编译器开关或执行环境配置等）调用检查。

对于常量表达式的运算，默认始终检查溢出，除非在 `unchecked` 上下文中。

对于以提升或本身表达式是浮点类型，无论是 `checked` 还是 `unchecked` 的上下文，都不会对浮点类型的结果进行溢出检查。

```csharp
class Sample
{
    static readonly int x = 1000000;
    static readonly int y = 1000000;

    const int cx = 1000000;
    const int cy = 1000000;
    static void Main(string[] args)
    {
        var rt1 = checked(x * y);     // throw Overflow
        var rt2 = unchecked(x * y);   // rt = -727379968
        var rt3 = x * y;              // 取决于是否检查的默认值

        var rt4 = checked(cx * cy);   // 编译时错误，overflow
        var rt5 = unchecked(cx * cy); // rt = -727379968 
        var rt6 = cx * cy;            // 编译时错误，overflow
    }
}
```

>---

#### default

`default` 表达式用于获取类型的默认值。表达式的结果是显式类型的默认值，或者是指定目标类型的默认值。当类型是简单值类型、任何枚举类型、已知引用类型的类型参数或引用类型时，`default` 表达式是一个常量表达时。

```csharp
Sample<String> S1 = new();
Console.WriteLine(S1.Default is null);  // True
Console.WriteLine(S1.Value);     // 0

Sample<double> S2 = new();  
Console.WriteLine(S2.Default);   // 0

Sample<int?> S3 = new();
Console.WriteLine(S3.Default.HasValue);  // False

class Sample<T>
{
    public T Default => default(T);
    public int Value { get; set; } = default;
}
```

>---
#### stackalloc

堆栈分配表达式从执行堆栈中分配一块内存。执行堆栈是存储局部变量的内存区域，不是托管堆的一部分。当当前函数返回时，用于本地变量存储的内存将自动恢复。

```ANTLR
stackalloc_expression
    : stackalloc unmanaged_type [ expression ] <{ stackalloc_initializer }>?
    | stackalloc [] { stackalloc_initializer }
```

`stackalloc` 表达式在堆栈上分配内存块，在表达式 `stackalloc T[E]` 中，`T` 必须是非托管类型。如果没有指定数组的初始化项，新分配的 `stackalloc` 内存块上的内容是未定义的。使用 `stackalloc` 会自动启用公共语言运行时 CLR 中的缓冲区溢出检测功能。

`stackalloc` 表达式只可以用于局部变量的初始化表达式或赋值操作。不能在 `catch` 或 `finally` 子句中使用堆栈分配内存。

在方法返回时，将自动丢弃在方法执行期间创建的堆栈中分配的内存块。不能显式释放使用 `stackalloc` 分配的内存。堆栈中分配的内存块不受垃圾回收的影响，也不必通过 `fixed` 语句固定。

```csharp
// Memory uninitialized
Span<int> span1 = stackalloc int[3];

// Memory initialized
Span<int> span2 = stackalloc int[3] { -10, -15, -30 };

// Type int is inferred
Span<int> span3 = stackalloc[] { 11, 12, 13 };

// Error; result is int*, not allowed in a safe context
var span4 = stackalloc[] { 11, 12, 13 };

// Error; no conversion from Span<int> to Span<long>
Span<long> span5 = stackalloc[] { 11, 12, 13 };

// Converts 11 and 13, and returns Span<long> 
Span<long> span6 = stackalloc[] { 11, 12L, 13 };

// Converts all and returns Span<long>
Span<long> span7 = stackalloc long[] { 11, 12, 13 };

// Implicit conversion of Span<T>
ReadOnlySpan<int> span8 = stackalloc int[] { 10, 22, 30 };

// Implicit conversion of Span<T>
Widget<double> span9 = stackalloc double[] { 1.2, 5.6 };

public class Widget<T>
{
    public static implicit operator Widget<T>(Span<double> sp) { return null; }
}
```

将 `stackalloc` 表达式的结果分配给 `System.Span<T>` 或 `System.ReadOnlySpan<T>` 类型时，可以不使用 `unsafe` 上下文。建议尽可能使用 `Span<T>` 或 `ReadOnlySpan<T>` 类型来处理堆栈中分配的内存。

```csharp
int length = 1000;
Span<byte> buffer = length <= 1024 ? stackalloc byte[length] : new byte[length];

ReadOnlySpan<int> numbers = stackalloc[] { 1, 2, 3, 4, 5, 6 };
var ind = numbers.IndexOfAny(stackalloc[] { 2, 4, 6, 8 });
Console.WriteLine(ind);  // output: 1
```

可以将 `stackalloc` 表达式的结果分配给指针类型，必须使用 `unsafe` 上下文。

```csharp
unsafe
{
    int length = 3;
    int* numbers = stackalloc int[length];
    for (var i = 0; i < length; i++)
        numbers[i] = i;
}
```

堆栈上可用的内存量存在限制，如果在堆栈上分配过多的内存，会引发 `StackOverflowException`。限制使用 `stackalloc` 分配的内存量，如果预期的缓冲区大小低于特定限制，则在堆栈上分配内存；否则，使用所需长度的数组。避免在循环内使用 `stackalloc`。在循环外分配内存块，然后在循环内重用它。

```csharp
const int MaxStackLimit = 1024;
Span<byte> buffer = inputLength <= MaxStackLimit ? 
        stackalloc byte[MaxStackLimit] : new byte[inputLength];
```

>---
#### with

使用 `with` 表达式创建左侧操作数的副本，附加需要修改的特性属性和字段。在 C#9 中，`with` 表达式的左侧操作数必须为记录类型。

从 C#10 开始，`with` 表达式的左侧操作数可以为结构类型或匿名类型。对于引用类型成员，在复制操作数时仅复制对成员实例的引用，副本和原始操作数都具有对同一引用类型实例的访问权限。
 
```csharp
var Point = new { x = 1, y = 1 };
var Point_copy = Point with { x = 10 };

Sample s = new Sample("Ychao") { ID = 1 };
Sample s_copy = s with { Name = "Hello", ID = 2 };

record Sample(string name)
{
    public string Name { get; init; } = name;
    public int ID { get; set; }
}
``` 

>---

#### await

`await` 运算符用于暂停封闭异步函数的求值，直到操作数表示的异步操作完成为止。`await` 只允许在 `async` 声明的异步函数体中使用，在非异步的嵌套方法或匿名方法、`lock` 语句块中、不安全的上下文中不能使用 `await` 表达式，异步的匿名方法无法转换为表达式树类型。

`await` 运算符的操作数是任务类型（`Task`、`Task<TResult>`、`ValueTask`、`ValueTask<TResult>` 等），它表示在计算 `await` 表达式时可能完成或未完成的异步操作。`await` 运算符的目的是暂停封闭异步函数的执行，直到等待的任务完成，然后获得其结果。

```csharp
public class AwaitOperator
{
    public static async Task Main()
    {
        Task<int> downloading = DownloadDocsMainPageAsync();
        Console.WriteLine($"{nameof(Main)}: Launched downloading.");

        int bytesLoaded = await downloading;
        Console.WriteLine($"{nameof(Main)}: Downloaded {bytesLoaded} bytes.");
    }

    private static async Task<int> DownloadDocsMainPageAsync()
    {
        Console.WriteLine($"{nameof(DownloadDocsMainPageAsync)}: About to start downloading.");

        var client = new HttpClient();
        byte[] content = await client.GetByteArrayAsync("https://learn.microsoft.com/en-us/");

        Console.WriteLine($"{nameof(DownloadDocsMainPageAsync)}: Finished downloading.");
        return content.Length;
    }
}
// Output similar to:
// DownloadDocsMainPageAsync: About to start downloading.
// Main: Launched downloading.
// DownloadDocsMainPageAsync: Finished downloading.
// Main: Downloaded 27700 bytes.
```

`await` 表达式的结果必须是可等待的，可等待的表达式 `E` 的结果类型具有一个 `GetAwaiter` 的可访问的无参非泛型的实例或扩展方法，并且返回类型 `A` 必须满足：
- `A` 实现接口 `System.Runtime.CompilerServices.INotifyCompletion`。
- `A` 有一个可访问、可读的 `bool` 类型的实例属性 `IsCompleted`。
- `A` 有一个可访问的无参非泛型实例方法 `GetResult`。 

`GetAwaiter` 方法的目的是为当前等待任务获取一个 `Awaiter` 等待器，对于 `await` 表达式而言，类型 `A` 是一个 `Awaiter` 类型。

`IsCompleted` 属性的目的是确定任务是否完成，如果完成，则不需要暂停求值。

`INotifyCompletion.OnCompleted` 方法用于为 `Task` 任务注册一个 `continuation` “延续” 的委托类型，并在 `Task` 任务完成后调用。

`GetResult` 方法的目的是在任务完成后获得任务的结果。该结果可能是成功完成，可能带有结果值，也可能是由 `GetResult` 方法抛出的异常。

> *await* *表达式的运行时求值顺序*

对于表达式 `await E`：
- 计算 `(E).GetAwaiter()` 求值获取一个 `Awaiter` 类型的等待器 `A`。
- 通过计算 `(A).IsCompleted` 求值的得到一个描述当前任务完成状态的 `bool` 值 `b`。
- 如果 `b` 为 `false`，则求值取决于 `A` 是否实现 `System.Runtime.CompilerServices.ICriticalNotifyCompletion` 接口，定义 `r` 为 `resumption` 恢复委托：
  - 当 `a` 未实现 `ICriticalNotifyCompletion` 接口，则求值 `((a) as INotifyCompletion).OnCompleted(r)`。
  - 当 `a` 实现了 `ICriticalNotifyCompletion` 接口，则求值 `((a) as ICriticalNotifyCompletion).UnsafeOnCompleted(r)`。
  - 然后暂停执行，并将控制权返回给当前异步方法的调用者。
- 立即调用（若 `b` 为 `true`）或稍后调用（`b` 为 `false`）恢复委托，以调用 `(a).GetResult()` 求值，若返回一个值，则它就是 `await` 表达式的结果，否则没有返回值。

方法 `OnCompleted` 和 `UnsafeOnCompleted` 的实现应该使恢复委托 `r` 最多被调用一次。否则，封闭异步函数的行为是未定义的。

>---
####  算数运算符

一元 `++`（增量）、`--`（减量）、`+`（加）和 `-`（减）运算符。
二元 `*`（乘法）、`/`（除法）、`%`（余数）、`+`（加法）和 `-`（减法）运算符。

> 算数运算中的程序设定

- `ulong` 类型不支持一元 `-` 运算符。
- 整数除法的结果为整数，并等于两数之商向零舍入后的结果。
- 整数余数 `a % b` 的结果是 `a - (a / b) * b` 得出的值，非零余数的符号与左侧操作数的符号相同。
- 优先级：`x++, x--` > `++x, --x, +x, -x` > `*, /, %` > `+, -`。
- 复合运算：二元 `*=`、`/=`、`%=`、`+=`、`-=`。

> 算数溢出与被零除

- 整数被零除总是引发 `DivideByZeroException`。
- 发生整数算术溢出，溢出检查上下文将控制引发的行为，默认算数环境为 `unchecked` 上下文。
- 使用 `float` 和 `double` 类型的算术运算永远不会引发异常。对于 `decimal` 类型的操作数，算术溢出始终会引发 `OverflowException`，被零除总是引发 `DivideByZeroException`。
- 由于实数和浮点运算的浮点表达形式的常规限制，在使用浮点类型的计算中可能会发生舍入误差。

```csharp
// 增量或减量运算
int i = 3;
Console.WriteLine(i);   // output: 3
Console.WriteLine(i++); // output: 3    // use 在前，增量在后
Console.WriteLine(i);   // output: 4
Console.WriteLine(--i); // output: 3    // 增量在前，use 在后
Console.WriteLine(i);   // output: 3

// 一元运算
uint a = 5;
var b = -a;
Console.WriteLine(b);            // output: -5
Console.WriteLine(b.GetType());  // output: System.Int64

// 二元算数
Console.WriteLine(-13 / 5);      // output: -2
Console.WriteLine(13 / 5.0);     // output: 2.6
Console.WriteLine(-5 % 4);       // output: -1
Console.WriteLine(5 % -4);       // output: 1
Console.WriteLine(-5.2f % 2.0f); // output: -1.2
Console.WriteLine(5 + 4.3);      // output: 9.3
Console.WriteLine(47 - 3);       // output: 44
Console.WriteLine(7.5m - 2.3m);  // output: 5.2

// 复合运算
int c = 5;
Console.WriteLine(c += 9);  // c=c+9, output: 14
Console.WriteLine(c -= 4);  // c=c-4, output: 10 
Console.WriteLine(c *= 2);  // c=2*c, output: 20
Console.WriteLine(c /= 4);  // c=c/4, output: 5
Console.WriteLine(c %= 3);  // c=c%3, output: 2
```

---
#### 关系运算符

二元 `<`（小于）、`>`（大于）、`<=`（小于等于）、`>=`（大于等于）、`==`（等于）、`!=`（不等于）运算符。

> 比较运算中的程序设定

- 所有的数值类型都支持这些运算符。任一操作数是 `NaN` 非数字，比较运算的结果都是 `false`。枚举类型比较仅限于相同枚举类型的操作数。`char` 类型比较对应的字符代码。
- 这些运算符不支持复合运算。
- 类型相等性比较：
  - 引用非记录类型只有在引用同一对象时相等。
  - 记录类型当所有字段对应值和自动实现的属性相等时判定相等性。
  - 字符串具有相等长度且每个字符位置有相同字符时判定相等性。
  - 两个委托类型在其调用列表长度和每个位置具有相同的条目时，二者相等。

```csharp
Console.WriteLine(0xffff < '你');  // False
Console.WriteLine('我' > '你');    // True
Console.WriteLine(float.NegativeInfinity <= 0); // True
Console.WriteLine(float.NaN >= 0); // False
Console.WriteLine('A' == 65);      // True
Console.WriteLine('我' != '你');   // True
```

>---
#### 相等性比较

有时需要比较两个值是否相等。相等性可以测试 “值相等性” 或 “引用相等性”：
  - 值相等性也称为 “等效性”，指两个对象包含相同的一个或多个值。
  - 引用相等性指两个对象引用均引用同一基础对象。

使用 `Object.ReferenceEquals` 方法确定两个引用是否引用同一对象。引用相等性的概念仅适用于引用类型，传递值类型只会传递值的副本给 `ReferenceEquals` 的参数，因此使用该方法比较两个值类型，结果始终返回 `false`。

```csharp
using System;
class Test
{
    public int Num { get; set; }
    public string Str { get; set; }
    static void Main()
    {
        Test a = new Test() { Num = 1, Str = "Hi" };
        Test b = new Test() { Num = 1, Str = "Hi" };

        bool areEqual = System.Object.ReferenceEquals(a, b);
        // False:
        System.Console.WriteLine("ReferenceEquals(a, b) = {0}", areEqual);

        // Assign b to a.
        b = a;

        // Repeat calls with different results.
        areEqual = System.Object.ReferenceEquals(a, b);
        // True:
        System.Console.WriteLine("ReferenceEquals(a, b) = {0}", areEqual);

        // Keep the console open in debug mode.
        Console.WriteLine("Press any key to exit.");
        Console.ReadKey();
    }
}
```

> *值相等性*

针对值相等性的测试，可以使用 `==` 运算符。对记录来说，值相等性是指如果记录类型的两个变量类型相匹配，且所有属性和字段值（或引用对象）都一致，那么记录类型的两个变量是相等的。字符串按值相等性比较。

可以使用 `Object.Equals` 比较两个结构对象的值相等性，对于引用类型则比较引用相等性。 

```csharp
int num1 = 0;
Console.WriteLine(num1 == 0);  // true

Sample s = new() { name = "Hello", num = 1 };
Sample s2 = new() { name = "Hello", num = 1 };
Console.WriteLine(s.Equals(s2));  // true

rSample rs = new("Hi", 1001);
rSample rs1 = new("Hi", 1001);
Console.WriteLine(rs == rs1); // true

string str1 = "Hello";
string str2 = "Hell";
Console.WriteLine(str1 == str2);  // false
str2 += "o";
Console.WriteLine(str1 == str2);  // true

struct Sample
{
    public required int num;
    public required string name;
}
record rSample(string name, int num);
```

> *用户定义类型相等性*

定义类或结构时，需确定为类型创建值相等性（或等效性）的自定义定义是否有意义。通常，预期将类型的对象添加到集合时，或者这些对象主要用于存储一组字段或属性时，需实现值相等性。可以基于类型中所有字段和属性的比较结果来定义值相等性，也可以基于子集进行定义。

类和结构中的等效性实现均应遵循：
  - 自反属性：`x.Equals(x)` 将返回 `true`。
  - 对称属性：`x.Equals(y)` 返回与 `y.Equals(x)` 相同的值。
  - 可传递属性：如果 `(x.Equals(y) && y.Equals(z))` 返回 `true`，则 `x.Equals(z)` 将返回 `true`。
  - 只要未修改 `x` 和 `y` 引用的对象，`x.Equals(y)` 的连续调用就将返回相同的值。
  - 任何非 `null` 值均不等于 `null`。 然而，当 `x` 为 `null` 时，`x.Equals(y)` 将引发异常。

定义的任何结构都已具有其从 `Object.Equals(Object)` 方法的 `System.ValueType` 替代中继承的值相等性的默认实现。此实现使用反射来检查类型中的所有字段和属性。尽管此实现可生成正确的结果，但与专门为类型编写的自定义实现相比，它的速度相对较慢。

如何设计相等性：

- 重写替代 `object.Equals(object)` 方法，大多数情况下，该方法应只调入使用 `System.IEquatable<T>` 接口实现类型的特定 `Equals` 方法。实际的等效性比较将在此接口中执行。
- 对于方法 `System.IEquatable<T>.Equals(T? other)` 应仅检查类中声明的字段。仅当要比较的变量的运行时类型相同时，才应将两个变量视为相等。
- 可选的重载 `==` 和 `!=` 运算符。
- 替代 `Object.GetHashCode`，以便具有值相等性的两个对象生成相同的哈希代码。
- 若要支持 “大于” 或 “小于” 定义，请为类型实现 `IComparable<T>` 接口，并同时重载 `<` 和 `>` 运算符


```csharp
// 类用户定义相等性
Point2D p1 = new Point2D(0, 100);
Point2D p2 = new Point2D(0, 200);
Console.WriteLine(p1 == p2);  // false
p2.Y = 100;
Console.WriteLine(p1 == p2);  // true

class Point2D(int x, int y) : IEquatable<Point2D>
{
    public int X { get; set; } = x;
    public int Y { get; set; } = y;
    public override bool Equals(object? obj) => this.Equals(obj as Point2D);

    public bool Equals(Point2D? other)
    {
        return
            object.ReferenceEquals(other, this)  // 比较引用相等性
            // 比较值相等性
            || other is not null   // 不和 null 比较
            && this.GetType() == other.GetType()  // 运行时类型相等
            && this.X == other.X     // 属性相等性 
            && this.Y == other.Y;
    }
    public override int GetHashCode() => (X, Y).GetHashCode();
    public static bool operator ==(Point2D lhs, Point2D rhs) => lhs?.Equals(rhs) ?? rhs is null;
    public static bool operator !=(Point2D lhs, Point2D rhs) => !(lhs == rhs);
}
```
```csharp
// 结构用户定义相等性
struct Point2D(int x, int y) : IEquatable<Point2D>
{
    public int X { get; private set; } = x;
    public int Y { get; private set; } = y;
    public override bool Equals(object? obj) => obj is Point2D other && this.Equals(other);
    public bool Equals(Point2D p) => X == p.X && Y == p.Y;
    public override int GetHashCode() => (X, Y).GetHashCode();
    public static bool operator ==(Point2D lhs, Point2D rhs) => lhs.Equals(rhs);
    public static bool operator !=(Point2D lhs, Point2D rhs) => !(lhs == rhs);
}
```

> *浮点值的相等性*

由于二进制计算机上的浮点算法不精确，因此浮点值（`double` 和 `float`）的相等比较会出现问题。若要被视为相等，两个 `double` 值必须表示相同的值。

由于值之间的精度差异，或者由于一个或两个值丢失精度，预期相同的浮点值通常不相等，因为它们的最小有效位数存在差异。调用 `Equals` 方法以确定两个值是否相等，或调用 `CompareTo` 方法以确定两个 `double` 值之间的关系，通常会产生意外的结果。

```csharp
double value1 = .333333333333333;
double value2 = 1.0/3;
Console.WriteLine("{0:R} = {1:R}: {2}", value1, value2, value1.Equals(value2));
// The example displays the following output:
//        0.333333333333333 = 0.33333333333333331: False
```

比较浮点值相等性，可以使用 `Math.Round` 方法是两个浮点值具有相同的精度。

```csharp
double value1 = .333333333333333;
double value2 = 1.0 / 3;
int precision = 7;
value1 = Math.Round(value1, precision);
value2 = Math.Round(value2, precision);
Console.WriteLine("{0:R} = {1:R}: {2}", value1, value2, value1.Equals(value2));

// The example displays the following output:
//        0.3333333 = 0.3333333: True
```

另一种方式是测试近似相等性而不是相等性。这要求定义两个值可以相差但仍相等的绝对量，或者定义较小的值与较大值相差的相对量。

```csharp
using System;
public class Example
{
    public static void Main()
    {
        double one1 = .1 * 10;
        double one2 = 0;
        for (int ctr = 1; ctr <= 10; ctr++)
            one2 += .1;

        Console.WriteLine("{0:R} = {1:R}: {2}", one1, one2, one1.Equals(one2));
        Console.WriteLine("{0:R} is approximately equal to {1:R}: {2}",
                          one1, one2,
                          IsApproximatelyEqual(one1, one2, .000000001));
    }
    static bool IsApproximatelyEqual(double value1, double value2, double epsilon)
    {
        if (value1.Equals(value2))
            return true;
        if (Double.IsInfinity(value1) | Double.IsNaN(value1))
            return value1.Equals(value2);
        else if (Double.IsInfinity(value2) | Double.IsNaN(value2))
            return value1.Equals(value2);
        
        // Handle zero to avoid division by zero
        double divisor = Math.Max(value1, value2);
        if (divisor.Equals(0))
            divisor = Math.Min(value1, value2);

        return Math.Abs((value1 - value2) / divisor) <= epsilon;
    }
}
// The example displays the following output:
//       1 = 0.99999999999999989: False
//       1 is approximately equal to 0.99999999999999989: True
```

可以利用浮点格式的设计功能：两个浮点值的整数表示形式之间的差异指示分隔它们的可能浮点值的数量。例如，`0.0` 和 `double.Epsilon` 的二进制格式表示的整数之间的差值为 1。

```csharp
public class Example
{
    public static void Main()
    {
        Console.WriteLine($"{Convert.ToString(BitConverter.DoubleToInt64Bits(double.Epsilon), 2)}".PadLeft(64, '0'));
        // '0'*63 + '1' = 1L, Epsilon 与 0.0 的二进制表示的整数仅相差 1

        double value1 = .1 * 10;
        double value2 = 0;
        for (int ctr = 0; ctr < 10; ctr++)
            value2 += .1;

        Console.WriteLine("{0:R} = {1:R}: {2}", value1, value2,
                          HasMinimalDifference(value1, value2, 1));
    }
    public static bool HasMinimalDifference(double value1, double value2, int units = 1)
    {
        long lValue1 = BitConverter.DoubleToInt64Bits(value1);
        long lValue2 = BitConverter.DoubleToInt64Bits(value2);

        // 非零时符号位不同则返回 false, 此时要比较 +0 and -0.
        if ((lValue1 >> 63) != (lValue2 >> 63))
            return value1 == value2;  // 比较 +0.0 与 -0.0, true

        long diff = Math.Abs(lValue1 - lValue2);
        // 比较浮点二进制代表的整数的差值
        return diff <= (long)units;
    }
}
// The example displays the following output:
//     1 = 0.9999999999999999: True   
```

`Double.Epsilon` 在测试相等性时，有时用作两 `Double` 个值之间距离的绝对度量值。但是，`Double.Epsilon` 测量的是值为零的 `Double` 对象可以加或减的最小可能值。对于大多数正值和负 `Double` 值，`Double.Epsilon` 的值太小，无法被检测到。因此，除零值外，不建议在相等性测试中使用它。

```csharp
static bool ZeroEquals(double val)
{
    return Math.Abs(val - 0.0) < double.Epsilon;
}
```

> *为 ref 变量创建引用相等性比较* 

对两个 `ref` 变量使用 `==` 或 `!=`，对于值类型则比较值相等性，对于引用类型则比较引用相等性。若要检查两个 `ref` 值类型是否引用同一个对象，则比较它们的地址值。

```csharp
int number = 0;
int number2 = number;

ref int n1 = ref number;
ref int n2 = ref number2;

Console.WriteLine(n1 == n2);  // true
Console.WriteLine(n1.refsEquals(ref n2));  // false
n2 = ref number;
Console.WriteLine(n1.refsEquals(ref n2));  // true
n2 = ref n1;
Console.WriteLine(n1.refsEquals(ref n2));  // true

public static class ObjectExt
{
    public unsafe static bool refsEquals<T>(this scoped ref T obj, scoped ref T other) where T : struct
    {
        fixed (T* reft1 = &obj, reft2 = &other)
            return reft1 == reft2;
    }
    public unsafe static bool refsEquals<T>(this scoped ref T? obj, scoped ref T? other) where T : struct
    {
        fixed (T?* reft1 = &obj, reft2 = &other)
            return reft1 == reft2;
    }
}
```

---
#### is

`is` 运算有两种形式，一种是类型测试（右侧是一个类型），一种模式匹配（右侧是一个模式）。

`is` 类型测试运算用于检查对象的运行时类型是否与给定的类型兼容。`E is T` 表达式中，`E` 表示一个表达式，`T` 是一个非动态类型，结果为一个布尔值。`is` 测试 `E` 是否为空，是否可以通过引用转换、装箱转换、拆箱转换、包装转换、拆包转换为类型 `T`。

测试的表达式 `E` 不能是方法组、匿名方法、lambda 表达式。`is` 运算符不会考虑用户定义的转换。

```csharp
object b = new Base();
Console.WriteLine(b is Base);  // output: True
Console.WriteLine(b is Derived);  // output: False

object d = new Derived();
Console.WriteLine(d is Base);  // output: True
Console.WriteLine(d is Derived); // output: True

class Base;
class Derived : Base;
```

检查 null 值：

```csharp
using System.Diagnostics;
object obj = null;

// 相等性测试
Trace.Assert(obj == null);
// ReferenceEquals
Trace.Assert(object.ReferenceEquals(obj, null));
// is 表达式
Trace.Assert(obj is null);
Trace.Assert(obj is not object);
Trace.Assert(obj is not { });
```

>---

#### as

`as` 运算符用于显式地将值转换为给定的引用类型或可空值类型。与强制转换表达式不同，`as` 运算符永远不会抛出异常。若指定的转换不可能，则结果值为 `null`。

`as` 运算符将 `E as T` 表达式中，`T` 不能是不可为 null 的值类型。若 `E` 不是动态类型，`E as T` 等效于 `E is T ? (T)(E) : (T)null`。如果 `E` 在编译时是动态的，`as` 运算符不是动态绑定的，因此 `E as T` 等效于 `E is T ? (T)(object)(E) : (T)null`

```csharp
IEnumerable<int> numbers = new[] { 10, 20, 30 };
IList<int> indexable = numbers as IList<int>;
if (indexable != null)
    Console.WriteLine(indexable[0] + indexable[indexable.Count - 1]);  // output: 40
```

`as` 运算符的操作数是类型参数时，它不能是无约束的，应使用强制转换表达式执行。

```csharp
class Sample
{
    public string F(object o)
        => o as string;  // OK, string is a reference type

    public T G<T>(object o) where T : Attribute
        => o as T;       // Ok, T has a class constraint

    public U H<U>(object o)
        => o as U;       // Error, U is unconstrained
}
```

>---
#### 逻辑运算与条件逻辑运算

一元 `!`（逻辑非）运算符。

二元 `&`（逻辑与）、`|`（逻辑或）和 `^`（逻辑异或）运算符，这些运算符始终计算两个操作数。

二元 `&&`（条件逻辑与）和 `||`（条件逻辑或）运算符，这些运算符仅在必要时才计算右侧操作数。

> 逻辑运算中的程序设定

- 对于 `bool?` 操作数：
  - `true & true = true`，`false & false/null/true = false`，`null & null/true = null`。
  - `false | false = false`，`true | false/null/true = true`，`null | null/false = null`。
  - `!null = null`，`null ^ null/false/true = null`。 
  - 条件逻辑运算符 `&&` 和 `||` 不支持 `bool?` 操作数。

- 优先级：`!` > `&` > `^` > `|` > `&&` > `||`。
- 复合运算：二元 `&=`、`|=`、`^=`。


```csharp
class Sample
{
    static bool SecondOperand(string @operator, bool? first = null)
    {
        Console.Write($"{(first.HasValue ? first.Value.ToString() : ""), 5} {@operator,2} Second operand is evaluated >> result = ");
        return true;
    }
    static void Main()
    {
        // 逻辑运算
        Console.WriteLine(!SecondOperand("!"));
        Console.WriteLine(true & SecondOperand("&", true));
        Console.WriteLine(false & SecondOperand("&", false));
        Console.WriteLine(true ^ SecondOperand("^",true));
        Console.WriteLine(false ^ SecondOperand("^",false));
        Console.WriteLine(true | SecondOperand("|", true));
        Console.WriteLine(false | SecondOperand("|",false));

        // 条件逻辑运算
        Console.WriteLine(true && SecondOperand("&&", true));
        Console.WriteLine(false && SecondOperand("&&",false));
        Console.WriteLine(true || SecondOperand("||", true));
        Console.WriteLine(false || SecondOperand("||", false));

        // 复合运算
        bool boo = true;
        Console.WriteLine(boo &= SecondOperand("&=", boo));
        Console.WriteLine(boo ^= SecondOperand("^=", boo));
        Console.WriteLine(boo |= SecondOperand("|=", boo));
    }
}
/*
       ! Second operand is evaluated >> result = False
 True  & Second operand is evaluated >> result = True
False  & Second operand is evaluated >> result = False
 True  ^ Second operand is evaluated >> result = False
False  ^ Second operand is evaluated >> result = True
 True  | Second operand is evaluated >> result = True
False  | Second operand is evaluated >> result = True

 True && Second operand is evaluated >> result = True
False
True
False || Second operand is evaluated >> result = True

 True &= Second operand is evaluated >> result = True
 True ^= Second operand is evaluated >> result = False
False |= Second operand is evaluated >> result = True
 */
```

>---

#### 用户定义条件逻辑运算符

若用户定义类型已包含 `|`（或 `&`）运算符重载，可以定义 `true` 和 `false` 的运算符重载以支持该类型执行条件逻辑运算 `||`（或 `&&`），唯一的要求是 `true` 和 `false` 运算符的操作数和返回类型都是其包含类型 `T`。

```csharp
public struct LaunchStatus(int status)
{
    public static readonly LaunchStatus Green = new LaunchStatus(0);
    public static readonly LaunchStatus Yellow = new LaunchStatus(1);
    public static readonly LaunchStatus Red = new LaunchStatus(2);
    private int Status = status;

    public static bool operator false(LaunchStatus x) => x == Red;
    public static bool operator true(LaunchStatus x) => x == Green || x == Yellow;

    public static LaunchStatus operator &(LaunchStatus x, LaunchStatus y)
    {
        if (x == Red || y == Red || (x == Yellow && y == Yellow))
            return Red;
        if (x == Yellow || y == Yellow)
            return Yellow;
        return Green;
    }
    public static bool operator ==(LaunchStatus x, LaunchStatus y) => x.Status == y.Status;
    public static bool operator !=(LaunchStatus x, LaunchStatus y) => !(x == y);
    public override bool Equals(object obj) => obj is LaunchStatus other && this == other;
    public override int GetHashCode() => status;
}
public class LaunchStatusTest
{
    public static void Main()
    {
        LaunchStatus okToLaunch = GetFuelLaunchStatus() && GetNavigationLaunchStatus();
        Console.WriteLine(okToLaunch ? "Ready to go!" : "Wait!");
    }
    /* output:
        Getting fuel launch status...
        Wait!
    */

    static LaunchStatus GetFuelLaunchStatus()
    {
        Console.WriteLine("Getting fuel launch status...");
        return LaunchStatus.Red;
    }
    static LaunchStatus GetNavigationLaunchStatus()
    {
        Console.WriteLine("Getting navigation launch status...");
        return LaunchStatus.Yellow;
    }
}
```

>---
#### 条件运算符

条件运算符 `? :` 也称为三元条件运算符，用于计算布尔表达式 `condition ? consequent : alternative`，并根据布尔表达式的计算结果为 `true` 还是 `false` 来返回两个表达式中的一个结果。

`consequent` 和 `alternative` 的类型必须可隐式转换为目标类型。

```csharp
var rand = new Random();
var condition = rand.NextDouble() > 0.5;

var x = condition ? 12 : (int?)null;
```

> *ref* *条件表达式*

条件 `ref` 表达式可有条件地返回变量引用：`condition ? ref consequent : ref alternative`。在 `ref` 条件表达式中，`consequent` 和 `alternative` 的类型必须相同。

可以使用 `ref` 分配条件 `ref` 表达式的结果，将其用作引用返回，或将其作为 `ref`、`out` 或 `in` 方法参数传递。

```csharp
var smallArray = new int[] { 1, 2, 3, 4, 5 };
var largeArray = new int[] { 10, 20, 30, 40, 50 };

int index = 7;
ref int refValue = ref ((index < 5) ? ref smallArray[index] : ref largeArray[index - 5]);
refValue = 0;

index = 2;
((index < 5) ? ref smallArray[index] : ref largeArray[index - 5]) = 100;

Console.WriteLine(string.Join(" ", smallArray));
Console.WriteLine(string.Join(" ", largeArray));
// Output:
// 1 2 100 4 5
// 10 20 0 40 50
```

>---
#### 位运算和移位运算

一元 `~`（按位求补）运算符。

二进制 `&`（按位与）、`|`（按位或）和 `^`（按位异或）运算符。

二进制 `<<`（左移）、`>>`（右移）和 `>>>`（无符号右移）运算符。

> 位运算和移位运算中的程序设定

- 这些运算符是针对 `int`、`uint`、`long` 和 `ulong` 类型定义的。位运算和移位运算永远不会导致溢出。
- 左移运算会放弃超出结果类型范围的高阶位，并将低阶空位位置设置为零；右移位运算会放弃低阶位，其中有符号数高位用 1 补齐，无符号数用 0 补齐；`>>>` 运算符始终执行逻辑移位，高位始终用 0 补齐。
- `~1010 = 0101`，`1010 & 1100 = 1000`，`1010 | 1100 = 1110`，`1010 ^ 1100 = 0110`。 
- 优先级：`~` > `<<`、`>>`、`>>>` > `&` > `^` > `|`。
- 复合运算：二元 `&=`、`^=`、`|=`、`<<=`、`>>=`、`>>>=`。

> 移位运算中的移位计数

- 对于 `<<`、`>>`、`>>>` 运算符的右操作数必须是 `int` 类型，对于 `x << count`、`x >> count` 和 `x >>> count` 表达式，实际移位计数取决于 `x` 的类型：
  - 若 `x` 为 `int` 或 `uint` 则移位计数由右侧操作数的低阶五位定义，即 `count & 0x1F` 或 `count & 0b_1_1111`。
  - 若 `x` 为 `long` 或 `ulong` 则移位计数由右侧操作数的低阶六位定义，即 `count & 0x3F` 或 `count & 0b_11_1111`。

```csharp
uint a = 0b_0000_1111_0000_1111_0000_1111_0000_1100u;
uint b = 0b_1010_0101_1100_0011_0000_1111_1010_0101u;
int c = -0b_1011_0101_1010;

// 位运算
ToString(~a, "~", a);
ToString(a & b, "&", b, a);
ToString(a | b, "|", b, a);
ToString(a ^ b, "^", b, a);

// 按位运算
ToString(a << 6, "<<", 6, a, false);
ToString(a >> 6, ">>", 6, a, false);
ToString(c << 6, "<<", 6, c, false);
ToString(c >> 6, ">>", 6, c, false);
ToString(b >>> 10, ">>>", 10, b, false);
ToString(c >>> 10, ">>>", 10, c, false);

static void ToString(long value, string @operator, long rhs, long? lhs = null, bool rbase2 = true)
    => Console.WriteLine(
        $"\n{(lhs.HasValue ? lhs.Value.toString() : ""),+36}" +
              $"\n{@operator,-4}{rhs.toString(rbase2),32}\n  " +
              $"= {value.toString(),32}");
static class Ext
{
    public static string toString(this long val, bool base2 = true) => Convert.ToString((int)val, toBase: base2 ? 2 : 10);
}
```

>---
#### 指针相关运算

- 一元 `&` 地址运算符，用于获取变量的地址。
- 一元 `*` 间接运算符，用于获取指针指向的变量。
- `->` 指针成员访问和 `[]` 元素访问运算符。
- 指针算术运算：`+`、`-`、`++` 和 `--`。
- 指针比较运算：`==`、`!=`、`<`、`>`、`<=` 和 `>=`。

> 指针相关运算符的程序设定

- `&` 的操作数必须是固定变量（固定变量是驻留在不受垃圾回收器操作影响的存储位置的变量）。驻留在可能受垃圾回收器影响的存储位置的变量（如重定位）称为可移动变量，对象字段和数组元素是可移动变量的示例，使用 `fixed` 语句 “固定”，则可以获取可移动变量的地址。无法获取常量或值的地址。
- `*` 获取其操作数指向的变量，它也称为取消引用运算符。`*` 运算符的操作数必须是指针类型，不能将 `*` 运算符应用于类型 `void*` 的表达式。
- `->` 指针成员访问合并间接 `*` 和成员访问 `.`，即 `X->y` 等价于 `(*X).y`。
- 对于指针类型 `T*` 的表达式 `ptr`，`ptr[n]` 形式的指针元素访问计算方式为 `*(ptr + n)`，等价于 `*(T*)((IntPtr)ptr + n * sizeof(T))`。参考指针算数。

> 指针算数

- 向指针 `p` 增加或从指针中减少整数值 `n`，表示将 `p` 的地址添加或减去 `n*sizeof(T)`。增量减量运算表示指针自增或自减 1 个 `sizeof(T)`。
- 比较运算用于比较两个指针操作数给出的地址。

```csharp
unsafe
{
    int[] arr = { 0, 1, 2, 3, 4, 5, 6 };
    fixed (int* ptr = arr)
    {
        nint I_ptr = (nint)ptr;
        nint I_ptr_2 = I_ptr + 2 * sizeof(int);****
        if (I_ptr_2 == (nint)(&ptr[2]))
            Console.WriteLine(I_ptr_2);     // could be: 2775296852288

        int* _Ptr = ptr;
        Console.WriteLine(*_Ptr);               // 0
        Console.WriteLine(*++_Ptr);             // 1

        Console.WriteLine(*(ptr + 2));          // 2
        Console.WriteLine(ptr[2]);              // 2

        Console.WriteLine(_Ptr >= ptr);         // True
        Console.WriteLine(--_Ptr == ptr);       // True
    }
}
```

---
### 类型转换

转换使表达式被转换为或被视为属于特定类型。转换可能涉及表示的变化，转换可以是隐式转换或显式强制转换。一些转换是语言定义的，用户可以自定义类型转换。

```csharp
int a = 123;
long b = a;      // implicit
int c = (int)b;  // explicit
```

>---
#### 隐式转换

隐式转换可能会在多种情况下发生，包括函数成员调用、强制转换表达式、赋值运算等。预定义的隐式转换始终会成功，并且不会引发异常。

> *隐式恒等转换*

恒等转换将任意类型转换为相同类型，即类型 `T` 或类型 `T` 的表达式可转换为 `T` 本身：
- `dynamic` 和 `object` 之间存在恒等转换。
- 在相同泛型构造的类型之间，如果每个对应类型参数之间存在恒等转换，构造实例之间存在恒等转换。
- 具有相同密度的元组类型之间，如果每对对应元素类型之间存在恒等转换时，元组之间存在恒等转换。

> *隐式数值转换*

当某一数值类型 `T` 的值域在目标类型 `U` 的可表示值域范围内，则 `T` 可以隐式转换为 `U`，例如：
- 从 `byte`、`sbyte` 到 `short`、`int`、`nint`、`long`、`float`、`double`、`decimal`。
- 从 `byte` 到 `ushort`、`uint`、`nuint`、`ulong`。
- 从 `short`、`ushort` 到 `int`、`nint`、`long`、`float`、`double`、`decimal`。
- 从 `ushort` 到 `uint`、`nuint`、`ulong`。
- 从 `int`、`uint` 到 `nint`、`long`、`float`、`double`、`decimal`。
- 从 `uint` 到 `nuint`、`ulong`。
- 从 `nint` 到 `long`、`float`、`double`、`decimal`。
- 从 `nuint` 到 `ulong`、`float`、`double`、`decimal`。
- 从 `long`、`ulong` 到 `float`、`double`、`decimal`。
- 从 `char` 到 `ushort`、`short`、`uint`、`int`、`nint`、`nuint`、`ulong`、`long`、`float`、`double`、`decimal`。
- 从 `float` 到 `double`。

从整型到浮点数的转换可能会导致精度损失，但是不会导致范围损失。

> *隐式枚举转换*

隐式枚举转换允许将任意整数类型的 `0` 值常量转换为任意枚举类型和任何可空枚举类型。其他的整数类型数值需要强制转换运算。

```csharp
TaskStatus status0 = 0;
TaskStatus status = (TaskStatus)5;
```

> *隐式内插字符串转换*

隐式内插字符串转换允许将内插字符串转换为 `System.IFormattable` 或 `System.FormattableString`。

> *隐式可空转换*

对于非空值类型的预定义隐式转换，也可以用于这些类型的可空值类型。非空值类型 `T` 到其可空类型 `T?` 之间存在隐式转换。

基于从 `S` 到 `T` 的底层转换的可空转换求值过程：
- 对于 `S?` 到 `T?` 的转换，若 `S?` 的值为空，则结果为 `T?` 的空值；否则转换将作为从 `S?` 展开为 `S` 后，再从 `S` 到 `T`，再从 `T` 包装为 `T?`。
- 对于 `S` 到 `T?` 的转换，先从 `S` 到 `T`，再从 `T` 包装到 `T?`。

```csharp
int num = 10;
long lnum = num;    // S to T
long? nlnum = num;  // S to T?

int? n_num = num;
long? n_lnum = n_num;  // S? to T?
```

> *null 的转换*

存在从 `null` 字面值到任何引用类型或可空值类型的隐式转换。对于引用类型转换为空引用，对于可空值类型则生成空值。

> *隐式引用转换*

隐式引用转换是指那些可以证明总是成功的引用类型之间的转换，在运行时不需要检查。隐式引用转换有：
- 从任意引用类型到 `object` 和 `dynamic` 的转换。
- 从任意类类型 `S` 到其基类 `T`、基接口 `I` 的转换。
- 从任意接口类型 `I` 到其基接口的 `Ibase` 的转换。
- 元素类型为 `Se` 的数组 `S` 到元素类型为 `Te` 的数组 `T` 存在隐式转换需要满足：
  - 数组 `S` 和 `T` 具有相同的维度。
  - `Se` 和 `Te` 都是引用类型，且 `Se` 到 `Te` 存在隐式转换。  
- 从任何数组类型到 `System.Array` 以及它实现的接口类型的转换。
- 从任意一维数组类型 `S[]` 到 `System.Collections.Generic.IList<T>` 及其基接口的隐式转换，需满足 `S` 到 `T` 存在隐式恒等转换或隐式引用转换。 
- 从任意委托类型到 `Delegate` 和它实现的接口的转换。
- 从 null 值到任意引用类型。
- 从任意引用类型 `S` 到引用类型 `T` 的隐式转换，需满足从 `S` 到 `T` 存在隐式恒等转换或隐式引用转换。
- 从任意引用类型 `S` 到接口或委托类型 `T` 的隐式转换，需满足 `S` 到 `T` 存在隐式恒等转换或隐式引用转换，且 `S` 可以协变转换到 `T`。
- 涉及任何引用类型的类型参数的隐式转换。
 
引用转换永远不会改变被转换对象的引用标识。虽然引用转换可以更改引用的类型，但它不会更改引用对象的类型或值。

> *装箱转换*

装箱转换允许将值类型隐式转换为引用类型，装箱转换有：
- 从任意值类型到 `object`、`System.ValueType` 的转换。
- 从任意枚举类型到 `System.Enum` 的转换。
- 从任意非空值类型到其实现的接口的转换。
- 从任意非空值类型到任意接口 `I` 的隐式转换，需满足非空值类型可装箱转换的另一个接口 `I0` 到 `I` 之间存在恒等转换或协变转换。
- 从任意可空类型到任意引用类型的转换，其中存在可空类型的基础类型到该引用类型的装箱转换。

将非空值类型的值装箱包括分配一个对象实例并将值复制到该实例中。若可空值类型的值是空值，则其装箱为空引用，否则将展开底层值并生成该值装箱的引用。

> *隐式动态转换*

存在从动态类型表达式到任意类型 `T` 的隐式动态转换，该转换是动态绑定的，这意味着将在运行时寻求从表达式的运行时类型到 `T` 的隐式转换，若无法成功转换，则抛出运行时异常。

```csharp
object o  = "object"
dynamic d = "dynamic";

string s1 = o;  // Fails at compile-time -- no conversion exists
string s2 = d;  // Compiles and succeeds at run-time
int i     = d;  // Compiles but fails at run-time -- no conversion exists
```

> *隐式常量表达式转换*

隐式常量表达式的转换允许：
- `int` 类型的常量表达式可以转换为 `sbyte`、`byte`、`short`、`ushort`、`uint`、`nint`、`nuint`、`ulong` 类型，前提是该常量值在目标类型的范围内。
- `long` 类型的常量表达式可以转换为 `ulong` 类型，前提是非负值。

> *涉及类型参数的隐式转换*

给定的类型参数 `T` 存在以下隐式转换： 

- 对于已知为引用类型的类型参数 `T`，允许从 `T` 到其任意基类 `C`、从由 `T` 到 `C` 实现的任何接口 `I` 和 `I` 的任意基接口的隐式引用转换。
  
- 若 `T` 不知是否为引用类型时，涉及 `T` 到任意基类或基接口的转换在编译时被认为是装箱转换。在运行时，如果 `T` 是值类型，则转换为装箱转换执行，否则转换作为隐式转换或恒等转换执行。

- 从 `T` 到类型参数 `U` 的转换，具体取决于 `U` 的类型参数约束。若 `U` 是值类型，则 `T` 到 `U` 的类型必须相同，且不执行任何转换；若 `T` 是值类型，则转换将作为装箱转换；否则将作为隐式引用转换或恒等转换。

- 从 `null` 到引用类型的类型参数 `T`。 

> *隐式元组转换*

如果元组表达式 `E` 与元组类型 `T` 具有相同的密度，且存在从 `E` 中的每个元素到 `T` 中相应元素类型的隐式转换，则存在 `E` 到 `T` 的隐式转换。转换通过创建 `System.ValueTuple<...>` 类型，并从左到右的顺序初始化它的每个字段。

如果元组表达式中的元素名与元组类型中相应的元素名不匹配，则发出警告，表达式的元素名称将被忽略。

```csharp
(int, string) t1 = (1, "One");
(byte, string) t2 = (2, null);
(int, string) t3 = (null, null);        // Error: No conversion
(int i, string s) t4 = (i: 4, "Four");
(int i, string) t5 = (x: 5, s: "Five"); // Warning: Names are ignored
```

> *用户定义的隐式转换*

用户定义的隐式转换包括由从一个可选的标准隐式转换，到执行用户定义的隐式转换运算符，再到执行另一个可选的标准隐式转换。

> *匿名函数转换和方法组转换*

匿名函数和方法组本身没有类型，它们可以隐式地转换为委托类型。一些 Lambda 表达式可以隐式转换为表达式树类型。

> *default 转换*

存在从 `default` 到任何类型的隐式转换，此转换将生成推断类型的默认值。

> *隐式抛出转换*

`throw` 表达式没有类型，但是它们可以隐式转换为任何类型。

>---
#### 显式转换

显式转换可在强制转换表达式（`(type)value`）中发生。显式转换集包含所有的隐式转换，即隐式转换可以显式使用强制转换表达式。

```csharp
int num = 123;
object obj = (object)num;  // 隐式转换

int num2 = (int)obj;       // 显式强制转换
```

不是隐式转换的显式转换是指不能证明总是成功的转换、已知可能丢失信息的转换以及跨类型域的转换，这些转换差异很大，必须显式标记。显式转换可能会存在无效的强制转换。

> *显式数字转换*

- 从 `sbyte` 到 `byte`、`ushort`、`uint`、`ulong`、`char`。
- 从 `byte` 到 `sbyte`、`char`.
- 从 `short` 到 `sbyte`、`byte`、`ushort`、`uint`、`ulong`、`char`
- 从 `ushort` 到 `sbyte`、`byte`、`short`、`char`
- 从 `int` 到 `sbyte`、`byte`、`short`、`ushort`、`uint`、`ulong`、`char`。
- 从 `uint` 到 `sbyte`、`byte`、`short`、`ushort`、`int`、`char`。
- 从 `nint` 到 `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`nuint`、`ulong`、`char`。
- 从 `nuint` 到 `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`nint`、`long`、`char`。
- 从 `long` 到 `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`ulong`、`char`。
- 从 `ulong` 到 `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`char`。
- 从 `char` 到 `sbyte`、`byte`、`short`。
- 从 `float` 到 `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`char`、`decimal`。
- 从 `double` 到 `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`char`、`float`、`decimal`。
- 从 `decimal` 到 `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`char`、`float`、`double`。

由于显式转换可能会丢失信息，或可能导致引发异常。对于显式数值转换：
- 在 `checked` 的上下文，源操作数在目标类型范围内则转换成功，否则将引发 `System.OverflowException` 异常。
- 在 `unchecked` 的上下文，始终转换成功。对于溢出的源类型将放弃额外的高位来截断源值，而小的源值则是符号扩展（有符号数）或零扩展（无符号数）高位。
- 对于从 `decimal` 到整数类型的转换，源值向零舍入到最接近的整数值。超出范围时引发 `Overflow` 异常。
- 对于 `float`、`double` 到整数类型的转换，在检查的上下文中，超出范围会引发溢出异常；未检查的上下文中向零舍入到最接近的整数值，不在范围的浮点值将是目标类型的未指定值。
- 对于 `double` 转换为 `float`，将值舍入到最接近的 `float` 值。若太小则结果是正零或负零，太大则是正无穷或负无穷。
- 对于 `float`、`double` 到 `decimal` 的转换，将源值转换为 `decimal` 格式，并将第 28 位小数后舍入到最接近的数。若太小时结果为零，若是 `nan`、无穷大或值太大而无法表示为 `decimal` 时，将引发溢出异常。
- 对于从 `decimal` 到浮点类型的转换，将源值舍入到最接近的目标类型值。这种转换可能会丢失精度，但不会引发异常。

> *显式枚举转换*

显式枚举转换包括从任意数值类型到枚举类型的显式转换，从任意枚举类型到任意数值类型的转换，或任意枚举类型之间的转换。

整数类型的 0 值可以隐式转换为枚举类型。

> *显式可空转换*

对于非空值类型的预定义显式转换，也可以用于这些类型的可空值类型。非空值类型 `T?` 到其可空类型 `T` 之间存在式转换。

基于从 `S` 到 `T` 的底层显式转换的可空显式转换求值过程：
- 对于 `S?` 到 `T?` 的转换，若 `S?` 的值为空，则结果为 `T?` 的空值；否则转换将作为从 `S?` 展开为 `S` 后，再从 `S` 到 `T`，再从 `T` 包装为 `T?`。
- 对于 `S` 到 `T?` 的转换，先从 `S` 到 `T`，再从 `T` 包装到 `T?`。
- 对于 `S?` 到 `T` 的转换，先是 `S?` 展开到 `S`，再从 `S` 到 `T` 的基本转换。

```csharp
long lnum = 10;    
int num = (int)lnum;  // (T)S to T
int? nnum = (int?)lnum;  // (T?)S to T?

long? l_num = lnum;   // T to T?
int? n_num = (int?)l_num;  // (T?)S? to T?
```

> *显式引用转换*

显式引用转换是需要运行时检查以确保它们正确的引用类型之间的转换。如果显式引用转换失败，将引发 `System.InvalidCastException` 异常。

若要在运行时成功进行显式引用转换，源操作数的值必须为 `null`，或者源操作数引用的对象的实际类型必须是可通过隐式引用转换转换为目标类型的类型或装箱转换。

```csharp
object obj = "Hello";
string str = (string)obj;

obj = 123;
str = (string)obj;  // err : 源类型的运行时类型 int 无法隐式转换为 string
```

> *显式元组转换*

如果元组表达式 `E` 与元组类型 `T` 具有相同的密度，且存在从 `E` 中的每个元素到 `T` 中相应元素类型的显式转换，则存在 `E` 到 `T` 的显式转换。转换通过创建 `System.ValueTuple<...>` 类型，并从左到右的顺序初始化它的每个字段，并对每一个元素应用显式转换。

如果元组表达式中的元素名与元组类型中相应的元素名不匹配，则发出警告，表达式的元素名称将被忽略。

```csharp
(int, string) t1 = (ValueTuple<int, string>)(1L, "One");
(byte, string) t2 = (ValueTuple<byte, string>)(2L, null);
(int, string) t3 = (ValueTuple<int, string>)(null, null);        // Error: No conversion
(int i, string s) t4 = (ValueTuple<int, string>)(d: 3.1415, "Four"); // Warning: Names are ignored
```

> *拆箱转换*

拆箱转换允许将引用类型显式转换为值类型。拆箱转换操作包括：首先检查对象实例是否是给定值类型的装箱值，然后将该值从实例中复制出来。拆箱到可空值类型时，空引用生成为可空值类型的 `null` 值。拆箱空引用将引发 `System.NullReferenceException`

前提是引用类型是包含目标类型的装箱类型或兼容类型，否则将引发 `System.InvalidCastException` 异常。

> *显式动态转换*

存在从 `dynamic` 到任何类型的 `T` 的显式动态转换，转换是动态绑定的，这意味着将在运行时检查表达式的运行时类型是否与目标类型存在显式转换。不存在任何转换时将产生异常。

> *涉及类型参数的显式转换*

给定的类型参数 `T` 存在以下显式转换： 

- 对于已知为引用类型的类型参数 `T`，允许从 `T` 的任意有效基类 `C` 到 `T`、或任意接口到 `T` 的显式引用转换。
  
- 若 `T` 不知是否为引用类型时，涉及任意基类或基接口到 `T` 的转换在编译时被认为是拆箱转换。在运行时，如果 `T` 是值类型，则转换为拆箱转换执行，否则转换作为显式引用转换或恒等转换执行。

- 从 `U` 到类型参数 `T` 的转换，前提是 `T` 依赖于 `U`。在运行时，若 `T`、`U` 都是值类型，则 `T` 和 `U` 的类型必须相同，且不执行任何转换；若 `T` 是值类型，`U` 是引用类型，则转换将作为拆箱转换；否则 `T`、`U` 都是引用类型且转换将作为显式引用转换或恒等转换。

- 不允许从无约束的类型参数直接显式转换为非接口类型。此目的是为了防止语义混淆。

```csharp
//var a = Sample<int>.Fun(15);  // err
var a2 = Sample<long>.Fun(15);  // ok

class Sample<T>
{
    public static long Fun(T t)
    {
        // return (long)t;  // err
        return (long)(object)t;  // t 必须是 long
    }
}
```

> *用户定义的显式转换*

用户定义的显式转换包括先可选的标准显式转换，然后执行用户定义的隐式或显式转换操作符，最后是另一个可选的标准显式转换。

>---

#### 用户定义转换

用户定义的转换将源表达式转换为另一种类型。用户定义转换的求值以查找源表达式或目标类型的最特定的用户定义转换运算符为核心。当确定了最特定的用户定义转换运算符，则用户定义的转换最多执行：
- （可选）首先，执行从源表达式到用户定义或提升的转换运算的操作数类型的标准转换。
- 接下来，调用用户定义或提升的转换运算符来执行转换。
- （可选）最后，执行从用户定义转换的结果类型到目标类型的标准转换。

标准转换指的是非用户定义的其他隐式或显式转换。用户定义的转换求值从不涉及多个用户定义或提升的转换运算符。也就是说，从类型 `S` 到 `T`，不会涉及先从 `S` 到 `X`，然后从 `X` 到 `T` 的转换。

使用关键字 `implicit`（隐式）和 `explicit`（显式）声明用户定义转换。定义转换的类型必须是该转换的源类型或目标类型。其中一个操作数必须是源类型。

```csharp
var p = (Point)(10, 1);
(double x, double y) P = new Point(1, 10);

class Point(double x, double y)
{
    public double X => x;
    public double Y => y;

    // 从 Point 到元组的隐式转换
    public static implicit operator (double x, double y)(Point p) => (p.X, p.Y);
    // 从 元组 到 Point 的显式转换
    public static explicit operator Point((double x, double y) p) => new Point(p.x, p.y);
}
```

>---
#### 匿名方法的转换

匿名方法表达式（`delegate`）和 Lambda 表达式或语句被归类为匿名方法。匿名方法没有类型，但可以隐式地转换为兼容的委托类型。一些 Lambda 表达式也可以转换为兼容的表达式树类型。

匿名方法 `F` 和委托类型 `D` 兼容，则：
- 若 `F` 包含一个匿名方法签名，则 `D` 和 `F` 具有相同数目的参数和返回类型。

```csharp
Action<int, string> dele = delegate (int x, string y) { };
Action<int, string> dele2 = delegate (long x, string y) { }; // err 签名不一致
```

- 若 `F` 不包含方法签名，则 `D` 可以有零到多个任意类型的参数，只要没有 `out` 修饰符。

```csharp
Action<int, string> dele = delegate { };
Action dele2 = delegate { };    // err : 委托参数中包含 out 参数

delegate void Action(out int val);
```

- 若 `F` 具有显式类型化的参数列表，则 `D` 的每个参数与 `F` 中相应的参数具有相同的类型和修饰符。

```csharp
Action dele2 = delegate (out int x, string str, ref float y) { x = 10; };   
delegate void Action(out int val, string str, ref float f);
```

- 若 `F` 具有隐式类型化的参数列表，则 `D` 中没有 `ref`、`in`、`out` 参数。

```csharp
Action dele = (x, str) => { x = str.Length; };
delegate void Action(int val, string str);
```

> *匿名方法转换到委托类型的求值*

将匿名函数转换为委托类型会生成一个委托实例，该实例引用匿名函数并可能在转换时捕获处于活动状态的外部变量集（可能为空）。当调用委托时，将执行匿名函数体。主体中的代码使用委托引用捕获的外部变量集执行。

从匿名函数生成的委托的调用列表包含单个条目，其中委托的确切目标对象和目标方法未指定。特别是，委托的目标对象是空、封闭函数成员的 `this` 值还是其他对象都没有指定。

将语义相同的匿名函数与捕获的相同（可能为空的）外部变量实例集转换为相同的委托类型，允许（但不是必需）返回相同的委托实例。相同是指在所有情况下，在给定相同参数的情况下，匿名函数的执行将产生相同的效果。

```csharp
delegate double Function(double x);

class Test
{
    static double[] Apply(double[] a, Function f)
    {
        double[] result = new double[a.Length];
        for (int i = 0; i < a.Length; i++)
            result[i] = f(a[i]);
        return result;
    }

    static void F(double[] a, double[] b)
    {
        a = Apply(a, (double x) => Math.Sin(x));
        b = Apply(b, (double y) => Math.Sin(y));
        // 由于两个匿名函数委托具有捕获的外部变量的相同集，并且由于匿名函数在语
        // 义上是相同的，因此编译器允许委托引用相同的目标方法。实际上，允许编译
        // 器从两个匿名函数表达式返回完全相同的委托实例。
    }
}
```
 
> *Lambda 表达式转换到表达式树类型的求值*

将 Lambda 表达式转换为表达式树类型会生成表达式树类型，即 Lambda 表达式转换的结果产生一个表示 Lambda 表达式本身结构的对象结构。

并非每个 Lambda 表达式都可以转换为表达式树类型。始终存在到兼容委托类型的转换，但由于特定于实现的原因，它可能在编译时失败。常见的原因包括：
- Lambda 包含一个语句块。
- Lambda 是异步的。
- Lambda 包含 `in`、`out`、`ref` 参数。
- Lambda 包含赋值操作。
- Lambda 包含一个动态操作。

>---
#### 方法组的转换

存在从方法组 `E` 到兼容委托类型 `D` 的隐式转换。

```csharp
delegate string D1(object o);
delegate object D2(string s);
delegate object D3();
delegate string D4(object o, params object[] a);
delegate string D5(int i);

class Test
{
    static string Fun(object o) => "";
    static void Test()
    {
        D1 d1 = Fun;            // Ok
        D2 d2 = Fun;            // Ok
        D3 d3 = Fun;            // Error -- 不适用
        D4 d4 = Fun;            // Error -- 适用但不兼容
        D5 d5 = Fun;            // Error -- 不兼容
    }
}
```

>---

#### 帮助程序类转换

若要在非兼容类型（如整数和 `System.DateTime` 对象，或十六进制字符串和字节数组）之间转换，可使用 `System.BitConverter` 类、`System.Convert` 类和内置数值类型的 `Parse` 方法（如 `Int32.Parse`）。

> 字节数组和内置数据类型的互相转换（`BitConverter`）

```csharp
// ----- ToInt32 -----
byte[] bytes = { 0, 0, 0, 25 };
// If the system architecture is little-endian (that is, little end first),
// reverse the byte array.
if (BitConverter.IsLittleEndian)
    Array.Reverse(bytes);
int i = BitConverter.ToInt32(bytes, 0);
Console.WriteLine("int: {0}", i);  // 25

// ----- GetBytes -----
byte[] bytes = BitConverter.GetBytes(201805978);
Console.WriteLine("byte array: " + BitConverter.ToString(bytes)); // 9A-50-07-0C
```

---
### 模式匹配

模式是一种语法形式，可以使用 `is` 表达式、`switch` 语句和 `switch` 表达式将输入表达式与任意数量的特征匹配。C# 支持多种模式，包括声明、类型、常量、关系、属性、列表、var 和弃元。可以使用布尔逻辑关键字 `and`、`or` 和 `not` 组合模式。

模式匹配类型：
  - 声明模式：用于检查表达式的运行时类型，如果匹配成功，则将表达式结果分配给声明的变量。
  - 类型模式：用于检查表达式的运行时类型。 在 C# 9.0 中引入。
  - 常量模式：用于测试表达式结果是否等于指定常量。
  - 关系模式：用于将表达式结果与指定常量进行比较。 在 C# 9.0 中引入。
  - 逻辑模式：用于测试表达式是否与模式的逻辑组合匹配。 在 C# 9.0 中引入。
  - 属性模式：用于测试表达式的属性或字段是否与嵌套模式匹配。
  - 位置模式：用于解构表达式结果并测试结果值是否与嵌套模式匹配。
  - var 模式：用于匹配任何表达式并将其结果分配给声明的变量。
  - 弃元模式：用于匹配任何表达式。
  - 列表模式：测试序列元素是否与相应的嵌套模式匹配。 在 C# 11 中引入。

>---
#### is 模式匹配

```csharp
bool rt_2 = E is <pattern>;

// exam
int i = 34;
object iBoxed = i;
int? jNullable = 42;
if (jNullable is not null)  // 检查 null
    if (iBoxed is int a && jNullable is int b)
        Console.WriteLine(a + b);  // output 76
```

#### switch 模式匹配

- `switch` 语句形式的模式匹配：

```csharp
switch (<switch_on>)
{
    case <exp_1>:
    case <exp_2>: 
        // do...
        break; // return, goto
    default:
        // default do
        break;
}

// exam
DisplayMeasurement(-4);     // Output: Measured value is -4; too low.
DisplayMeasurement(5);      // Output: Measured value is 5.
DisplayMeasurement(30);     // Output: Measured value is 30; too high.
DisplayMeasurement(double.NaN);  // Output: Failed measurement.

void DisplayMeasurement(double measurement)
{
    switch (measurement)
    {
        case < 0.0: Console.WriteLine($"Measured value is {measurement}; too low."); break;
        case > 15.0: Console.WriteLine($"Measured value is {measurement}; too high."); break;
        case double.NaN: Console.WriteLine("Failed measurement."); break;
        default: Console.WriteLine($"Measured value is {measurement}."); break;
    }
}
```

- `switch` 表达式形式的模式匹配

```csharp
var rt = <switch_on> switch
{
    case_1 => case_1_return,
    case_2 => case_2_return,
    //....cases
    _ => default_return
};

// exam
public static class SwitchExample
{
    public enum Direction { Up, Down, Right, Left }
    public enum Orientation { North, South, East, West }
    public static Orientation ToOrientation(Direction direction) => direction switch
    {
        Direction.Up => Orientation.North,
        Direction.Right => Orientation.East,
        Direction.Down => Orientation.South,
        Direction.Left => Orientation.West,
        _ => throw new ArgumentOutOfRangeException(nameof(direction), $"Not expected direction value: {direction}"),
    };
    static void Main()
    {
        var direction = Direction.Right;
        Console.WriteLine($"Map view direction is {direction}." + $" Cardinal orientation is {ToOrientation(direction)}.");
        // Output: Map view direction is Right. Cardinal orientation is East.
    }
}
```

>---

#### 声明模式

使用声明模式检查表达式的运行时类型是否与给定类型兼容。声明模式的表达式结果 `E` 为非 null 且在运行时类型是 `T` 类型、或可隐式转换类型、或 `T` 的派生类型、或具有基础类型 `T` 的可为 null 的值类型、或存在从 `E` 的运行时类型到类型 `T` 的装箱或取消装箱转换，则模式匹配成功。  

> is 表达式

```csharp
object greeting = "Hello, World!";
if (greeting is string message)
    Console.WriteLine(message.ToLower());  // output: hello, world!
```

> switch 表达式和语句

```csharp
var numbers = new int[] { 10, 20, 30 };
Console.WriteLine(GetSourceLabel(numbers));  // output: 1

var letters = new List<char> { 'a', 'b', 'c', 'd' };
Console.WriteLine(GetSourceLabel(letters));  // output: 2
// switch 表达式
static int GetSourceLabel<T>(IEnumerable<T> source) => source switch
{
    Array array => 1,
    ICollection<T> collection => 2,
    _ => 3,
};
// switch 语句
static int GetSourceLabel<T>(IEnumerable<T> source)
{
    switch (source)
    {
        case Array array: /*do...*/ return 1;
        case ICollection<T> collection: return 2;
        default: return 3;
    }
}
```

- 可以使用弃元代替变量名。

```csharp
static int GetSourceLabel<T>(IEnumerable<T> source) => source switch
{
    Array _ => 1,     // 弃元替代
    ICollection<T> _ => 2,  
    _ => 3,
};
```

>---

#### 类型模式

使用类型模式检查表达式 `E` 的运行时类型是否与给定类型 `T` 兼容。类型模式的表达式结果 `E` 为非 null 且在运行时类型是 `T` 类型、或可隐式转换类型、或 `T` 的派生类型、或具有基础类型 `T` 的可为 null 的值类型、或存在从 `E` 的运行时类型到类型 `T` 的装箱或取消装箱转换，则模式匹配成功。

> is 表达式

```csharp
var input = Console.ReadLine();
if (input is string)
    Console.WriteLine("INPUT: " + input);
```

> switch 表达式和语句

```csharp
int[] d = null;
Console.WriteLine(GetSourceLabel(d));  // output: -1

var numbers = new int[] { 10, 20, 30 };
Console.WriteLine(GetSourceLabel(numbers));  // output: 1

var letters = new List<char> { 'a', 'b', 'c', 'd' };
Console.WriteLine(GetSourceLabel(letters));  // output: 2
// switch 表达式
static int GetSourceLabel<T>(IEnumerable<T> source) => source switch
{
    Array => 1, // 类型模式
    ICollection<T> => 2,
    null => -1,
    _ => 3,
};
// switch 语句
static int GetSourceLabel<T>(IEnumerable<T> source)
{
    switch (source)
    {
        case Array: return 1;
        case ICollection<T>: return 2;
        case null: return -1;
        default: return 3;
    }
};
```

>---

#### 常量模式

可使用常量模式来测试表达式结果是否等于指定的常量。

```csharp
// is 表达式
var input = Console.ReadLine();
if (input is not (null or "" or "\n"))
    Console.WriteLine("INPUT: "+input);

// switch 表达式
var rt = Console.ReadLine() switch
{
    "\n" => "\\n",
    "" => "Empty",  // 直接回车输入 ""
    string input => input,
    null => "null",     // ctrl+letter 输出 null
};
Console.WriteLine("INPUT: " + rt);

// switch 语句
switch (Console.ReadLine())
{
    case "\n": rt = "\\n"; break;
    case "": rt = "Empty"; break;
    case string input: rt = input; break;
    case null: rt = "null"; break;
}
Console.WriteLine("INPUT: " + rt);
```

>---

#### 关系模式

可使用关系模式将表达式结果与常量进行比较。在关系模式中，可使用关系运算符 `<`、`>`、`<=` 或 `>=` 中的任何一个。关系模式的右侧部分必须是常数表达式。

```csharp
Console.WriteLine(Classify(13));   // output: Too high
Console.WriteLine(Classify(double.NaN));  // output: Unknown
Console.WriteLine(Classify(2.4));  // output: Acceptable

static string Classify(double measurement) => measurement switch
{
    < -4.0 => "Too low",
    > 10.0 => "Too high",
    double.NaN => "Unknown",
    _ => "Acceptable",
};
```

>---

#### 逻辑模式

可使用 `not`、`and` 和 `or` 模式连结符来创建逻辑模式。其中优先级为 `not` > `and` > `or`。

```csharp
Console.WriteLine(Classify(13));    // output: High
Console.WriteLine(Classify(-100));  // output: Too low
Console.WriteLine(Classify(5.7));   // output: Acceptable
static string Classify(double measurement) => measurement switch
{
    < -40.0 => "Too low",
    >= -40.0 and < 0 => "Low",
    >= 0 and < 10.0 => "Acceptable",
    >= 10.0 and < 20.0 => "High",
    >= 20.0 => "Too high",
    double.NaN => "Unknown",
};
```

>---

#### 属性模式

可以使用属性模式将表达式的属性或字段与嵌套模式进行匹配。

```csharp
public record Order(int Items, decimal Cost);

public decimal CalculateDiscount(Order order) => order switch
{
    { Items: > 10, Cost: > 1000.00m } => 0.10m,
    { Items: > 5, Cost: > 500.00m } => 0.05m,
    { Cost: > 250.00m } => 0.02m,
    null => throw new ArgumentNullException(nameof(order), "Can't calculate discount on null order"),
    var someObject => 0m,
};
```

> 嵌套

```csharp
public record Point(int X, int Y);
public record Segment(Point Start, Point End);

static bool IsAnyEndOnXAxis(Segment segment) =>
    segment is { Start: { Y: 0 } } or { End: { Y: 0 } };
// 扩展属性模式：等价行为
static bool IsAnyEndOnXAxis(Segment segment) =>
    segment is { Start.Y: 0 } or { End.Y: 0 };
```

>---

#### 位置模式

可使用位置模式来解构表达式结果并将结果值与相应的嵌套模式匹配。

```csharp
static string Classify(Point point) => point switch
{
    (0, 0) => "Origin",
    ( > 0, 0) => "positive X",
    ( < 0, 0) => "negative X",
    (0, > 0) => "positive Y",
    (0, < 0) => "negative Y",
    _ => "Just a point",
};
public readonly struct Point(int x, int y)
{
    public int X { get; } = x;
    public int Y { get; } = y;
    // Deconstruct 方法用于解构表达式结果
    public void Deconstruct(out int x, out int y) => (x, y) = (X, Y);
}
```

> 在位置模式中使用属性模式

```csharp
var random = new Random(DateTime.Now.Microsecond);
int index = 0;
while (index < 100)
{
    index++;
    var input = new Vector2D(random.NextDouble() * 20 - 10, random.NextDouble() * 20 - 10);
    if (input is Vector2D(> 0, > 0) p)
    {
        if (IsInDomain(p))
            Console.WriteLine(p + " is in Domain"); // 第一象限与半径为 10 的圆的相交区域
    }
}
static bool IsInDomain(Vector2D point) => point is ( > 0, > 0) { magnitude: < 10 };
public record Vector2D(double X, double Y)
{
    public double magnitude => Math.Abs(unchecked(Math.Sqrt(X * X + Y * Y)));
    public override string ToString() => ($"{X:F2}", $"{Y:F2}").ToString();
}
```

>---

#### var 模式

可使用 `var` 模式来匹配任何表达式（包括 `null`），并将其结果分配给新的局部变量。

```csharp
Console.WriteLine(Transform(new Point(1, 2)));  // output: Point { X = -1, Y = 2 }
Console.WriteLine(Transform(new Point(5, 2)));  // output: Point { X = 5, Y = -2 }

static Point Transform(Point point) => point switch
{
    var (x, y) when x < y => new Point(-x, y),
    var (x, y) when x > y => new Point(x, -y),
    (int x, int y) => new Point(x, y),
};
public record Point(int X, int Y);
```

>---

#### 弃元模式

可使用弃元模式 `_` 来匹配任何表达式，包括 `null`。

```csharp
static decimal GetDiscountInPercent(DayOfWeek? dayOfWeek) => dayOfWeek switch
{
    DayOfWeek.Monday => 0.5m,
    DayOfWeek.Tuesday => 12.5m,
    DayOfWeek.Wednesday => 7.5m,
    DayOfWeek.Thursday => 12.5m,
    DayOfWeek.Friday => 5.0m,
    DayOfWeek.Saturday => 2.5m,
    DayOfWeek.Sunday => 2.0m,
    _ => 0.0m,  // 弃元
};
```

>---

#### 列表模式

从 C#11 开始，可以将数组或列表与模式的序列进行匹配。当每个嵌套模式与输入序列的相应元素匹配时，列表模式就会匹配。若要匹配任何元素，可使用弃元模式；若想要捕获元素，可使用 `var` 模式；若要仅匹配输入序列开头或 / 和结尾的元素，可使用切片模式 `..`，切片模式匹配零个或多个元素，最多可在列表模式中使用一个切片模式。

```csharp
Console.WriteLine(new[] { 1, 2, 3, 4, 5 } is [> 0, > 0, ..]);  // True
Console.WriteLine(new[] { 1, 1 } is [_, _, ..]);               // True
Console.WriteLine(new[] { 0, 1, 2, 3, 4 } is [> 0, > 0, ..]);  // False
Console.WriteLine(new[] { 1 } is [1, 2, ..]);                  // False

Console.WriteLine(new[] { 1, 2, 3, 4 } is [.., > 0, > 0]);     // True
Console.WriteLine(new[] { 2, 4 } is [.., > 0, 2, 4]);          // False
Console.WriteLine(new[] { 2, 4 } is [.., 2, 4]);               // True

Console.WriteLine(new[] { 1, 2, 3, 4 } is [>= 0, .., 2 or 4]); // True
Console.WriteLine(new[] { 1, 0, 0, 1 } is [1, 0, .., 0, 1]);   // True
Console.WriteLine(new[] { 1, 0, 1 } is [1, 0, .., 0, 1]);      // False
```

- 可以在切片模式中嵌套子模式。

```csharp
void MatchMessage(string message)
{
    var result = message is ['a' or 'A', .. var s, 'a' or 'A']
        ? $"Message {message} matches; inner part is {s}."
        : $"Message {message} doesn't match.";
    Console.WriteLine(result);
}

MatchMessage("aBBA");  // output: Message aBBA matches; inner part is BB.
MatchMessage("apron");  // output: Message apron doesn't match.

void Validate(int[] numbers)
{
    var result = numbers is [< 0, .. { Length: >= 2 and <= 4 }, > 0] ? "valid" : "not valid";
    Console.WriteLine(result);
}

Validate(new[] { -1, 0, 1 });  // output: not valid
Validate(new[] { -1, 0, 0, 1 });  // output: valid
Validate(new[] { -1, 0, 2, 0, 1 });  // output: valid
```

---
### 索引与范围运算符

索引和范围运算符可以在序列的访问器中使用：
- `^`（从末尾开始索引）：指示元素位置来自序列的末尾，`[^n] = [Length - n]`。
- `..`（范围）：指定可用于获取一系列序列元素的索引范围。`..` 运算符指定某一索引范围的开头和末尾作为其操作数，左侧操作数是范围的包含性开头，右侧操作数是范围的不包含性末尾。`[a..]` 等效于 `[a..^0]`、`[..b]` 等效于 `[0..b]`、`[..]` 等效于 `[0..^0]`。

```csharp
// ^ 末尾运算符
var xs = new int[] { 0, 10, 20, 30, 40 };
int last = xs[^1];  // [^0] 将超出索引范围

// .. 范围运算符
var rx = new int[] { 0, 100, 200, 300, 400 };
int halfIndex = rx.Length / 2;
var rx_LeftHalf = rx[..halfIndex];
var rx_RightHalf = rx[^(rx.Length - halfIndex)..];
Console.WriteLine("Left Half : " + string.Join(",", rx_LeftHalf));
Console.WriteLine("Right Half : " + string.Join(",", rx_RightHalf));
```

>---

#### Index 与 Range 

索引 `System.Index` 和范围 `System.Range` 为访问序列中的单个元素或范围提供了简洁的语法。表达式 `^0` 属于 `System.Index` 类型，表达式 `a..b` 属于 `System.Range` 类型。若任何类型提供带 `Index` 或 `Range` 参数的索引器，则该类型可分别显式支持索引 `^n` 或范围 `a..b`。

单维度数组、交错数组、`String`、`Span<T>` 和 `ReadOnlySpan<T>` 同时支持索引和范围。`List<T>` 仅支持索引。

```csharp
System.Range r = 0..5;
System.Index i = ^1;

string str = "Hello, World";
string hello = str[0..5];  // str[r]

List<int> arr = [0, 1, 2, 3, 4, 5];
var last = arr[^1];    // arr[i]
```

>---

#### 索引和范围的类型支持

若任何类型提供带 `Index` 或 `Range` 参数的索引器，则该类型可分别显式支持索引或范围。

```csharp
PointArray ps = new PointArray(
    new(0, 1), new(1, 2), new(2, 3), 
    new(3, 4), new(4, 5), new(5, 6));
Console.WriteLine("Last Point is " + ps[^1]);
// Last Point is (5, 6)
Console.WriteLine("The Points of range 1~4 are " + string.Join(",", ps[1..5]));
// The Points of range 1~4 are (1, 2),(2, 3),(3, 4),(4, 5)

readonly record struct Point(int x, int y)
{
    public override string ToString() => (x, y).ToString();
}
record struct PointArray(params Point[] ps)
{
    public Point this[Index i] => ps[i];
    public Point[] this[Range r] => ps[r];
}
```

>---

#### 索引和范围的隐式支持

若某个类型具有一个名为 `int Length{ get;}` 或 `int Count{ get;}` 实例属性和一个 `T this[int index]` 实例索引器，并且没有仅以 `System.Index` 类型为索引的索引器时，该类型隐式支持索引运算。首选使用 `Length`。

若某个类型具有一个名为 `int Length{ get;}` 实例属性和一个 `public T[] Slice(int start, int length)` 实例方法，并且没有仅以 `System.Range` 为索引的索引器时，该类型隐式支持范围运算。

```csharp
PointArray ps = new PointArray(
    new(0, 1), new(1, 2), new(2, 3), 
    new(3, 4), new(4, 5), new(5, 6));
Console.WriteLine("Last Point is " + ps[^1]);
// Last Point is (5, 6)
Console.WriteLine("The Points of range 1~4 are " + string.Join(",", ps[1..5]));
// The Points of range 1~4 are (1, 2),(2, 3),(3, 4),(4, 5)

readonly record struct Point(int x, int y)
{
    public override string ToString() => (x, y).ToString();
}
record struct PointArray(params Point[] ps)
{
    public Point this[int i] => ps[i];
    public int Length => ps.Length;
    public Point[] Slice(int start, int length)
    {
        var _ps = new Point[length];
        Array.Copy(ps, start, _ps, 0, length);
        return _ps;
    }
}
```

---
### 集合表达式

可以使用集合表达式来创建常见的集合值。集合表达式在 `[` 和 `]` 括号之间包含元素的序列。可以为一维数组类型、`System.Span<T>` 和 `System.ReadOnlySpan<T>`、支持集合初始化设定项的类型（例如 `System.Collections.Generic.List<T>` 等）使用集合表达式语法。

```csharp
Span<string> weekDays = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
foreach (var day in weekDays)
    Console.WriteLine(day);

int[] arr = [10, 20, 30];
List<int> list = [1, 2, 3, 4, 5];
```

>---

#### 内联集合值

可以使用展开运算符 `..` 在集合表达式中使用内联集合值。

```csharp
int[] left = [1, 2, 3, 4];
int[] right = [5, 6, 7, 8, 9];
int[] all = [.. left, .. right, 0];
Console.WriteLine(string.Join(",", all)); 
// output: 1,2,3,4,5,6,7,8,9,0
```

>--- 
#### 集合表达式转换

集合表达式可转换为单维数组类型 `T[]`。

```csharp
int[] arr = [1, 2, 3, 4, 5];
int[][] arr2 = [[10, 20, 30], [0], arr];      // 交错数组
```

集合表达式可转换为 `Span<T>` 或 `ReadOnlySpan<T>` 类型。

```csharp
Span<int> arr = [1, 2, 3, 4, 5];
ReadOnlySpan<int> arr2 = [.. arr, 6, 7, 8, 9];
Span<int> arr3 = [.. arr2, 0];
Console.WriteLine(string.Join(",", arr3.ToArray()));
// output: 1,2,3,4,5,6,7,8,9,0
```

集合表达式可转换为实现 `IEnumerable<T>` 接口并拥有一个公共或扩展定义的 `Add` 方法。

```csharp
ReadOnlyArray<int> arr = [1, 2, 3, 4, 5, 6];
foreach (int i in arr)
    Console.WriteLine(i);

struct ReadOnlyArray<T>() : IEnumerable<T>
{
    private readonly T[] values = new T[100];
    private int Length = 0;
    public void Add(T value)
    {
        if (Length > values.Length - 1)
            throw new ArgumentOutOfRangeException("Capacity");
        values[Length++] = value;
    }
    public IEnumerator<T> GetEnumerator() => values[..^(values.Length - Length)].AsEnumerable().GetEnumerator();
    IEnumerator IEnumerable.GetEnumerator() => values[..^(values.Length - Length)].GetEnumerator();
}
```

集合表达式可转换为实现 `IEnumerable` 接口并拥有一个公共或扩展定义的 `Add` 方法。

```csharp
InlineBuffer arr = [1, 2, "Hello", 4, 3.1415, 6];
foreach (int i in arr)
    Console.WriteLine(i);

class InlineBuffer : IEnumerable
{
    public readonly List<object> buffer = new List<object>(80);
    public void Add(object value) => buffer.Add(value);
    public IEnumerator GetEnumerator() => buffer.GetEnumerator();
}
```

集合表达式可转换为实现任何继承 `System.Collections.IEnumerable` 或 `System.Collections.Generic.IEnumerable<T>` 接口的接口的类型。

```csharp
MyList<int> arr = [1, 2, 3, 4, 5];

class MyList<T> : IReadOnlyList<T>  // IReadOnlyList<T> : IEnumerable<T>
{
    public T this[int index] => throw new NotImplementedException();
    public int Count => throw new NotImplementedException();
    public IEnumerator<T> GetEnumerator() => throw new NotImplementedException();
    IEnumerator IEnumerable.GetEnumerator() => throw new NotImplementedException();
    public void Add(T t) { }
}
```

>---

#### 集合表达式实例的构造过程

当目标类型是实现 `System.Collections.IEnumerable` 接口的结构或类类型，且目标类型没有类似 `Create` 集合生成器的方法，则集合实例的构造如下：
- 元素按顺序求值，部分或所有元素可能在下面的步骤中求值。编译器可以通过调用每个扩展元素表达式上的 `Length` 或 `Count` 属性来确定集合表达式的已知长度。
- 调用不带参数的构造函数。
- 对于每个元素，按顺序：
  - 如果元素是表达式元素，则使用元素表达式作为参数调用适用的 `Add` 方法或扩展方法。
  - 如果元素是展开元素（`.. Expr`），则使用以下方法之一：
    - 在扩展元素表达式上调用适用的 `GetEnenumerator` 实例或扩展方法，对于来自枚举器的每个枚举项，在集合实例上调用适用的 `Add` 实例或扩展方法，并将该项作为参数。如果枚举实现了 `IDisposable`，那么在枚举之后将调用 `Dispose`。
    - 在使用扩展元素表达式作为参数的集合实例上调用适用的 `AddRange` 实例或扩展方法。
    - 使用集合实例和 `int` 索引作为参数，在扩展元素表达式上调用适用的 `CopyTo` 实例或扩展方法。
- 在上面的构造步骤中，可以在带有 `int Capacity` 参数的集合实例上调用一次或多次适用的 `EnsureCapacity` 实例或扩展方法。

当目标类型是数组、`Span` 类型、具有 `Create` 集合生成器的类型或接口，则集合实例的构造如下：
- 元素按顺序求值。部分或所有元素可能在下面的步骤中求值。编译器可以通过调用每个扩展元素表达式上的可计数属性来确定集合表达式的已知长度。
- 创建初始化实例的方法如下：
  - 如果目标类型是一个数组，并且集合表达式的长度已知，则分配一个具有预期长度的数组。
  - 如果目标类型是 `Span` 或具有 `Create` 方法的类型，并且集合具有已知的长度，则将引用连续存储创建具有预期长度的 `Span`。
  - 否则分配中间存储。
- 对于每个元素按顺序：
  - 如果元素是表达式元素，则调用初始化实例索引器将计算的表达式添加到当前索引处。
  - 如果该元素是展开元素，则使用以下方法之一：
    - 调用已知接口或类型的成员将项从扩展元素表达式复制到初始化实例。
    - 在扩展元素表达式上调用适用的 `GetEnenumerator` 实例或扩展方法，对于枚举器中的每个项，调用初始化实例索引器以在当前索引处添加项。如果枚举数实现了 `IDisposable`，那么在枚举之后将调用 `Dispose`。
    - 使用初始化实例和 `int` 索引作为参数，在扩展元素表达式上调用适用的 `CopyTo` 实例或扩展方法。
- 如果为集合分配了中间存储，则为集合实例分配实际集合长度，并将初始化实例中的值复制到集合实例中，或者如果需要一个 `Span`，编译器可能会使用中间存储中实际集合长度的 `Span`。否则初始化实例就是集合实例。
- 如果目标类型具有创建方法，则使用 `Span` 实例调用该创建方法。

>---

#### 为 IDictionary 类型扩展集合表达式构造语法

```csharp
Dictionary<int, int> ArrDic = [(1, 1), (2, 2), (3, 3)];
public static class KYExt
{
    public static void Add<TK, TV>(this IDictionary<TK, TV> Dic, (TK key, TV value) KV)
    {
        if (Dic.ContainsKey(KV.key))
            return;
        Dic.Add(KV.key, KV.value);
    }
}
```

>---

#### 集合生成器
 
集合表达式还可转换具有集合生成器的类型。类型通过编写绑定名称的生成器方法（例如 `Create`）和对集合类型应用 `System.Runtime.CompilerServices.CollectionBuilderAttribute` 来指示生成器方法来选择加入集合表达式支持。集合类型必须具有迭代器 `GetEnumerator`。

> 设计一个可使用集合表达式的集合类型

- 首先必须将 `CollectionBuilderAttribute` 属性添加到需要使用集合表达式构造的集合类型上，并指定集合生成器类和构造器方法的名称。生成器必须是非泛型类或结构，生成器方法必须是 `static` 并使用 `ReadOnlySpan<T>` 为唯一参数，以集合元素类型为 `Span` 类型。
- `ReadOnlySpan` 参数可以显式的声明为 `scoped` 或 `[UnscopedRef]`，如果参数隐式或显式地限定了作用域，则编译器可能会在堆栈而不是堆上为 `Span` 分配存储空间。

```csharp
[CollectionBuilder(typeof(MyCollectionBuilder), "Build")]
public class MyCollection
{
    public readonly int[] Values;
    public MyCollection(int[] arr) => Values = arr;

    internal class MyCollectionBuilder
    {
        internal static MyCollection Build(ReadOnlySpan<int> arr) => new MyCollection(arr.ToArray());
    }
}
```

- 集合类型需要一个 `IEnumerator<T> GetEnumerator()` 方法为其集合元素提供迭代功能。也可以继承 `IEnumerable` 或 `IEnumerable<T>`。

```csharp
public class MyCollection
{
    //....
    public IEnumerator<int> GetEnumerator() => Values.AsEnumerable().GetEnumerator();
    //....
}
```

- 使用集合表达式初始化该集合类型。

```csharp
MyCollection arr = [1,2,3,4];
```

> *泛型集合生成器*

`CollectionBuilderAttribute` 特性指定的集合生成器必须是非泛型类或结构，生成器方法是可以使用类型参数的。声明集合生成器的类不能嵌套在泛型类型中。

```csharp
using System.Runtime.CompilerServices;

MyCollection<int> arr = [1, 2, 3, 4, 5];

[CollectionBuilder(typeof(MyCollectionBuilder), "Build")]
public record MyCollection<T>(params T[] Values)
{
    public IEnumerator<T> GetEnumerator() => Values.AsEnumerable().GetEnumerator();
}
internal class MyCollectionBuilder
{
    internal static MyCollection<T> Build<T>(ReadOnlySpan<T> arr) => new MyCollection<T>(arr.ToArray());
}
```





---
### 语句

#### 声明语句

声明语句声明新的局部变量、局部常量或 `ref` 局部变量。 

```csharp
void Sample()
{
    int a, b;        // 仅声明
    int c = 1;       // 声明并初始化
    var arr = new[] { 1, 2, 3, 4, 5 };    // 隐式类型声明
    const string greeting = "Hello";      // 常量声明
    ref int r_num = ref c;
}
```

>---
#### 空语句

当在需要语句的上下文中不需要执行任何操作时，使用空语句（`;`）。执行空语句只是将控制转移到语句的结束点。

```csharp
while (condition)
    ;
```

>---
#### if-else

`if`、`if-else`、`if-else if` 语句根据布尔表达式的结果选择要遵循的若干代码路径的哪一个。

```csharp
string scan = Console.ReadLine();

if (scan is null)
    Console.WriteLine("Input NULL");
else if (scan is "")
    Console.WriteLine("Input Empty");
else Console.WriteLine(scan);
```

>---
#### switch

`switch` 语句根据与匹配表达式匹配的模式来选择要执行的语句列表。可以为 `switch` 语句的一部分指定多个 `case` 模式；`default` 模式始终匹配成功，最多只有一个 `default` 子句。

在 `switch` 语句中无法贯穿，但可以并列多个 case，可以使用跳转语句从 `switch` 跳出或转移其他分支。可以在 `case` 模式中使用 `when` 筛选。

```csharp
switch (a)
{
    case > 0 when a < 10:
        Console.WriteLine("0 < a < 10");
        break;
    case > 10:
    case  < -10:
        break;
    case 0:
        Console.WriteLine($"a == {a}");
        break;
    case 5:
    case -5:
        goto case 0;  // 仅 case 常量
    default:
        break;
}
```

在 `switch` 语句块中声明的局部变量不考虑它在哪个分支，它们属于同一名称空间和作用域。例如，`int y` 尽管声明出现在 `case 0` 段中，但对于默认情况，局部变量 `y` 在 `switch` 某 `case` 或 `default` 段中的作用域内。

```csharp
int x = 1;
switch (x)
{
    case 0:
        int y;
        break;
    default:
        y = 10;
        Console.WriteLine(x + y);
        break;
}
```

>---
####  for

```csharp
for( 初始化表达式; 条件表达式; 迭代器)
{ 
    循环体 
} 
```

“初始化表达式” 部分仅在进入循环前执行一次，并根据条件表达式确定是否进入循环体。“迭代器” 在每次循环体执行后执行一次。`for` 语句的每部分都是可选的：`for(;;)` 相当于 `while(true)`。

```csharp
for (int i = 0; i < 10; i++)
    Console.WriteLine(i);
```

>---
#### foreach

`foreach(var t in ts)` 语句为类型实例中实现 `System.Collections.IEnumerable` 或 `System.Collections.Generic.IEnumerable<T>` 接口的每个元素执行循环体。

```csharp
var fibNumbers = new List<int> { 0, 1, 1, 2, 3, 5, 8, 13 };
foreach (int element in fibNumbers)
{
    Console.Write($"{element} ");
}
// Output:
// 0 1 1 2 3 5 8 13
```

除了这些类型，迭代对象可以是其类型具有公共无参数 `GetEnumerator` 方法（从 C# 9 开始，`GetEnumerator` 方法可以是类型的扩展方法），`GetEnumerator` 方法的返回类型具有公共 `Current` 属性（可以有 `ref` 修饰，返回迭代变量）和公共无参 `bool MoveNext()` 方法。

```csharp
NumArray arr = new NumArray(1, 2, 3, 4, 5, 6, 7, 8, 9);
foreach (int i in arr)
    Console.WriteLine(i);

record struct NumArray(params int[] nums)
{
    public IEnumerator<int> GetEnumerator() => nums.ToList().GetEnumerator();
}
```

若枚举器的 `Current` 属性返回 `ref Current` 则可以使用 `ref` 或 `ref readonly` 修饰声明迭代变量。

```csharp
Span<int> storage = stackalloc int[10];
int num = 0;
foreach (ref int item in storage)
    item = num++;
foreach (ref readonly var item in storage)
    Console.Write($"{item} ");
// Output:
// 0 1 2 3 4 5 6 7 8 9
```

定义一个集合类型 `C`、枚举器类型 `E` 和迭代类型 `T`、`ref T` 或 `ref readonly T`，组成一个 `foreach` 语句的形式 `foreach (V v in x) { embedded_statement }`，迭代器的行为类似于：

```csharp
{
    E e = ((C)(x)).GetEnumerator();
    try
    {
        while(e.MoveNext())
        {
            V v = (V)(T)e.Current;
            embedded_statement; 
        }
    }finally
    {
        if(e is IDisposable d)
            d.Dispose();
    }
}
```

`foreach` 语句在编译时，首先确定表达式的集合类型、枚举器类型和迭代元素类型。

对于 `foreach(var t in expr)`：
- 如果表达式 `expr` 的类型 `X` 是数组类型，则可以隐式转换为 `IEnumerable` 接口。`foreach` 语句编译时确定集合类型 `IEnumerable`，枚举器类型是 `IEnumerator`，迭代元素类型是 `X`。
+ 如果表达式 `expr` 是动态表达式，且可以推断表达式的结果可以隐式转换到 `IEnumerable` 接口。那么编译时确定集合类型是 `IEnumerable`，枚举器类型是 `IEnumerator`，迭代元素类型是 `dynamic` 或 `object` 类型。
- 否则，将判断表达式的结果类型 `X` 是否具有合适的 `GetEnumerator` 方法：
  - 首先在没有类型参数的 `X` 类型中查找对标识符为 `GetEnumerator` 的公共非静态方法成员。`GetEnumerator` 方法不含有任何参数，返回类型 `E` 应该是一个类、结构或接口类型。
  - 接下来在 `E` 上查找是否具有 `Current` 的公共非静态的属性。
  - 接下来在 `E` 上查找是否具有 `MoveNext` 的公共非静态的返回 `bool` 类型的方法。
  - 当满足上述所有查找条件时，该 `X` 是一个可枚举对象。`foreach` 语句编译时确定集合类型是 `X`，枚举器类型是 `E`，迭代元素类型是 `E.Current` 的属性类型。
  - 查找过程中当不满足任意步骤的查找条件时，则进行下一步判断。
+ 检查是否有可枚举接口：
  - 如果在所有类型 `Ti` 中存在从 `X` 到 `IEnumerable<Ti>` 的隐式转换，则存在一个唯一类型 `T`，使得 `T` 不是动态类型，并且对于所有其他类型 `Ti` 存在从 `IEnumerable<T>` 到 `IEnumerable<Ti>` 的隐式转换，则集合类型为接口 `IEnumerable<T>`，枚举类型为接口 `IEnumerator<T>`，迭代元素类型为 `T`。
  - 否则，如果有多个这样的类型 `T`，则产生一个错误，并且不采取进一步的步骤。
  - 否则，如果存在从 `X` 到 `IEnumerable` 接口的隐式转换。那么集合类型就是  `IEnumerable`，枚举类型就是 `IEnumerator`，元素类型为 `object`。
- 否则，将判断表达式的结果类型 `X` 是否具有合适的 `GetEnumerator` 扩展方法，且它的返回类型 `E` 包含符合迭代器规则的 `Current` 和 `MoveNext` 成员。`foreach` 语句编译时确定集合类型是 `X`，枚举器类型是 `E`，迭代元素类型是 `E.Current` 的属性类型。
+ 否则，将产生一个错误，并且不采取进一步的步骤。

```csharp
class Sample(int[] arr)
{
    int[] arr = arr;

    public SampleEnumerator GetEnumerator()
    {
        return new SampleEnumerator(this);
    }
    static void Main(string[] args)
    {
        Sample s = new Sample(new int[] { 1, 2, 3, 4, 5, 6 });

        foreach (var item in s)
        {
            Console.WriteLine(item);
        }
    }
    public class SampleEnumerator
    {
        private Sample sample;
        private int index = -1;
        public SampleEnumerator(Sample sample) => this.sample = sample;
        public int Current => sample.arr[index];
        public bool MoveNext() => (++index) < sample.arr.Length;
    }
}
```

> `foreach` 语句解析

- `foreach` 语句可扩展为使用 `IEnumerable` 和 `IEnumerator` 接口的标准用语，以便循环访问集合中的所有元素。

```csharp
// 原始 foreach 结构
IEnumerable collection = new int[] { 10, 20, 30, 40, 50 };
foreach (var item in collection)
    Console.WriteLine(item.ToString());

// 编译器转化类似于
IEnumerator? _enumerator = collection.GetEnumerator();
while (_enumerator.MoveNext())
{
    var item = _enumerator.Current;
    Console.WriteLine(item.ToString());
}

// 编译器完整编译
var enumerator = collection.GetEnumerator();
try
{
    while (enumerator.MoveNext())
    {
        var item = enumerator.Current;
        // do with item
        Console.WriteLine(item.ToString());
    }
}
finally
{
    // dispose of enumerator.
    (enumerator as IDisposable)?.Dispose();
}
```

>---
#### await foreach

C# 支持迭代器方法和异步方法，但不支持同时是迭代器和异步方法的方法。可以使用 `await foreach` 语句以支持异步数据流，这种迭代器返回 `IAsyncEnumerable<T>` 或 `IAsyncEnumerator<T>` 而不是 `IEnumerable<T>` 或 `IEnumerator<T>`。`IAsyncDisposable` 接口用于启用异步清理。

可以将 `await foreach` 语句与类型具有公共无参 `GetAsyncEnumerator` 方法且该方法的返回类型具有公共 `Current` 属性和公共无参数 `ValueTask<bool> MoveNextAsync` 方法的实例一起使用。异步检索下一个元素时，可能会挂起循环的每次迭代。

对于 `await foreach` 的编译时处理，等同于 `foreach` 的编译时处理。查找成元时，`GetEnumerator` 替换为 `GetAsyncEnumerator`，`bool MoveNext` 替换为 `TaskType<bool> MoveNextAsync`，`T Current` 替换为 `TaskType Current`。 

```csharp
namespace System.Collections.Generic
{
    public interface IAsyncEnumerable<out T>
    {
        IAsyncEnumerator<T> GetAsyncEnumerator(CancellationToken cancellationToken = default);
    }

    public interface IAsyncEnumerator<out T> : IAsyncDisposable
    {
        ValueTask<bool> MoveNextAsync();
        T Current { get; }
    }
}
```

`await foreach` 可以被视为：
 
```csharp
await foreach(var task in asyncEnumerable)
{
    use(task);
}
// >>>>> 
{
    IAsyncEnumerator<T> asyncEnumerator = asyncEnumerable.GetAsyncEnumerator();
    try
    {
        while (await asyncEnumerator.MoveNextAsync())
        {
            Use(asyncEnumerator.Current);
        }
    }
    finally { await ((System.IAsyncDisposable)asyncEnumerator).DisposeAsync(); }
}
```

异步迭代流 `IAsyncEnumerable<T>`：

```csharp
await foreach (int n in GenerateNumbersAsync(5))
{
    Console.Write(n);
    Console.Write(" ");
}
// Output: 0 2 4 6 8
async IAsyncEnumerable<int> GenerateNumbersAsync(int count)
{
    for (int i = 0; i < count; i++)
        yield return await ProduceNumberAsync(i);
}
async Task<int> ProduceNumberAsync(int seed)
{
    await Task.Delay(1000);
    return 2 * seed;
}
```

>---
#### do 

`do{ .. } while(e)` 循环执行一次或多次。

```csharp
int n = 0;
do
{
    Console.Write(n);
    n++;
} while (n < 5);
// Output:
// 01234
```

>---
#### while

`while(e) { .. }` 循环会执行零次或多次。

```csharp
int n = 0;
while (n < 5)
{
    Console.Write(n);
    n++;
}
// Output:
// 01234
```

>---
#### break 

`break` 语句将终止它最接近的封闭循环语句（即 `for`、`foreach`、`while` 或 `do` 循环）或 `switch` 语句。

```csharp
double[] measurements = { -4, 5, 30, double.NaN };
foreach (double measurement in measurements)
{
    switch (measurement)
    {
        case < 0.0:
            Console.WriteLine($"Measured value is {measurement}; too low.");
            break;
        case > 15.0:
            Console.WriteLine($"Measured value is {measurement}; too high.");
            break;
        case double.NaN:
            Console.WriteLine("Failed measurement.");
            break;
        default:
            Console.WriteLine($"Measured value is {measurement}.");
            break;
    }
}
// Output:
// Measured value is -4; too low.
// Measured value is 5.
// Measured value is 30; too high.
// Failed measurement.
```

>---
#### continue

`continue` 语句开启最接近的封闭循环语句（即 `for`、`foreach`、`while` 或 `do` 循环）的新循环。

```csharp
for (int i = 0; i < 5; i++)
{
    Console.Write($"Iteration {i}: ");
    if (i < 3)
    {
        Console.WriteLine("skip");
        continue;
    }
    Console.WriteLine("done");
}
// Output:
// Iteration 0: skip
// Iteration 1: skip
// Iteration 2: skip
// Iteration 3: done
// Iteration 4: done
```

>---
#### return

`return` 语句终止它所在的函数的执行，并将控制权和函数结果（若有）返回给调用方。

```csharp
double surfaceArea = CalculateCylinderSurfaceArea(1, 1);
Console.WriteLine($"{surfaceArea:F2}"); // output: 12.57

double CalculateCylinderSurfaceArea(double baseRadius, double height)
{
    double baseArea = Math.PI * baseRadius * baseRadius;
    double sideArea = 2 * Math.PI * baseRadius * height;
    return 2 * baseArea + sideArea;     // return
}
```

>---
#### goto

`goto` 语句将控制权转交给带有标签的语句。

```csharp
var matrices = new Dictionary<string, int[][]>
{
    ["A"] = new[]
    {
        new[] { 1, 2, 3, 4 },
        new[] { 4, 3, 2, 1 }
    },
    ["B"] = new[]
    {
        new[] { 5, 6, 7, 8 },
        new[] { 8, 7, 6, 5 }
    },
};

CheckMatrices(matrices, 4);

void CheckMatrices(Dictionary<string, int[][]> matrixLookup, int target)
{
    foreach (var (key, matrix) in matrixLookup)
    {
        for (int row = 0; row < matrix.Length; row++)
            for (int col = 0; col < matrix[row].Length; col++)
                if (matrix[row][col] == target)
                    goto Found;
        Console.WriteLine($"Not found {target} in matrix {key}.");
        continue;
    Found:
        Console.WriteLine($"Found {target} in matrix {key}.");
    }
}
// Output:
// Found 4 in matrix A.
// Not found 4 in matrix B.
```

在 `switch` 语句中 使用 `goto` 语句将控制权移交到具有常量大小写的 `case` 或 `goto default`。

```csharp
public enum CoffeeChoice
{
    Plain,
    WithMilk,
    WithIceCream,
}
public class GotoInSwitchExample
{
    public static void Main()
    {
        Console.WriteLine(CalculatePrice(CoffeeChoice.Plain));  // output: 10.0
        Console.WriteLine(CalculatePrice(CoffeeChoice.WithMilk));  // output: 15.0
        Console.WriteLine(CalculatePrice(CoffeeChoice.WithIceCream));  // output: 17.0
    }
    private static decimal CalculatePrice(CoffeeChoice choice)
    {
        decimal price = 0;
        switch (choice)
        {
            case CoffeeChoice.Plain:
                price += 10.0m;
                break;
            case CoffeeChoice.WithMilk:
                price += 5.0m;
                goto case CoffeeChoice.Plain;
            case CoffeeChoice.WithIceCream:
                price += 7.0m;
                goto case CoffeeChoice.Plain;
        }
        return price;
    }
}
```

>---
#### yield

在迭代器中使用 `yield` 语句提供下一个值的 `yield return` 或表示迭代结束的 `yield break`。迭代器的返回类型可以是 `IEnumerable<T>`、`IEnumerable`、`IAsyncEnumerable<T>` 异步迭代。

当开始对迭代器的结果进行迭代时，迭代器会一直执行，直到到达第一个 `yield return` 语句为止。 然后，迭代器的执行会暂停，调用方会获得第一个迭代值并处理该值。在后续的每次迭代中，迭代器的执行都会在导致上一次挂起的 `yield return` 语句之后恢复，并继续执行，直到到达下一个 `yield return` 语句为止。当控件到达迭代器或 `yield break` 语句的末尾时，迭代完成。

Lambda 表达式中不允许使用 `yield return` 语句。

```csharp
foreach (var item in Square([1, 2, 3, 4, 5, 6, 99999/* 溢出位 */, 7, 8, 9]))
    Console.Write(item + " ");  // output: 1 4 9 16 25 36
IEnumerable<int> Square(int[] items)
{
    int rt;
    for (int i = 0; i < items.Length; i++)
    {
        try { rt = checked(items[i] * items[i]); }
        catch { yield break; }  // 在溢出时跳出迭代
        yield return rt;
    }
}
```

> *异步迭代*

```csharp
await foreach (var item in SquareAsync([1, 2, 3, 4, 5, 99999, 6, 7, 8]))
    Console.WriteLine(item);

async IAsyncEnumerable<int> SquareAsync(int[] nums)
{
    int rt = 0;
    for (int i = 0; i < nums.Length; i++)
    {
        try { rt = await Square(nums[i]); }
        catch
        {
            Console.WriteLine("Overflow");
            yield break;
        }
        yield return rt;
    }
}
async Task<int> Square(int num)
{
    await Task.Run(() => Console.Write($"Input {num}*{num} = "));
    return checked(num * num);
}
// output:
//      Input 1*1 = 1 
//      Input 2*2 = 4
//      Input 3*3 = 9
//      Input 4*4 = 16
//      Input 5*5 = 25
//      Input 99999*99999 = Overflow
```

>---
#### checked, unchecked

`checked` 和 `unchecked` 语句指定整型类型算术运算和转换的溢出检查上下文。当发生整数算术溢出时，溢出检查上下文将定义发生的情况。在已检查的上下文中，引发 `System.OverflowException`；如果在常数表达式中发生溢出，则会发生编译时错误。在未检查的上下文中，会通过丢弃任何不适应目标类型的高序位来将操作结果截断。 

默认情况下，整型算术运算和转换在未检查的上下文中执行。常数表达式在已检查的上下文中计算，如果发生溢出，则会发生编译时错误。可以使用 `unchecked` 为常数表达式显式指定未检查的上下文。

从 C# 11 开始，用户可以定义的 `checked` 运算符重载和转换。

```csharp
int Sum(int x, int y) => unchecked(x + y);
int Mul(int x, int y)
{
    checked
    {
        int mul = x * y;
        Console.WriteLine(mul);
        return mul;
    }
}
```

>---
#### lock

`lock(x){ .. }` 语句获取给定对象的互斥锁，执行语句块，然后释放锁，其中 `x` 是引用类型。当锁被持有时，持有该锁的线程可以再次获取并释放该锁。任何其他线程都被阻止获取锁并等待，直到锁被释放。`lock` 语句确保在任何时刻最多只有一个线程执行它的线程体。

在 `lock` 语句的正文中不能使用 `await` 表达式。

```csharp
public class Account
{
    private readonly object balanceLock = new object();
    private decimal balance;
    public Account(decimal initialBalance) => balance = initialBalance;
    public void UpdateAccount(decimal amount)
    {
        lock (balanceLock)
            balance += amount;
    }
    public decimal GetBalance()
    {
        lock (balanceLock)
            return balance;
    }
}
class AccountTest
{
    static async Task Main()
    {
        var account = new Account(1000);
        var tasks = new Task[100];
        for (int i = 0; i < tasks.Length; i++)
            tasks[i] = Task.Run(() => Update(account));
        await Task.WhenAll(tasks);
        Console.WriteLine($"Account's balance is {account.GetBalance()}");
        // Output:
        // Account's balance is 2000
    }
    static void Update(Account account)
    {
        decimal[] amounts = { 0, 2, -3, 6, -2, -1, 8, -5, 11, -6 };
        foreach (var amount in amounts)
            account.UpdateAccount(amount);
    }
}
```

当同步对共享资源的线程访问时，一般锁定专用对象实例（例如，`private readonly object balanceLock = new object();`）或另一个不太可能被代码无关部分用作 `lock` 对象的实例。避免对不同的共享资源使用相同的 `lock` 对象实例，因为这可能导致死锁或锁争用。避免使用 `this`、`Type` 实例、字符串字面量作为 `lock` 对象。

>---
#### using

`using(<IDisposable> disposable){ .. }` 语句或 `using <IDisposable> disposable;` 声明可确保正确使用 `IDisposable` 实例 `disposable`：`disposable` 局部变量在它的作用域末尾调用它的 `Dispose` 方法并释放该对象。`using` 语句可确保在发生异常的情况下也会释放 `IDisposable` 实例。在一个 `using` 语句中声明多个实例时，它们将按声明的相反顺序释放。

由 `using` 语句或声明进行声明的变量是只读的，无法重新分配该变量或将其作为 `ref` 或 `out` 参数传递。

```csharp
// using 语句
static IEnumerable<int> LoadNumbers_1(string filePath)
{
    var numbers = new List<int>();
    using (StreamReader reader = File.OpenText("numbers.txt"))  
    {
        string line;
        while ((line = reader.ReadLine()) is not null)
            if (int.TryParse(line, out int number))
                numbers.Add(number);
    }
    return numbers; 
}
// using 声明
static IEnumerable<int> LoadNumbers_2(string filePath)
{
    using StreamReader reader = File.OpenText(filePath); 
    var numbers = new List<int>();
    string line;
    while ((line = reader.ReadLine()) is not null)
        if (int.TryParse(line, out int number))
            numbers.Add(number);
    return numbers;
}
```

>---
#### await using

使用 `await using` 语句来正确使用 `IAsyncDisposable` 实例：在声明的局部变量离开被声明的作用域语句块时，将自动调用 `DisposeAsync` 方法释放该实例。`await using` 也可以使用拥有公共无参 `public async ValueTask DisposeAsync()` 方法的对象（不必是 `IAsyncDisposable` 接口实例）。

```csharp
await using (var resource = new AsyncDisposableExample())
{
    // Use the resource
}
class AsyncDisposableExample{
    public async ValueTask DisposeAsync() => Console.WriteLine("DisposeAsync...");
}

```

可以将 `using` 语句和声明与适用于可释放模式的 `ref` 结构的实例一起使用，该结构有一个实例 `public void Dispose()` 方法。

```csharp
int num = 1;
using (Sample s = new Sample(ref num))
{
    // ref 字段可以在 using 中修改，但其引用不可修改
    s.Value = 10;
    Console.WriteLine(num);
}
ref struct Sample
{
    public Sample(ref int val)
    {
        Value = ref val;
    }
    public ref int Value;
    public void Dispose() => Console.WriteLine("ref struct Disposed");
}
```

>---
#### throw

在 `throw e;` 语句中，表达式 `e` 的结果必须隐式转换为 `System.Exception`。可以在 `catch` 块中使用 `throw;` 语句重新引发由 `catch` 处理的异常。`throw;` 保留异常的原始堆栈跟踪，该跟踪存储在 `Exception.StackTrace` 属性中；`throw e;` 更新 `e` 的 `StackTrace` 属性。

```csharp
try
{
    Action ac = null;
    ac();
}
catch (Exception e)
{
    Console.WriteLine(e);
    throw e;  // line 信息更新
}
```

`throw` 表达式的结果没有类型，但是可以隐式转换为任意类型。`throw` 表达式只允许：
- 作为条件运算符 `? : ` 的第二或第三个操作数。
- 作为空合并运算符 `??` 的第二个操作数。
- 作为 Lambda 表达式或方法的表达式主体。
 
```csharp
class Person(string name)
{
    public string Name => name ?? throw new ArgumentNullException(nameof(name));
}
```

>---
#### try-catch

`try-catch` 语句处理在执行代码块期间可能发生的异常。将代码置于 `try` 块中可能发生异常的位置，使用 `catch` 子句指定要在相应的 `catch` 块中处理的异常的基类型。

可以提供多个 `catch` 子句，也可以为 `catch` 指定异常筛选器 `when`。可以在 `catch` 中使用 `throw` 语句重新引发异常。

```csharp
try
{
    // try do....
}
catch (ArgumentException e) when (e is ArgumentNullException || e is ArgumentOutOfRangeException)
{
    Console.WriteLine($"Processing failed: {e.Message}");
}
catch (OperationCanceledException)
{
    Console.WriteLine("Processing is cancelled.");
}
catch // 无筛选条件
{
    throw;  // 重新引发异常
}
```

如果异步函数中发生异常，则等待函数的结果时，它会传播到函数的调用方。如果迭代器方法中发生异常，则仅当迭代器前进到下一个元素时，它才会传播到调用方。

```csharp
await Run();

static async Task Run()
{
    try
    {
        Task<int> processing = ProcessAsync(-1);
        Console.WriteLine("Launched processing.");

        int result = await processing;
        Console.WriteLine($"Result: {result}.");
    }
    catch (ArgumentException e)
    {
        Console.WriteLine($"Processing failed: {e.Message}");
    }
    // Output:
    // Launched processing.
    // Processing failed: Input must be non-negative. (Parameter 'input')
}
static async Task<int> ProcessAsync(int input)
{
    if (input < 0)
    {
        throw new ArgumentOutOfRangeException(nameof(input), "Input must be non-negative.");
    }

    await Task.Delay(500);
    return input;
}
```

>---
#### try-finally

在 `try-finally` 语句中，当控件离开 `try` 块时，将执行 `finally` 块。控件可能会离开 `try` 块，由于 `try` 正常执行、或执行跳转语句、或发生异常。可以使用 `finally` 块来清理 `try` 块中使用的已分配资源。可以在 `finally` 块之前可选的使用 `catch` 块进行捕获异常处理。

```csharp
try
{
    int[] arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
    for (int i = 0; i <= arr.Length; i++)
        arr[i]++;
}
catch (ArgumentException e) when (e is ArgumentNullException || e is ArgumentOutOfRangeException)
{
    Console.WriteLine($"Processing failed: {e.Message}");
}
finally
{
    Console.WriteLine("Finally ...");
}
```

---
### 异常

C# 中的异常系统提供了一种结构化的、统一的、类型安全的方式来处理系统级和应用级的错误条件。

异常可以通过两种方式抛出：
- `throw` 语句无条件地抛出异常。控件永远不会到达紧随抛出之后的语句。
- C# 语句和表达式在处理过程中出现的某些异常情况，会导致在某些情况下无法正常完成操作。（例如，整数除法中的 0 除）。
  
公共语言运行时 CLR、.NET、第三方库和应用程序代码都可产生异常。.NET 中的托管异常在 Win32 结构化异常处理机制的基础之上实现。

```csharp
public class ExceptionTest
{
    static double SafeDivision(double x, double y)
    {
        if (y == 0)
            throw new DivideByZeroException();
        return x / y;
    }
    public static void Main()
    {
        double a = 98, b = 0;
        double result;
        try
        {
            result = SafeDivision(a, b);
            Console.WriteLine("{0} divided by {1} = {2}", a, b, result);
        }
        catch (DivideByZeroException)
        {
            Console.WriteLine("Attempted divide by zero.");  
        }
    }
}
```

>---
#### System.Exception

异常是最终全都派生自 `System.Exception` 的类型：
  - 调用堆栈状态：每个 `Exception` 对象都包含一个 `StackTrace` 字符串属性，包含当前调用堆栈上的方法的名称和引发异常的位置。
  - 错误文本说明：每个 `Exception` 对象都包含一个名为 `Message` 的属性，此字符串用来设置为解释发生异常的原因。
  - `InnerException`：它是 `Exception` 对象的只读属性。如果它非 `null`，则指向导致当前异常的异常（即，当前异常是处理 `InnerException` 的 `catch` 块中引发的）。否则，它的值为 `null`，表示其异常不是由其他异常引起的。以这种方式链接在一起的异常对象的数目是任意的。

可以在 `catch` 语句中捕捉查看这些异常。

```csharp
try
{
    ExceptionTest();
}
catch (NotImplementedException ex)
{
    Console.WriteLine($"EROOR : {ex.Message}\n" + ex.StackTrace);
}

void ExceptionTest() => throw new NotImplementedException();
```

>---
#### 异常处理

C# 语言的异常处理功能有助于处理在程序运行期间发生的任何意外或异常情况。异常处理功能使用 `try` 语句块来尝试执行可能失败的操作，并在捕获异常时在 `catch` 中处理故障，以及在操作结束后在 `finally` 中清除资源。异常是使用 `throw` 关键字创建而成的。

一般情况下，异常并不是由代码直接调用的方法抛出，而是由调用堆栈中再往下的另一个方法抛出。发生异常时，CLR 会展开堆栈，系统根据异常的运行时类型，搜索最近的可以处理该异常的 `catch` 子句。

首先，在当前方法中搜索包含 `try` 语句的词法，并按顺序考虑 `try` 语句的相关 `catch` 子句。如果失败，则搜索调用当前方法的方法，寻找包含当前方法调用点的词法封闭 `try` 语句。此搜索将继续进行，直到找到可以处理当前异常的 `catch` 子句。如果在调用堆栈中找不到相应的 `catch` 代码块，将会终止进程并向用户显示消息。没有命名异常类的 `catch` 子句可以处理任何异常。

一旦找到匹配的 `catch` 子句，系统就准备将控制转移到 `catch` 子句的第一个语句。在开始执行 `catch` 子句之前，系统首先按顺序执行与 `try` 语句相关的 `finally` 子句，这些语句嵌套程度比捕获异常的语句嵌套程度高：
- 在 `try` 中执行可能抛出异常的语句。程序使用 `throw` 关键字，用以显式生成异常。
- 在 `try` 中出现异常后，控制流会跳转到调用堆栈中任意位置上的首个相关异常处理程序（`catch`）。可以使用 `catch` 代码块末尾的 `throw` 关键字重新抛出异常。
- 若未找到给定异常对应的异常处理程序，那么程序会停止执行，并显示错误消息。
- 无论是否引发异常，`finally` 代码块中的代码仍会执行。使用 `finally` 代码块可释放资源。例如，关闭在 `try` 代码块中打开的任何流或文件。

```csharp
try
{
    // ..... do 
    string str = null;
    Console.WriteLine(str.ToLower());
}
catch (NullReferenceException ex1) 
{
    Console.WriteLine($"Arguement err : {ex1.Message}\n{ex1.StackTrace}");
}
catch
{
    throw;  // 重新抛出时，将异常传递给被调用方而不调用 finally
}
finally
{
    Console.WriteLine("Do Finally work...");
}
/*
    Arguement err : Object reference not set to an instance of an object.
        at Program.<Main>$(String[] args) in Program.cs:line 7
    Do Finally work...
*/
```

如果没有找到匹配的 `catch` 子句，则会发生以下三种情况之一：

- 如果对匹配 `catch` 子句的搜索到达静态构造函数或静态字段初始化式，则使用 `System.TypeInitializationException` 并在触发静态构造函数调用时抛出。`System.TypeInitializationException` 的 `InnerException` 包含最初抛出的异常。
- 如果异常存在于终结器内，将中止终结器，并调用基类终结器（如果有）。
- 如果搜索匹配的 `catch` 子句到达最初启动线程的代码，则终止线程的执行。这种终止的影响是由实现定义的。

>---
#### 重新引发异常

在 `catch` 块捕获的异常，可以通过一条单独的 `throw;` 语句重新抛出保留原始栈信息的异常。若使用 `throw` 抛出的是 `catch` 块中的具体异常，则会更新所有栈信息来匹配新的抛出位置。这会导致指示异常最初发生位置的栈信息丢失。

```csharp
class Sample
{
    static void Fun() => throw new NotImplementedException();
    static void Main(string[] args)
    {
        try
        {
            Fun();
        }
        catch (Exception e)
        {
            throw;
            //throw e;
        }
    } 
}
```

如何抛出现有异常而不替换栈信息？可以使用 `System.Runtime.ExceptionServices.ExceptionDispatchInfo` 类专门处理这种情况。

```csharp
using System.Runtime.ExceptionServices;
class ExceptionHandler
{
    public static void Capture(Exception ex, bool isThrow = false)
    {
        ExceptionDispatchInfo.Throw(ex);
        // or 
        var exInfo = ExceptionDispatchInfo.Capture(ex);
        if(isThrow)
            exInfo.Throw();
    }
}
class Sample
{
    static void Fun() => throw new NotImplementedException();
    static void Main(string[] args)
    {
        try
        {
            Fun();
        }
        catch (Exception e)
        {
            ExceptionHandler.Capture(e, true);
        }
    }
}
```

>---
#### 定义异常的类别

程序可以引发 `System` 命名空间中的预定义异常类（前面提到的情况除外），或通过从 `Exception` 派生来创建其自己的异常类。

派生类应该至少定义三个构造函数：一个无参数构造函数、一个用于设置消息属性，一个用于设置 `Message` 和 `InnerException` 属性。

```csharp
[Serializable]
public class InvalidDepartmentException : Exception
{
    public InvalidDepartmentException() : base() { }
    public InvalidDepartmentException(string message) : base(message) { }
    public InvalidDepartmentException(string message, Exception inner) : base(message, inner) { }
}
```

>---

#### 常见 .NET 异常类型

```csharp
ArithmeticException         // 算术运算期间出现的异常的基类，例如 DivideByZeroException 和 OverflowException。
ArgumentException           // 传递给方法的参数无效
ArgumentNullException       // 不应为 null 的参数传递了 null 值
ArrayTypeMismatchException	// 存储数组元素时，由于元素类型与数组类型不兼容引发。
ApplicationException        // 作为应用程序定义的异常的基类。
DivideByZeroException	    // 尝试将整数值除以零时引发。
FormatException             // 当参数的格式无效或复合格式字符串格式不正确时引发的异常。
IndexOutOfRangeException	// 索引小于零或超出数组边界时，尝试对数组编制索引时引发。
InvalidCastException	    // 从基类型显式转换为接口或派生类型在运行时失败时引发。
InvalidOperationException   // 当方法调用对于对象的当前状态无效时引发的异常。
NullReferenceException	    // 尝试引用值为 null 的对象时引发。
NotImplementedException     // 当请求的方法或操作未实现时引发的异常。 
OutOfMemoryException	    // 尝试使用新运算符分配内存失败时引发。 此异常表示可用于公共语言运行时的内存已用尽。
OverflowException	        // checked 上下文中的算术运算溢出时引发。
RuntimeBinderException      // 表示在处理 C# 运行时绑定中的动态绑定时发生的错误。
StackOverflowException	    // 执行堆栈由于有过多挂起的方法调用而用尽时引发；通常表示非常深的递归或无限递归。
TypeInitializationException	// 静态构造函数引发异常并且没有兼容的 catch 子句来捕获异常时引发。
```

>---
#### 捕捉非 CLS 异常

包括 C++/CLI 在内的某些 .NET 语言允许对象引发并非派生自 `Exception` 的异常，这类异常被称为非 CLS 异常或非异常。无法在 C# 中引发非 CLS 异常。可以在 `catch (RuntimeWrappedException ex)` 内捕获，通过 `RuntimeWrappedException.WrappedException` 属性访问原始异常。

如果为了响应非 CLS 异常需要执行某些操作（如写入日志文件），且无需访问异常信息时，请使用此方法。

```csharp
// Class library written in C++/CLI.
var myClass = new ThrowNonCLS.Class1();

try
{
    // throws gcnew System::String("I do not derive from System.Exception!");  
    myClass.TestThrow();
}
catch (System.Runtime.CompilerServices.RuntimeWrappedException e)
{
    String s = e.WrappedException as String;
    if (s != null)
        Console.WriteLine(s);
}
```

默认情况下，公共语言运行时包装所有异常。要禁用此行为，请将此程序集级别属性添加到代码中，通常位于 `AssemblyInfo.cs` 文件：

```csharp
[assembly: RuntimeCompatibilityAttribute(WrapNonExceptionThrows = false)];
```

---
### CSharp 特性

像类或成员的可访问性一样，C# 使用一种新的声明性信息，称为特性。可以将特性附加到各种程序实体，并在运行时环境中检索特性信息。

特性是通过特性类的声明来定义的，特性类可以有位置参数和命名参数。使用特性规范，将特性附加到 C# 程序中的实体上，并且可以在运行时作为特性实例进行检索。

>---

#### Attribute 类

直接或间接派生自抽象类 `System.Attribute` 的类被称为特性类。特性类的声明定义了一种可以在程序实体上的新特性。按照惯例，特性类以 `Attribute` 后缀命名，特性的使用可以包含或省略这个后缀。

从 C#11 开始可以声明泛型特性类。泛型特性类在标记程序成员时，必须是封闭类型（即需要提供具体类型参数）。

>---

#### 位置参数与命名参数

特性类具有位置参数和命名参数，特性类的每个公共构造函数都为该类定义了一个有效的位置参数序列。命名参数由特性类的非静态、公共和读写的字段或属性定义。

定义特性类时，可以在特性类上附加 `AttributeUsage` 来控制它的使用方式。

```csharp
[AttributeUsage(AttributeTargets.Class)]
public class AuthorAttribute(string name) : Attribute
{
    public string Name { get; } = name;  // name 位置参数初始化
    public string Version;  // 命名参数
}

[Author("Hello", Version = "1.0.0.0")]
class Sample;
```

特性类的位置参数和命名参数的类型仅限于：
- 以下类型之一：`bool`、`char`、`byte`、`sbyte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`float`、`double`、`object`、`System.Type`、枚举类型。
- 上述类型的一维数组。
- 非特性参数类型的构造函数参数或公共字段不能作为特性规范中的位置参数或命名参数。

位置参数或命名参数的特性参数值不能是类型参数或开放式泛型。`Type` 的特性参数可以是未绑定的泛型类型。

```csharp
class SampleAttribute(Type type) : Attribute
{
    public Type type { get; } = type;
}
class Example<T>
{
    [Sample(typeof(Example<T>))] int v1;   //err 
    [Sample(typeof(T))] int v2;   //err 

    [Sample(typeof(Example<int>))] int v4;   
    [Sample(typeof(Example<>))] int v3;   
}
```

>---

#### 特性规范

*特性规范* 是指将特性应用到程序元素的声明。特性是为声明指定的一段附加声明性信息。可以在全局范围内（在包含它的程序集或模块上）、类型声明、类型成员声明、属性或索引器访问器声明、事件访问器声明、形式参数列表的元素、类型参数列表的元素上指定特性。

```ANTLR
global_attributes
    : [ global_attribute_target : attribute_list ]+
global_attribute_target
    : assembly  
    | module  
    ;

attributes
    : [ <attribute_target :>? attribute_list ]+
attribute_target
    : field
    | event
    | method
    | param
    | property
    | return
    | type
    | typevar  
    ;
```

每个 `attribute` 由位置参数和命名参数的可选列表组成，位置参数在前，命名参数在后。

当特性放置在全局级别时，需要指定全局属性目标标识：
- `assembly`：特性的目标中包含程序集。
- `module`：特性的目标中包含模块。

其他标准化的特性目标包含 `event`、`field`、`method`、`param`、`property`、`return`、`type`、`typevar`。这些目标只能在以下上下文中使用：
- `event`：事件。
- `field`：字段、类似字段的事件、自动实现的属性。
- `method`：构造函数、终结器、方法、运算符、属性或索引器的访问器、事件的访问器、类似字段的事件。
- `param`：属性或索引器的 `set` 访问器、事件的访问器、构造函数参数、方法参数、运算符参数。
- `property`：属性、索引器。
- `return`：委托、方法、运算符、属性或索引器的 `get` 访问器。
- `type`：委托、类、结构、枚举和接口。
- `typevar`：类型参数。

某些上下文允许在多个目标上指定一个属性，程序可以通过包含 `attribute_target` 显式地指定目标。如果没有指定特性目标，则使用默认值。例如，对于委托声明上的特性，默认目标是委托。否则，当目标是 `method`，则是委托；当目标是 `return` 则是委托的返回值。

程序元素的默认特性目标以及可以显式指定的目标声明：
- 委托默认是委托本身 `type`，可以指定 `type`、`return`。
- 方法默认是方法本身 `method`，可以指定 `method`、`return`。
- 运算符默认是运算符本身 `method`，可以指定 `method`、`return`。
- `get` 访问器默认是关联的方法 `method`，可以指定 `method`、`return`。
- `set` 访问器默认是关联的方法 `method`，可以指定 `method`、`param`。
- 自动实现的属性默认是属性 `property`，可以指定 `property`、`field`。其他属性的默认仅是 `property`。
- 字段事件默认是事件本身 `event`，可以指定 `method`、`event`、`field`。有访问器的事件默认仅是 `event`。
- 事件的访问器默认是关联的方法 `method`，可以指定 `method`、`return`、`param`。

不兼容的特性目标将会被忽略。

```csharp
[AttributeUsage(AttributeTargets.All)]
public class TargetAttribute : Attribute;

[type: Target]
class Sample<[typevar: Target] T> where T : notnull
{
    [field: Target] public T AutoValue { get; }

    public T Value
    {
        [return: Target]
        get => default!;
        [param: Target]
        set { }
    }

    [field: Target] event Action fieldEvent;

    event Action accessorEvent
    {
        [return: Target]
        add { }
        [method: Target]
        remove { }
    }
}
```

按照惯例，特性类的命名以 `Attribute` 作为后缀。使用特性时，后缀 `Attribute` 可以包含或省略。当特性名称前附加 `@` 时，无后缀的名称可能无法被编译器识别，编译器会将该命名视为 *type_name* 并查找完整名称下的特性类。

```csharp
class SampleAttribute : Attribute;

[Sample] 
class ExampleA;  // refer to SampleAttribute

[SampleAttribute] 
class ExampleB;  // refer to SampleAttribute

[@Sample] 
class ExampleC;  // err: no attribute
```

如果一个特性类省略后缀的名称是一个类型或另一个特性类（未使用命名惯例），则会发生歧义。此时 `@` 逐字标识会很有用。

```csharp
class Sample : Attribute;
class SampleAttribute : Attribute;

[Sample] 
class ExampleA;  // 歧义

[SampleAttribute] 
class ExampleB;  // refer to SampleAttribute

[@Sample] 
class ExampleC;  // refer to Sample

[@SampleAttribute] 
class ExampleD;  // refer to SampleAttribute
```

>---

#### 特性实例

特性实例是在运行时表示特性的实例。一个特性由特性类、位置参数和命名参数定义。特性实例是使用位置参数和命名参数初始化的特性类的实例。特性实例的检索涉及编译时和运行时处理。

> *特性的编译*

编译一个在程序实体 `E` 上指定的特性，包含一个特性类 `T`、位置参数列表 `P` 和命名参数列表 `N`，通过以下步骤编译成程序集 `A`：
- 按照编译时处理步骤编译形式为 `new T(P)` 的对象创建表达式。这些步骤要么导致编译时错误，要么确定可以在运行时调用的实例构造函数 `C`。
- 如果 `C` 没有公共可访问性，则会发生编译时错误。
- 对于命名参数列表的每个参数 `Arg`，在特性类 `T` 中查找以 `Arg` 的标识符为名称的非静态公共的读写属性或字段。若未找到，则发生编译时错误。
- 如果位置参数列表或命名参数列表中的某个参数的类型是 `string`，并且参数的值不是 Unicode 标准定义的格式良好的，则编译的值是否等于检索的运行时值是实现定义的。例如，一个字符串如果包含高代理的 UTF-16 代码单元，而后面没有紧跟一个代理的代码单元，那么这个字符串就不是格式良好的。
- 将以下信息（用于特性的运行时实例化）作为编译包含该特性的程序的结果存储在编译器的汇编输出中：特性类 `T`、`T` 上的实例构造函数 `C`、位置参数列表 `P`、命名参数列表 `N` 和相关的程序实体 `E`，其值在编译时完全解析。

> *运行时检索特性实例*

由 `T`、`C`、`P`、`N` 表示并与 `E` 相关联的特性实例可以在运行时通过以下步骤从程序集 `A` 中检索：
- 遵循执行 `new T(P)` 的形式的对象构造表达式的运行时处理步骤，使用实例构造函数 `C` 和编译时确定的值。这些步骤要么导致异常，要么产生 `T` 的实例 `O`。
- 对于 `N` 中的每个参数 `Arg`，按顺序：
  - 使用 `Arg` 的标识符 `Name`，在 `O` 上查找标识为 `Name` 的非静态公共读写字段或属性，并将 `Arg` 的值赋值查找的结果。若未查找到这样名称的字段或属性，则抛出异常。
  - 结果是特性类 `T` 的一个实例 `O`，且使用 `N` 和 `P` 进行初始化。 

```csharp
[AttributeUsage(AttributeTargets.Class)]
public class HelpAttribute(string url) : Attribute
{
    public string Topic { get; set; }
    public string Url { get; } = url;
}

[Help("https://github.com/dotnet", Topic = "Help")]
public sealed class InterrogateHelpUrls
{
    public static void Main(string[] args)
    {
        Type helpType = typeof(HelpAttribute);

        var attributes = typeof(InterrogateHelpUrls).GetCustomAttributes(helpType, false);
        var helpers = (HelpAttribute[])attributes;
        foreach (var helper in helpers)
        {
            Console.WriteLine($"Url : {helper.Url}");
            Console.WriteLine($"Topic : {helper.Topic}");
        }
    }
}
```



---
### 自动内存管理

C# 采用自动内存管理，使开发人员无手动分配和释放由对象占用的内存。自动内存管理策略是由 *垃圾回收器* 实现的。对象的内存管理生命周期如下所示：
  1. 创建对象时，将为其分配内存，运行构造函数，并将对象视为实时对象。
  2. 如果对象及其任何部分不能通过任何可能的执行继续访问（除了运行终结器），则该对象被视为不再使用，并可用于终结回收。C# 编译器和垃圾回收器可以选择对代码进行分析，以确定将来可能会使用哪些对对象的引用。如果作用域中的局部变量是唯一的对象引用，并且从当前执行点开始的任何可能的执行中都不会引用该本地变量，则垃圾回收器可能（但不必需）将该对象视为不再使用。
  3. 一旦对象符合销毁条件，在稍后某个未指定的时间运行对象的终结器（如果有）。正常情况下，对象的析构函数只运行一次，尽管特定于实现的 Api 可能会允许重写此行为。
  4. 一旦对象的终结器运行，如果该对象及其任何部分不能通过任何可能的执行继续进行访问（包括运行终结器），则该对象将被视为不可访问且认为该对象符合回收条件。
  5. 最后，在对象变为符合收集条件后的某个时间，垃圾回收器将释放与该对象关联的内存。

垃圾回收器维护有关对象使用情况的信息，并使用这些信息做出内存管理决策，如在内存中定位新创建的对象的位置，何时重新定位对象以及何时不再使用或不可访问对象。

可以通过 `System.GC` 类上的静态方法控制垃圾回收器的行为，此类可用于请求进行收集，运行（或不运行）终结器。由于垃圾收集器在决定何时收集对象和运行终结器方面有很大的自由度，因此符合标准的实现可能产生与以下代码显示的输出不同的输出：

```csharp
class Sample
{
    unsafe static void Main(string[] args)
    {
        int i = 0;
        do
        {
            Sample s = new Sample();
            s.CreateGC(100000);
            Task.Delay(200).GetAwaiter().GetResult();
            GC.Collect();
            GC.WaitForPendingFinalizers();
        } while (i++ < 10);
    }
    static nint Ps;
    static nint LastPs;

   async void CreateGC(int size)
    {
        await Task.Delay(1);
        int[] arr = new int[size];
        for (int i = 0; i < arr.Length; i++)
            arr[i] = i;
    }
    ~Sample() => Console.WriteLine("Finalizer Invoked");
}
```

通常情况下，终结器只对存储在其自身字段中的数据执行清理，而不对引用的对象或静态字段执行任何操作。使用终结器的替代方法是让类实现 `System.IDisposable` 接口，这使得对象的客户端可以确定何时释放对象的资源，通常是通过将对象作为 `using` 语句中的资源来访问。

```csharp
protected void Defer() 
{
   using var sr = new System.IO.StringReader("Hello World");
} // > call sr.Dispose()
```




---
### 预处理指令

预处理指令提供了有条件地跳过部分编译单元、报告错误和警告条件以及描述源代码的不同区域的能力。不同于 C，在 C# 中，没有单独的预处理步骤，预处理指令作为词法分析阶段的一部分进行处理。可用的预处理指令有：

- `#define`、`#undef`：分别用于定义和取消定义条件编译符号。
- `#if`、`#elif`、`else`、`endif`：使用条件编译符号以指示在源代码中的哪些部分可以有条件地跳过。
- `#error`：用于发出错误。
- `#warning`：用于发出警告。
- `#region`、`endregion`：用于显式标记或折叠源代码的某些部分。
- `#line`：用于控制错误和警告发出的行号。
- `#nullable`：用于控制可为空注释上下文和可为空警告上下文。
- `#pragma`：用于向编译器指定可选的上下文信息。

>---
#### 条件编译


`#if`、`#elif`、`#else` 和 `#endif` 条件编译指令根据当前的条件编译符号有条件地包含或排除源文件的某些部分。条件编译符号存在 `defined` 和 `undefined` 两种状态。

使用 `#define` 指令来定义条件编译符号；`#undef` 指令来取消定义条件编译符号。它们仅对当前编译单元有效。

预处理表达式可以出现在 `#if` 和 `#elif` 指令中，表达式可以使用 `!`、`==`、`!=`、`&&`、`||` 操作符，括号用以分组。表达式求值总是产生一个布尔值，仅可以引用的是条件编译符号和布尔字面值。


```csharp
#define MYTEST
using System;
public class MyClass
{
    static void Main()
    {
#if DEBUG == true
        Console.WriteLine("DEBUG is defined");
#elif (!DEBUG && MYTEST)
        Console.WriteLine("MYTEST is defined");
#elif (DEBUG && MYTEST)
        Console.WriteLine("DEBUG and MYTEST are defined");
#else
        Console.WriteLine("DEBUG and MYTEST are not defined");
#endif
    }
}
```

> `<DefineConstants>`

可以通过 `DefineConstants` 编译器选项来定义项目级别的符号，作用于整个项目域，优先级低于在编译单元内通过 `#define` 定义的条件编译符。在当前编译单元范围中，可以通过 `#undef` 取消定义符号，取消定义的作用域仅限于当前声明的编译单元内。

可以使用 `ConditionalAttribute` 来执行条件编译。可以使用 `#define` 定义的符号，也可以是编译器选项设置的符号。`ConditionalAttribute` 仅对特性类或 `void` 方法有效。未定义符号的条件方法或条件特性在编译时，编译器在其所有调用点删除调用。


```xml
<DefineConstants>CONDITION1</DefineConstants>
```
```csharp
#define CONDITION2
using System.Diagnostics;

class Test
{
    static void Main()
    {
        Console.WriteLine("Calling Method1");
        Method1(3);
        Console.WriteLine("Calling Method2");
        Method2();

        Console.WriteLine("Using the Debug class");
        Trace.Listeners.Add(new ConsoleTraceListener());
        Debug.WriteLine("DEBUG is defined");
    }

    [Conditional("CONDITION1")] 
    public static void Method1(int x) => Console.WriteLine("CONDITION1 is defined");
    [Conditional("CONDITION1"), Conditional("CONDITION2")]
    public static void Method2() => Console.WriteLine("CONDITION1 or CONDITION2 is defined");
}
```

>---
#### 诊断指令

诊断指令用于显式生成错误和警告消息，其报告方式与其他编译时错误和警告的方式相同。
- `#warning` 使用指定的消息生成编译器警告。
- `#error` 使用指定的消息生成编译器错误。

```csharp
#warning Code review needed before check-in
#if Debug && Retail
    #error A build can't be both debug and retail
#endif

class Test {...}
```

>---
#### 区域指令

区域指令用于显式标记源代码区域。可以使用 `#region` 和 `#endregion` 预处理器指令来标记可折叠的源代码区域。

```csharp
#region MyClass definition 
public class MyClass
{
    static void Main()
    {
    }
}
#endregion 
```

>---
#### 行指令

行指令可用于更改编译器在输出（如警告和错误）中报告的行号和源文件名，这些信息也被调用者信息属性使用。借助 `#line`，可修改编译器的行号及（可选）用于错误和警告的文件名输出。

```csharp
class MainClass
{
    static void Main()
    {
#line 200 "Special"
        int i;
        int j;
#line default
        char c;
        float f;
#line hidden // numbering not affected
        string s;
        double d;
    }
}
/*
Special(200,13): warning CS0168: The variable 'i' is declared but never used
Special(201,13): warning CS0168: The variable 'j' is declared but never used
MainClass.cs(9,14): warning CS0168: The variable 'c' is declared but never used
MainClass.cs(10,15): warning CS0168: The variable 'f' is declared but never used
MainClass.cs(12,16): warning CS0168: The variable 's' is declared but never used
MainClass.cs(13,16): warning CS0168: The variable 'd' is declared but never used
*/
```

> 行指令语法

- `#line num filename` 指示下一行的行号强制设为 `num`，在下一个 `#line` 指令前，文件名都会报告为 `filename`。
- `#line filename` 指令可指定要在编译器输出中显示的文件名。默认情况下，将使用源代码文件的实际名称。文件名必须在行号之后。
- `#line default` 指令将行号恢复至默认行号，并对上一指令重新编号的行进行计数。
- `#line hidden` 指令能对调试程序隐藏连续行，当开发者逐行执行调试代码时，介于 `#line hidden` 和下一 `#line` 指令（假设它不是其他 `#line hidden` 指令）间的任何行都将被跳过。`#line hidden` 指令不影响错误报告中的文件名或行号。 

> C#10 `#line` 指令拓展

```csharp
#line (1, 1) - (5, 60) 10 "partial-class.cs"
/*34567*/int b = 0;
```

- `(1, 1)`：指令后面行上的第一个字符的起始行和列。
- `(5, 60)`：标记区域的结束行和列。
- `10`：将使 `#line` 指令生效的列偏移量。
- `"partial-class.cs"`：输出文件的名称。

>---
#### 可空上下文设置指令

`#nullable` 预处理器指令将设置可为空注释上下文和可为空警告上下文。此指令控制是否可为空注释是否有效（引用类型的 `?` 注释），以及是否给出为 `Null` 性警告。

可在项目级别设置 `<Nullable>`，预处理器指令 `#nullable` 优先于项目级设置，用于设置其控制的上下文，直到另一个 `#nullable` 替代它，或到源文件的末尾。

```csharp
#nullable disable      // 将可为空注释和警告上下文设置为“已禁用”。
#nullable enable       // 将可为空注释和警告上下文设置为“已启用”。
#nullable restore      // 将可为空注释和警告上下文还原为项目设置。
#nullable disable annotations   // 将可为空注释上下文设置为“已禁用”。
#nullable enable annotations    // 将可为空注释上下文设置为“已启用”。
#nullable restore annotations   // 将可为空注释上下文还原为项目设置。
#nullable disable warnings      // 将可为空警告上下文设置为“已禁用”。
#nullable enable warnings       // 将可为空警告上下文设置为“已启用”。
#nullable restore warnings      // 将可为空警告上下文还原为项目设置。
```

>---
#### 编译指示指令

`#pragma` 预处理指令用于指定编译器的可选上下文信息。`#pragma` 为编译器给出特殊指令以编译它所在的文件，这些指令必须受编译器支持。语法：`#pragma pragma-name pragma-arguments`。
  
> `#pragma warning`

- `#pragma warning` 可以启用或禁用特定警告。

```csharp
#pragma warning disable warning-list    // 禁用
#pragma warning restore warning-list    // 启用
```

- `warning-list` 是以逗号分隔的警告编号的列表。

```csharp
using System;

#pragma warning disable 414, CS3021  // CS 前缀可选，禁用
[CLSCompliant(false)]
public class C
{
    int i = 1;
    static void Main(){}
}
#pragma warning restore CS3021  // 启用
[CLSCompliant(false)]  // CS3021
public class D
{
    int i = 1;
    public static void F(){}
}
```

> `#pragma checksum`

- `#pragma checksum`：生成校验和。

```csharp
#pragma checksum "filename" "{guid}" "checksum bytes"
```

- `filename` 是需要监视更改或更新的文件的名称，`guid` 是哈希算法的全局唯一标识符 GUID，`checksum bytes` 是表示校验和字节的十六进制数字的字符串（偶数个）。
- Visual Studio 调试器使用校验和确保它可始终找到正确的源。编译器为源文件计算校验和，然后将输出发出到程序数据库 PDB 文件。调试器随后使用 PDB 针对它为源文件计算的校验和进行比较。
- 如果编译器在文件中没有找到 `#pragma checksum` 指令，它将计算校验和，并将该值写入 PDB 文件。

---