## C# 安全规则规范



---
### 安全机制

在编译时，编译器将表达式允许转义到哪个作用域的概念与每个表达式关联起来，被称为 *safe-to-escape* 安全转义。类似地，对于每个左值 *Lvalue*，编译器把允许对 *Lvalue* 的引用（`ref`）转义到哪个作用域的概念，称之为 *ref-safe-to-escape*。对于给定的左值表达式，它们的引用安全转义范围有所不同。

基本的安全机制执行指出：给定从具有安全转义范围 `S1` 的表达式 `E1` 到具有安全转义范围 `S2` 的左值表达式 `E2` 的赋值过程 `E2 = E1`，如果 `S2` 的作用域范围大于 `S1`，则无法保证安全地通过赋值操作进行 `E1` 到 `E2` 的转义。对于引用转义同样如此。通过构造，两个作用域 `S1` 和 `S2` 处于嵌套关系，因为合法表达式总是可以从封闭该表达式式的作用域安全返回（*safe-to-return*）。

---
### safe-to-escape & ref-safe-to-escape 

*safe-to-escape* 表示一个范围，它包含一个表达式，值可以安全地转义到该表达式。如果这个范围是整个方法，则从该方法返回的值是安全的。不是 `ref struct` 类型的表达式始终可以从执行方法结束时安全返回。

*ref-safe-to-escape* 表示一个范围，它包含一个左值 *Lvalue* 表达式，对于要转义的 *Lvalue* 的引用 `ref` 值来说，转义到该范围是安全的。如果该作用域是整个方法，则可以安全地从该方法返回对 *Lvalue* 的引用。

编译器通过追踪计算每个值的 *safe-to-escape* 范围和对值的引用 *ref-safe-to-escape* 范围来防止对无效内存位置的访问而导致的意外泄漏。这些安全转义范围定义了一个值可以安全转义的最大范围。若违反了这个安全范围约束，编译器会发出诊断错误。常见的作用域范围有 *current method*、*calling method*、*return only*：
- 具有 *calling method* 安全转义范围的值允许在程序的任何地方转义，可以将该值作为方法返回、或分配给某个右值、或作为参数传递给其他方法。
- 具有 *return only* 安全转义范围的值只能通过 `return` 语句返回、或赋值给 `out` 参数从当前方法进行转义。
- 具有 *current method* 安全转义范围的值不允许从当前方法的堆栈外转义。   

对于大多数的常规值，其安全转义范围为 *calling method*，它几乎允许被返回一个值给调用方（包含 `out` 传递），或将该值分配给某个字段。某些类型的值仅在当前执行方法的堆栈中有效（`Span<T>` 等 `ref struct` 类型，`stackalloc` 表达式，`scoped` 变量或参数等）。

对于赋值操作 `x = y`，编译器会检查左值的 *safe-to-escape* 是否小于等于右值的安全转义范围；对于 `= ref` 赋值，编译器将检查左值的 *ref-safe-context* 是否小于等于右值的引用安全转义范围；对于方法返回 `return expr`，`expr` 至少为 *return only* 的安全转义范围；对于 `return ref expr`，`expr`至少为 *return only* 的引用转义范围。

> safe-to-escape

```csharp
ref struct Sample
{
    int Value { get; set; }
    Span<int> Span { get; set; }

    // safe-to-escape of 'x' is "calling method" hence the 'x' is allowed to 'escape' the current method:
    static int CallerContext_Example(Sample c)
    {
        var x = 123;
        c.Value = x; 
        return x;
    }

    // safe-to-escape of 'x' is "current method" hence the 'x' is not allowed to 'escape' the current method:
    static Span<int> FunctionMember_Example(Sample s)
    {
        Span<int> x = stackalloc[] { 1, 2, 3 }; // implicit scoped
        s.Span = x; // ERR
        return x;  // ERR
    }
}
```

> ref-safe-to-escape

```csharp
ref struct Sample
{
    ref int refValue;
    Span<int> Span { get; set; }

    // References passed in as fields on ref-struct parameters have ref-safe-to-escape of "calling method".
    // This makes sense because clearly the references ALREADY exist outside this method, they were set when they were passed in.
    static ref int CallingMethodExample(Sample s1, Sample s2)
    {
        s2.refValue = ref s1.refValue;  // 'ref s1.Value' has a ref-safe-to-escape of "calling method", so this is permitted
        return ref s1.refValue;  // 'ref s1.Value' has a ref-safe-to-escape of "calling method", so this is permitted
    }

    // References passed in directly to methods as parameters have ref-safe-to-escape of "return only".
    // "return only" lies somewhere inbetween "current method" and "calling method" -- the ref is allowed
    // to escape the current method but ONLY via return statement.
    static ref int ReturnOnlyExample(ref int x, Sample s)
    {
        s.refValue = ref x; // ERR: 'ref x' has a ref-safe-to-escape of "return only", so this does not compile
        return ref x; // 'ref x' has a ref-safe-to-escape of "return only", so this is permitted
    }

    // References to stack variables will always have a ref-safe-to-escape scope of "current method"
    // (meaning those references can exist only within the current method but may not escape any further).
    static ref int CurrentMethodExample(Sample s, scoped ref int rv)
    {
        var x = 123;
        s.refValue = ref x;

        return ref x; // ERR: 'ref x' has a ref-safe-to-escape of "current method",
                      // which means the reference is NOT allowed to escape OUTSIDE the current method, so this does not compile
    }
}
```

*Lvalue* 表达式的 *ref-safe-to-escape* 范围永远不能大于相同值的 *safe-to-escape* 范围。这意味着当规范限制值的 *safe-to-escape* 时，它也隐式地限制了*ref-safe-to-escape*。但 *ref-safe-to-escape* 的范围可以小于 *safe-to-escape*。例如一个非 `ref` 局部变量可以 *safe-to-escape* 到方法外部，但只能 *ref-safe-to-escape* 到方法内部。

---
### safe-context & ref-safe-context

> ECMA 对先前 C# 规范中 *safe-to-escape* 更名为 *safe-context*，*ref-safe-to-escape* 更名为 *ref-safe-context*。一个值的安全上下文可分为 *declaration-block* 声明块、*function-member* 函数域、*return-only* 仅返回、*caller-context* 调用方，自声明块（最窄）到调用方（最宽）。函数成员（方法、属性、索引器、构造函数、实例构造函数、运算符等）返回的安全上下文应至少为 *return-only*。
> 
> *calling method* 等效于 *caller-context*，*safe-to-return* 等效于 *caller-context*，*current method* 等效于 *function-member*。

在安全的上下文中，每个值的 *safe-context* 记录了该值可以安全转义的作用域，每个值的引用 *ref-safe-context* 记录了该值的引用可以安全转义的作用域。编译器通过对程序文本的静态分析来确定值的 *safe-context*（反映了变量在运行时的生存期）和值引用的 *ref-safe-context*（反映了变量引用在运行时的生存期）。有以下类别的安全上下文：
- 具有 *caller-context* 的值（引用）可以在程序中的任何地方转义，例如作为返回值 `return`（`return ref`）、分配给某个字段或作为实参传递给其他方法（`= ref`）等。类型不是 `ref struct` 的表达式总是具有 *caller-context* 的 *safe-context*。 
  
- 具有 *return-only* 的变量，可以通过方法返回或通过 `out` 参数传递到调用方。

- 具有 *function-member* 的变量不允许从当前执行方法转义到调用方。

- *declaration-block* 指的是在块中声明的局部变量的作用域，以及该作用域中的任何嵌套嵌入语句。局部变量（未被捕获而被提升）的生存期在声明块结束处终止。对局部变量的引用的 *ref-safe-context* 是该局部变量的作用域。只有当引用变量在该变量的 *ref-safe-context* 中声明时，对局部变量的引用才是引用变量的有效引用。

对于任何变量，该变量的 *ref-safe-context* 是对该变量引用的有效上下文。所有引用变量都遵循安全规则，以确保引用变量本身的 *ref-safe-context* 不大于其变量值的 *ref-safe-context*。一个值的 *ref-safe-context* 永远不会大于其 *safe-context*。

>---
#### return-only

C#11 规范设计中要求引入一个新的安全上下文：*return-only* 仅返回。它类似于 *caller-context*，因为它可以通过返回转义，但它只能通过 `return` 语句返回。

*return-only* 设计的一个细节是，它是一个比 *function-member* 宽，但比 *caller-context* 窄的上下文类别。`return` 语句的表达式必须至少是 *return-only*。因此，大多数现有的规则都会失效。例如，从具有 *return-only* 的 *safe-context* 表达式赋值到 `ref` 参数将失败，因为它比 `ref` 形参的 *safe-context*（*caller-context*）窄。

有三个位置的参数默认为 *return-only*：
- `ref`、`in` 参数具有一个 *return-only* 的 *ref-safe-context*。

  ```csharp
  ref readonly int Fun1(ref int v1, in int v2) // ref-safe-context is return-only
  {
      Span<int> rS1;   // ref struct 在未初始化的声明点的 safe-context 是 caller-context
      ReadOnlySpan<int> roS1; // ref struct 在未初始化的声明点的 safe-context 是 caller-context
  
      rS1 = new Span<int>(ref v1);          // err: return-only to caller-context
      roS1 = new ReadOnlySpan<int>(in v2);  // err: return-only to caller-context
  
      Span<int> rS2 = new Span<int>(ref v1);   // okay: rS2 is return-only
      ReadOnlySpan<int> roS2 = new ReadOnlySpan<int>(in v2);  // okay: rS2 is return-only
  
      return ref v1;  // okay
      return ref v2;  // okay
  }
  ```

- `ref struct` 类型的 `out` 形参将具有 *return-only* 的 *safe-context*。这允许 `return` 和 `out` 具有相同的效益。由于 `out` 是 `scoped` 作用域，所以 *ref-safe-context* 仍然比 *safe-context* 窄。

  ```csharp
  Span<int> Fun2(out Span<int> S, out Span<int> S2, ref Span<int> S3 /* safe-context is caller-context */)
  {
      S = default;
  
      S2 = S;  // okay // safe-context: return-only to return-only
  
      S3 = S;  // err  // safe-context: return-only to caller-context
  
      Span<int> rS;  // ref struct 在未初始化的声明点的 safe-context 是 caller-context
      rS = S;  // err  // safe-context: return-only to caller-context
  
      Span<int> rS2 = S;  // ref struct 在声明时具有和初始化项相同的 safe-context: return-only
      rS = rS2; // err
  
      return S;  // return-only
      return rS2;  // return-only
  }
  ```

- 结构实例构造函数中的 `this` 具有 *return-only* 的 *safe-context*。`this` 在结构的实例构造函数中被视为 `out` 参数（在结构实例方法中则被视为 `scoped ref` 形参）。

  ```csharp
  ref struct Sample
  {
      public Sample(out Sample outS /* safe-context: caller-context*/, 
                    ref Sample refS /* safe-context: caller-context*/)
      {
          refS = this; // err: The safe-context of this is return-only
          
          outS = this; // okay
      }
  }
  ```


任何赋值给 `out` 参数的表达式必需至少具有 *return-only* 的 *safe-context*。类型不是 `ref struct` 类型的表达式总是具有一个 *caller-context* 的 *safe-context*。

```csharp
void Fun(out int oV /* safe-context is caller-context */, 
        out Span<int> oS /* safe-context is return-only */)
{
    oV = 10010; // expr is caller-context 
    oS = stackalloc int[10]; // err: function-member < return-only
    oS = default; // okay: safe-context of default is caller-context
}
```

>---
#### scoped 作用域修饰符

关键字 `scoped` 将用于限制变量值的生存期。它可以作用于引用传递参数、`ref` 局部变量、`ref struct` 的参数或局部变量，并且具有将 *ref-safe-context* 或 *safe-context* 的生存期限制为 *function-member* 当前方法。例如：

| Parameter or Local       | ref-safe-context  | safe-context      |
| ------------------------ | ----------------- | ----------------- |
| `Span<int> s`            | *function-member* | *caller-context*  |
| `scoped Span<int> s`     | *function-member* | *function-member* |
| `ref Span<int> s`        | *caller-context*  | *caller-context*  |
| `scoped ref Span<int> s` | *function-member* | *caller-context*  |

在这种关系中，一个值的 *ref-safe-context* 永远不会比它的 *safe-context* 更宽。函数成员的 `out` 参数或结构的实例方法中的 `this` 被视为隐式声明的 `scoped ref`。   

```csharp
class Sample
{
    // ref-safe-context of 'ref parameter' is caller-context
    //Span<int> CreateSpan(ref int parameter) => default;

    // ref-safe-context of 'scoped ref parameter' is function-member
    Span<int> CreateSpan(scoped ref int parameter) => default;
    // the implementation of this method isn't relevant to callers.
    
    Span<int> BadUseExamples(int parameter)
    // ref-safe-context of parameter is function-member
    {
        // Legal in C# 10 and legal in C# 11 due to scoped ref
        return CreateSpan(ref parameter);

        // Legal in C# 10 and legal in C# 11 due to scoped ref
        int local = 42; // 
        return CreateSpan(ref local);

        // Legal in C# 10 and legal in C# 11 due to scoped ref
        Span<int> span = stackalloc int[42];
        return CreateSpan(ref span[0]);
    }
}
```

扩展方法中 `this` 修饰的 `ref` 结构类型参数可以声明为 `scoped ref T`。

```csharp
static class Ext
{
    //  ref-safe-context of 'this scoped ref s' is function-member.
    public static ref Sample Fun(this scoped ref Sample s) => ref s; // err

    // ref-safe-context of 'this ref s' is return-only.
    public static ref Sample Fun2(this ref Sample s) => ref s;
}
```

`scoped` 将 `ref struct` 局部变量的 *safe-context* 或 `ref` 局部变量的 *ref-safe-context* 限制为 *function-member*，而忽略初始化项的生存期。

```csharp
Span<int> ScopedLocalExamples()
{
    // Okay: default 表达式的 safe-context 是 *caller-context*，因此 span1 具有相同的安全上下文
    Span<int> span1 = default;
    return span1;

    // Error: `span2` 是 *function-member*. 即使 default 表达式是 *caller-context*
    // span2 的安全上下文被 scoped 声明限制为 *function-member*
    scoped Span<int> span2 = default;
    return span2;  // function-member < caller-context

    // stackalloc 表达式的 safe-context 是 *function-member*, span3 的 safe-context 是 *function-member*
    // 因此 `span3` 与 `span4` 在声明上是等效的
    Span<int> span3 = stackalloc int[42];
    scoped Span<int> span4 = stackalloc int[42];
    return span3;  // function-member < caller-context
}
```

`scoped` 作用域修饰符不能用于修饰返回值、字段、数组元素等。`scoped` 可以影响任意的 `ref`、`in` 参数、`ref` 局部变量、类型是 `ref struct` 的参数或局部变量。非 `ref struct` 的值总是可以安全返回的。`out` 参数被视为隐式 `scoped ref`。

```csharp
interface ISample
{
    void Fun1(scoped in int v1, scoped out int v2);
    void Fun2(scoped ref int v1, scoped Span<int> s);
    void Fun3(scoped int v); // Error: CS9048
}
```

方法的 `out` 参数、结构类型实例方法的 `this` 变量（包含其他实例成员）被隐式的声明为 `scoped`，因此它们不能通过 `return ref` 转义。

```csharp
using System.Diagnostics.CodeAnalysis;
struct Sample
{
    ref int Fun(out int i) // 'out int i' 相等于 'scoped out int is'
    {
        i = 10010;
        return ref i;  // Error, function-member
    }

    ref Sample refThis() => ref this; // Error, function-member
}
```

> ScopedRef 特性

包含 `scoped` 注释的参数将通过特性 `ScopedRefAttribute` 发送到元数据中。该特性由编译器使用并生成，在编译单元中无法使用。编译器将对带 `scoped` 语法的参数发出此属性。只有当语法导致值与其默认状态不同时，才会触发此行为。例如，`scoped out` 将不发出任何特性。

>---
#### UnscopedRef 特性

可以为结构实例方法、结构实例属性（不能是 `init` 属性）、引用传递的参数标记 `UnscopedRefAttribute` 特性，以提供与 `scoped` 注释相反的注释，这可以应用于任何 `ref`，并将标记对象的 *ref-safe-context* 更改为比默认值更宽的一级。例如：
- 如果应用于结构的实例方法或属性，`[UnscopedRef]` 将修改隐式 `scoped ref this` 参数的 *ref-safe-context* 为 *return-only*。
  
  ```csharp
  ref struct RSample
  {
      int value;
      [UnscopedRef] ref int Value => ref this.value;
      [UnscopedRef] ref RSample This => ref this;
      public void Fun(ref RSample s)
      {
          s = ref this; // err; ref this is function-member
      }
  }
  ```

- 如果应用于 `ref`、`in` 参数，它将修改参数的 *ref-safe-context* 为 *caller-context*。默认是 *return-only*。

  ```csharp
  ref struct RSample
  {
      public RSample(ref int v1, in int v2) { }
      public static RSample Create(ref int v, in int v2)
      {
          return new RSample(ref v, in v2);  // return-only
      }
      public static ref RSample UnscopedRefCreate(ref RSample rs, [UnscopedRef] ref int v, [UnscopedRef] in int v2)
      {
          rs = Create(ref v, in v2); // UnscopedRef
          return ref rs;  // return-only
      }
  }
  ```

- 如果应用于 `out` 参数，它将修改参数的 *ref-safe-context* 为 *return-only*。默认是隐式的 `scoped`（*function-member*）。

  ```csharp
  ref struct RSample
  {
      public ref int Fun(out int v)
      {
          v = 10010;
          return ref v;  // err: function-member
      }
      public ref int Fun1([UnscopedRef] out int v)  // return-only
      {
          v = 10010;
          return ref v;
      }
  }
  ```


`UnscopedRef` 特性不能用于：
- 非结构体上声明的成员。
- 结构体的静态成员、`init` 属性、构造函数。
- 标记为 `scoped` 的参数、值参数。
- 没有隐式作用域（即 *caller-context*）的引用传递参数。

---
### 变量与方法返回的安全分配原则
#### 赋值操作与方法返回

对于变量的分配操作 `e1 = e2`，`e2` 的 *safe-context* 范围至少要和 `e1` 的 *safe-context* 范围一样大。

```csharp
class Sample
{
    void Fun(out Span<int> v)  // return-only
    {   
        Span<int> span = stackalloc int[10];  // function-member
        v = span;  // err, scoped : v > span
    }
}
```

对于方法返回 `return e`，`e` 的 `safe-context` 至少为 *return-only*。
  
```csharp
class Sample
{
    Span<int> Fun()  // return : return-only at least 
    {
        Span<int> span = stackalloc int[10];  // function-member
        return span; // err, scoped: return-only > span
    }
}
```

>---
#### ref 引用重赋值和 ref 方法返回

`= ref` 操作的左操作数必须是绑定到一个局部变量、一个 `ref` 参数（非 `this`），一个 `out` 参数或一个 `ref` 字段。对于形式为 `e1 = ref e2` 引用重赋值，必须满足：
- `e2` 的 *ref-safe-context* 至少与 `e1` 的 *ref-safe-context* 相同，即 `ref e1 <= ref e2`。
- `e1` 必须具有与 `e2` 相同的 *safe-context*。

```csharp
/**
*  caller-context    $cm
*  return-only       $ro
*  function-member   $local
*  $cm > $ro > $local
*  RC : ref-safe-context
*  SC : safe-context
*  [UnscopedRef] : unscoped
*/
void Test(                                          // safe-context      ref-safe-context
    ref int v,                                      //  $cm                $ro
    ref Span<int> s,                                //  $cm                $ro
    out Span<int> os)                               //  $ro                $local
{
    os = default;
    Span<int> ls0 = s;                              //  $cm                $local
    Span<int> ls1 = default;                        //  $cm                $local
    Span<int> ls2 = new Span<int>(reference: ref v);//  $ro                $local
    Span<int> ls3 = stackalloc int[1];              //  $local             $local 

    s = ref ls1;  // err;  SC 相同, 但是 RC(s:$ro) > RC(ls1:$local)
    s = ref ls2;  // err;  RC(s:$ro) > RC(ls2:$local)

    s = ls1;      // okay; SC both $cm
    s = ls2;      // err;  SC(e1:$cm) > SC(e2:$ro)

    ref var rls = ref ls1;   // rls : SC = $cm, RC = $local
    rls = s;      // okay; both $cm
    rls = ls2;    // err;  $cm > $ro
    rls = ref s;  // okay; RC: $local < $ro, SC: both $cm
    rls = ref ls3;// err;  RC: both $local, SC: $cm != $local

    ref var rls2 = ref ls2;  // rls2: safe-context = $ro, ref-safe-context = $local
    rls2 = s;     // okay;
    rls2 = ls3;   // err; SC: $ro > $local
    rls2 = ref s;   // err; RC: $local < $ro, SC: $ro != $cm
    rls2 = ref os;  // okay; RC: $local = $local, SC: both $ro
}
```

对于方法返回 `return ref e`，`e` 的 `ref-safe-context` 至少为 *return-only*。结构类型实例方法中的 `this` 及其字段的安全上下文是 *function-member*，若要通过 `return ref` 方式返回值的引用，需要将实例方法标记为 `[UnscopedRef]`。

```csharp
struct Sample
{
    int value;
    ref int Fun(ref int v1, out int v2)
    {
        // v1 ref scoped: return-only
        // v2 ref scoped: function-member
        // this ref scoped: function-member
        v2 = 0;
        return ref v2;  // err
        return ref value;  // err
        return ref v1;  // okay
    }

    [UnscopedRef] ref int RefValue() => ref value;
    [UnscopedRef] ref Sample RefThis() => ref this;
}
```

---
### 泛型生命周期模型

生命周期最自然的表达方式是使用类型。在给定的程序的生命周期内对生命周期类型（*lifetime type*）的检查安全的。通常不会直接讨论生命周期类型，有一些类别的生命周期随特定的实例化点的不同而变化，我们将这些变化的生命周期称为泛型生命周期 *generic lifetimes*，用泛型参数表示，C# 不提供表示生命周期泛化的语法，因此定义一个从 C# 到包含显式泛型参数扩展的低级语言的隐式转换。

例如使用语法 `$a` 引用了一个名为 `a` 的生命周期，它本身是一个没有意义的生命周期，但可以通过 `where $a : $b` 语法与其他生命周期建立关系，表明 `$a` 的生命周期可以转换为 `$b`，也就是说 `$a` 的生命周期至少和 `$b` 一样长。有以下一些预定义的生命周期：
- `$heap`：堆上存在的任何值的生命周期，可用于任何上下文和方法签名。
- `$local`：方法堆栈中存在的任何值的生命周期，它实际上是 *function-member* 的名称占位。它可以隐式地定义在方法中，可以出现在方法签名中，除了任何的输出位置（前身是 *current method*）。
- `$ro`：用于 *return-only* 的名称位置占位（前身是 *return only*）。
- `$cm`：用于 *caller-context* 的名称位置占位（前身是 *calling method*）。

生命周期之间有一些预定义的关系：
- `where $heap : $a` 表示所有类别的生命周期 `$a`。
- `where $cm : $ro`。
- `where $x : $local` 表示所有预定义的生命周期，除非显式定义，否则用户定义的生命周期与 `$local` 没有关系。

在类型上定义的生命周期可以是不变的（*invariant*），也可以是协变的（*covariant*）。它们使用与泛型参数相同的语法表示：

```csharp
// $this is covariant
// $a is invariant
ref struct Sample<out $this, $a> 
```

类型定义上的 `$this` 不是预定义的，它在定义时存在一些与之相关的规则：
- 它必须是第一个生命周期参数。
- 它一定是协变的：`out $this`。
- `ref` 字段的生命周期必须可转换为 `$this`。
- 所有非 `ref` 字段的 `$this` 必须是 `$heap` 或 `$this`。

一个引用的生命周期由提供引用的生命周期来提供。一个引用堆的 `ref` 表示为 `ref<$heap>`。

在模型中定义构造函数时，将为方法使用 `new` 这个名称。必须为包含一个参数列表的构造值提供构造函数实参，这对于表达构造函数输入与构造值之间的关系是紧密联系的。模型将使用 `Span<$a> new<$ro>` 而不是 `Span<$a><$ro>`，构造函数中的 `this` 的类型（包括生命周期）将是定义的返回值。

>---
#### 生命周期模型的规则定义

生命周期的基本规则定义为：
- 所有的生命周期在语法上都表示为泛型参数，位于类型参数之前。除了 `$heap` 和 `$local` 之外，对于预定义的生命周期均是如此。
- 所有不是 `ref struct` 类型的类型 `T` 隐式具有 `T<$heap>` 生命周期。
- 对于定义为 `ref<$l0> T<$l1, $l2, ..., $ln>` 的 `ref` 字段：
  - 从 `$l1` 到 `$ln` 的生命周期类型必须是不变的；
  - `$l0` 必须可转换为 `$this`。
- 对于定义为 `ref<$a> T<$b, ...>` 的引用，`$b` 必须可以转换为 `$a`。
- `ref` 变量的生命周期由：
  - 对于 `ref` 的局部变量、参数或 `ref<$a> T` 的返回类型，它们的生命周期是 `$a`。
  - `$heap` 用于所有的引用类型或引用类型的字段。
  - `$local` 用于其他的所有类型。
- 当底层类型的转换合法时，赋值或返回也是合法的。
- 表达式的生命周期可以通过强制转换来显式设置：
  - `(T<$a> expr)` 的生命周期显式定义为 `T<...>` 的 `$a`。
  - `ref<$a> (T<$b>)expr` 的生命周期是 `T<...>` 的 `$b`，它的引用生命周期为 `$a`。

对于声明周期而言，`ref` 被认为是表达式的一部分，以便进行转换，它在逻辑上表示为将 `ref<$a> T<...>` 转换为 `ref<$a, T<...>>`，其中 `$a` 是协变的，`T` 是不变的。

>---
#### C# 语法映射到底层模型

没有显式生命周期参数的类型被视为定义了 `out $this`，并应用于该类型的所有字段。包含 `ref` 字段的类型必须定义显式的生命周期参数。这些规则支持了现有的不变量，即对于所有类型，`T` 可以赋值给 `scoped T` 的变量，映射到 `T<$a, ...>` 赋值给 `T<$local, ...>` 并在已知的所有生命周期内转换为 `$local`。

对于 `S<out $this, ...>`类型中的实例方法中的 `this` 被隐式定义为：
- 一般实例方法：`ref<$local> S<$cm, ...>`。
- `[UnscopedRef]` 标记的实例方法：`ref<$ro> S<$cm, ...>`。

由于实例方法缺少显式 `this` 参数因此使用强制隐式定义，实例中考虑将编写为静态方法并将 `this` 作为显式参数。

```csharp
ref struct S<out $this>
{
    // Implicit this can make discussion confusing 
    void M<$ro, $cm>(ref<$ro> S<$cm> s) {  }

    // Rewrite as explicit this to simplify discussion
    static void M<$ro, $cm>(ref<$local> S<$cm> this, ref<$ro> S<$cm> s) { }
}
```

C# 语法中以以下方式映射到模型：
- `ref` 参数的引用生命周期为 `$ro`。
- `ref struct` 类型的参数具有 `this` 相同的生命周期 `$cm`。
- `ref return` 返回的引用生命周期为 `$ro`。
- `ref struct` 类型的返回类型具有值生命周期 `$ro`。
- `scoped` 注释的参数或一个 `ref` 将更改引用生命周期为 `$local`。

> `ref` 映射

```csharp
ref int M1(ref int i) => ...

// Maps to the following. 
ref<$ro> int Identity<$ro>(ref<$ro> int i)
{
    // okay: has ref lifetime $ro which is equal to $ro
    return ref i;

    // okay: has ref lifetime $heap which convertible $ro
    int[] array = new int[42];
    return ref array[0];

    // error: has ref lifetime $local which has no conversion to $a hence 
    // it's illegal
    int local = 42;
    return ref local;
}
```

> `ref struct` 映射

```csharp
ref struct S
{
    ref int Field;
    S(ref int f)
    {
        Field = ref f;
    }
}
S M2(ref int i, S span1, scoped S span2) => ...

// Maps to 

ref struct S<out $this>
{
    // Implicitly 
    ref<$this> int Field;
    S<$ro> new<$ro>(ref<$ro> int f)
    {
        Field = ref f;
    }
}
S<$ro> M2<$ro>(ref<$ro> int i, S<$ro> span1, S<$local> span2)
{
    // okay: types match exactly
    return span1;

    // error: has lifetime $local which has no conversion to $ro
    return span2;

    // okay: type S<$heap> has a conversion to S<$ro> because $heap has a
    // conversion to $ro and the first lifetime parameter of S<> is covariant
    return default(S<$heap>)

    // okay: the ref lifetime of ref $i is $ro so this is just an identity conversion
    S<$ro> local = new S<$ro>(ref $i);
    return local;

    int[] array = new int[42];
    // okay: S<$heap> is convertible to S<$ro>
    return new S<$heap>(ref<$heap> array[0]);

    // okay: the parameter of the ctor is $ro ref int and the argument is $heap ref int. These 
    // are convertible.
    return new S<$ro>(ref<$heap> array[0]);

    // error: has ref lifetime $local which has no conversion to $a hence 
    // it's illegal
    int local = 42;
    return ref local;
}
```

> 循环自分配问题

```csharp
ref struct S
{
    int field;
    ref int refField;

    static void SelfAssign(ref S s)
    {
        s.refField = ref s.field;
    }
}

// Maps to 

ref struct S<out $this>
{
    int field;
    ref<$this> int refField;

    static void SelfAssign<$ro, $cm>(ref<$ro> S<$cm> s)
    {
        // error: the types work out here to ref<$cm> int = ref<$ro> int and that is 
        // illegal as $ro has no conversion to $cm (the relationship is the other direction)
        s.refField = ref<$ro> s.field;
    }
}
```

> 参数捕获问题 

```csharp
ref struct S
{
    ref int refField;

    void Use(ref int parameter)
    {
        // error: this needs to be an error else every call to this.Use(ref local) would fail 
        // because compiler would assume the `ref` was captured by ref.
        this.refField = ref param;
    }
}

// Maps to 

ref struct S<out $this>
{
    ref<$this> int refField;
    
    // Using static form of this method signature so the type of this is explicit. 
    static void Use<$ro, $cm>(ref<$local> S<$cm> @this, ref<$ro> int param)
    {
        // error: the types here are:
        //  - refField is ref<$cm> int
        //  - ref param is ref<$ro> int
        // That means the RHS is not convertible to the LHS ($ro is not covertible to $cm) and 
        // hence this reassignment is illegal
        @this.refField = ref<$ro> param;
    }
}
```

---
### 方法参数匹配原则

从 C#11 开始可以在 `ref struct` 声明 `ref` 字段，变量的值可以通过 `ref struct` 类型参数的引用或返回进行转义。其中有一个 `out` 或 `ref` 参数是 `ref struct` 类型，那么所有的 ***ref-likes*** 参数需要具有相同的生命周期。例如，当 `ref` 形参是 `ref struct` 类型时，它们有可能会发生数据交换，因此在调用点必须确保所有潜在的交换都是兼容的。若语言没有强制要求参数匹配，则可能会发生：

```csharp
void Fun(ref Span<int> s1)
{
    Span<int> s2 = stackalloc int[1];
    Swap(ref s1, ref s2);   //err; 这会导致将 stackalloc 分配给 s1, 并被允许转义到 Fun 的调用方
}
void Swap(ref Span<int> s1, ref Span<int> s2)
{
    s1 = ref s2;
}
```

对 `ref` 的参数（`ref struct` 类型）的分析包括实例方法中的接收方，由于它可以用来存储作为参数传入的值，像 `ref` 参数一样。

```csharp
void Broken(ref S s)
{
    Span<int> span = stackalloc int[1];

    // The result of a stackalloc is stored in s.Span
    // and escaped to the caller of Broken
    s.Set(span);  // err; s 作为接收方可能会存储 span
}
ref struct S
{
    public Span<int> Span;
    public void Set(Span<int> span)
    {
        Span = span;
    }
}
```

如果接收方是 `readonly ref struct` 结构体，则将其参数视为 `in`，而不是 `ref`。在这种情况下，接收方 `s` 不能用于存储来自其他参数的值。因此 `s` 为 `readonly` 时，`s.Set(span)` 是合法的，因为 `span` 不会被存储到 `s` 的任何地方。

```csharp
void Broken(ref S s)
{
    Span<int> span = stackalloc int[1];
    s.Set(span);  // okay; 接收方不能存储 span
}
readonly ref struct S
{
    public readonly Span<int> Span;
    public void Set(Span<int> span)
    {
        //Span = span;
    }
}
```

在计算调用方法返回值的 *safe-context* 或 *ref-safe-context* 时，由于 `scoped` 或 `[UnscopedRef]` 注释的参数 `p` 的影响（包括 `ref struct` 中隐式传递的 `this`），对于传递给形参 `p` 的给定实参 `expr`：
- 若 `p` 是 `scoped ref`、`scoped in` 参数，在计算返回值的 *ref-safe-context* 时不考虑 `expr` 提供的 *ref-safe-context*。
- 若 `p` 是 `scoped` 参数，在计算返回值的 *safe-context* 时不考虑 `expr` 提供的 *safe-context*。
- 若 `p` 是 `out` 参数，在计算返回值的上下文时不考虑 `expr` 提供的 *safe-context* 或 *ref-safe-context*。
- 若 `p` 是 `[UnscopedRef]` 注释 `out` 参数，在计算返回值的 *safe-context* 时不考虑 `expr` 提供的 *safe-context*。
- 对于结构类型的 `[UnscopedRef]` 实例方法，`this` 视为 `ref` 参数，其他任意类型的实例方法中，`this` 视为 `scoped ref` 参数。

**方法参数必须匹配** 可以解释为：在调用方法时，所有非 `scoped` 的 `ref struct` 类型的参数的 *safe-context*、`ref` 参数的 *ref-safe-context*、`[UnscopedRef] out` 参数的 *ref-safe-context* 必须大于或等于所有 `ref ref-struct` 参数的 *safe-context*。

对于任何方法调用 `e.M(p1,p2,...)`
- 返回值的 *safe-context* `E` 是以下上下文中最窄的：
  (1) *caller-context*。
  (2) 所有参数的 *safe-context*。
  (3) 所有非 `scoped` 的引用（`ref`、`in`、`[UnscopedRef] out`）参数的实参表达式的 *ref-safe-context*。
- 所有类型是 `ref struct` 的 `out` 参数必须由处于该 *safe-context* 范围的值赋值。

上述规则不包含 `ref struct` 结构的 `this`，由于在 `ref struct` 的实例方法中总会涉及一个 `ref struct` 类型的 `this`，因此调用 `ref struct` 的实例方法总是要考虑 “方法参数必须匹配” 的原则。计算 `ref struct` 实例方法返回值的 *safe-context* 时：
- `scoped ref this` 不贡献 *ref-safe-context*，贡献 *safe-context*。
- `[UnscopedRef] ref this` 贡献 *ref-safe-context*，

如果不匹配的签名使用 C#11 的 *ref-safe-context* 规则，则将不匹配问题报告为错误，否则为警告。

编译器在以下情况下分析并报告使用方法时（包括重写方法、接口实现、委托转换）的不安全的参数组合：
- 方法返回一个 `ref struct` 类型或 `ref/ref readonly` 返回时，并且该方法至少有一个额外的 `ref`、`in`、`out` 参数，或一个 `ref struct` 的参数
- 或者该方法包含一个 `ref struct` 类型的 `ref` 或 `out` 参数，并且该方法至少有一个额外的 `ref`、`in`、`out` 参数（`ref struct` 实例方法中的 `this` 被视为 `ref` 传递），或一个 `ref struct` 的参数。

> *ref struct* 中的方法匹配分析

```csharp

using System.Diagnostics.CodeAnalysis;

ref struct RSample
{
    /**
    *  caller-context    $cm
    *  return-only       $ro
    *  function-member   $local
    *  $cm > $ro > $local
    *  RC : ref-safe-context
    *  SC : safe-context
    *  [UnscopedRef] : unscoped
    */
    // 忽略以下方法的实现
    Span<int> Fun1(ref Span<int> S1) => throw new Exception();
    Span<int> Fun2(scoped ref Span<int> S1, out Span<int> S2) => throw new Exception();
    Span<int> Fun3(scoped ref Span<int> S1, [UnscopedRef] out Span<int> S2) => throw new Exception();
    [UnscopedRef] Span<int> Fun4(ref Span<int> S1, out Span<int> S2) => throw new Exception();
    Span<int> Fun5(Span<int> S1, out Span<int> S2) => throw new Exception();
    Span<int> Fun6(Span<int> S1, ref Span<int> S2) => throw new Exception();
    Span<int> Fun7(ref Span<int> S1, [UnscopedRef] out Span<int> S2) => throw new Exception();
    Span<int> Fun8(scoped Span<int> S1, out Span<int> S2) => throw new Exception();

    Span<int> span;  // SC: SC(this), RC: SC(this)
    ref int RValue;  // SC: $cm, RC: RC(this)
    int value;  // SC: $cm, RC: SC(this)

    Span<int> Test(
           // scoped ref this.span           // SC: $cm   RC: $local
           // unscoped ref this.span         // SC: $cm   RC: $ro
           ref Span<int> s1,                 // SC: $cm   RC: $ro
           out Span<int> s2,                 // SC: $ro   RC: $local
           [UnscopedRef] out Span<int> s3,   // SC: $ro   RC: $ro
           scoped Span<int> s4,              // SC: $local RC: $local
           scoped ref Span<int> s5)          // SC: $cm,  RC: $local
    {

        s2 = default(Span<int>);
        s3 = default(Span<int>);
        Span<int> ls1 = default(Span<int>);    // SC: $cm, RC: $local 
        Span<int> ls2 = new Span<int>(ref value);  // SC: $local, RC: $local
        Span<int> ls3 = new Span<int>(ref RValue); // SC: $cm, RC: $local
        Span<int> ls4 = stackalloc int[1];     // SC: $local, RC: $local

        // Fun1 分析：参数列表为 `scoped ref this`,`ref S1`
        //      this: SC = $cm, 不贡献 RC
        //      S1: 要求 SC 是 $cm
        //      return: SC 是 RC(S1)
        // 其中 $cm 参数包含: this.span,s1,s5,ls1,ls3
        Fun1(S1: ref this.span);  // SC(return) = RC(this.span) = $local
        return Fun1(S1: ref s1);  // SC = RC(s1) = $ro
        Fun1(S1: ref s5);   // $local
        Fun1(S1: ref ls1);  // $local
        Fun1(S1: ref ls3);  // $local

        // Fun2 分析: `scoped ref this`,`scoped ref S1`,`out S2`
        //      this: SC = $cm, 不贡献 RC
        //      S1: 要求 SC 是 $cm, 不贡献 RC
        //      S2: 不贡献 RC 和 SC, 可以是 $cm 范围内的任何左值
        //      return: SC 是 $cm, 因此 out 参数可以是任意 $cm 范围内的值
        return Fun2(S1: ref this.span, S2: out s1);
        return Fun2(S1: ref s1, S2: out s4);
        return Fun2(S1: ref ls3, S2: out ls4);

        // Fun3 分析: `scoped ref this`,`scoped ref S1`,`unscoped out S2`
        //      this: SC = $cm, 不贡献 RC
        //      S1: 要求 SC 是 $cm, 不贡献 RC
        //      S2: 不贡献 SC, 可以是 $cm 下的任意左值
        //      return: SC 是 RC(S2)
        Fun3(S1: ref s1, S2: out s2);  // $local
        return Fun3(S1: ref s5, S2: out s1);  // $ro
        return Fun3(S1: ref ls3, S2: out s3); // $ro

        //// Fun4 分析: `unscoped ref this`,`ref S1`,`out S2`
        ////      this: SC = $cm, 贡献 RC
        ////      S1: SC 必须是 $cm
        ////      S2: 不贡献 RC 和 SC
        ////      return: SC 是 RC(this), RC(S1) 中的最小值 $local, 因此 out 参数只能是 $local
        Fun4(S1: ref this.span, out s4);  // $local
        Fun4(S1: ref s1, out _);     // $local
        Fun4(S1: ref ls3, out ls4);  // $local

        // Fun5 分析: `scoped ref this`,`S1`,`out S2`
        //      this: SC = $cm, 不贡献 RC
        //      S1: 要求 SC 是 $cm, 不贡献 RC
        //      S2: 不贡献 RC 和 SC, 可以是 $cm 范围内的任何左值
        //      return: SC 是 $cm
        return Fun5(S1: this.span, S2: out ls4);
        return Fun5(S1: s1, S2: out ls4);
        return Fun5(S1: ls3, S2: out s1);

        // Fun6 分析: `scoped ref this`,`S1`,`ref S2`
        //      this: SC = $cm, 不贡献 RC
        //      S1: 要求 SC 是 $cm, 不贡献 RC
        //      S2: 要求 SC 是 $cm
        //      return: SC 是 RC(S2)
        return Fun6(S1: ls3, S2: ref s1); // $ro
        Fun6(S1: ls3, S2: ref s5);        // $local

        // Fun7 分析: `scoped ref this`,`ref S1`,`unscoped out s2`
        //      this: SC = $cm, 不贡献 RC
        //      S1: 要求 SC 是 $cm
        //      S2: 不贡献 SC, SC(S2) 的范围不超过 RC(return)
        //      return: SC 是 S1,S2 中最窄的 RC
        // 这类情况限制 RC(S1) >= SC(S2) >= RC(S2), SC(return) = Min{RC(S1), RC(S2)}, SC(S2) <= SC(return)
        // 因此, SC(S2) == RC(S2), SC(return) == RC(S2)
        Fun7(S1: ref s1, S2: out ls2);         // $local
        Fun7(S1: ref this.span, S2: out ls4);  // $local
        Fun7(S1: ref s5, S2: out _);     // $local

        // Fun8 分析: `scoped ref this`,`scoped S1`, `out S2`
        //      this: SC = $cm, 不贡献 RC
        //      S1: 要求 SC 是 $cm, 不贡献 RC
        //      S2: 不贡献 RC 和 SC, 可以是 $cm 范围内的任何左值
        //      return: SC 是 $cm
        return Fun8(S1: this.span, S2: out ls4);
        return Fun8(S1: s1, S2: out ls4);
        return Fun8(S1: ls3, S2: out s1);
    }
}
```

> 非 *ref struct* 方法匹配分析

```csharp
using System.Diagnostics.CodeAnalysis;
class Sample
{
    /**
    *  caller-context    $cm
    *  return-only       $ro
    *  function-member   $local
    *  $cm > $ro > $local
    *  RC : ref-safe-context
    *  SC : safe-context
    *  [UnscopedRef] : unscoped
    */
    Span<int> Fun1(ref Span<int> s) => s;
    Span<int> Fun2(scoped ref Span<int> s, out Span<int> s2) { s2 = s; return default; }
    Span<int> Fun3(scoped ref Span<int> s, [UnscopedRef] out Span<int> s2) { s2 = s; return default; }
    Span<int> Fun4(ref Span<int> s, out Span<int> s2) { s2 = s; return default; }
    Span<int> Fun5(Span<int> s, out Span<int> s2) { s2 = s; return default; }
    Span<int> Fun6(Span<int> s, ref Span<int> s2) { s2 = s; return default; }
    Span<int> Fun7(ref Span<int> s, [UnscopedRef] out Span<int> s2) { s2 = s; return default; }

    Span<int> Test(                                     // safe-context      ref-safe-context
        ref int v,                                      //  $cm                $ro
        ref Span<int> s,                                //  $cm                $ro
        out Span<int> os)                               //  $ro                $local
    {
        os = default;
        Span<int> ls0 = s;                              //  $cm                $local
        Span<int> ls1 = default;                        //  $cm                $local
        Span<int> ls2 = new Span<int>(reference: ref v);//  $ro                $local
        Span<int> ls3 = stackalloc int[1];              //  $local             $local 

        var rt = Fun1(s: ref s);
        // Fun1 分析：参数列表为 `ref s`
        //      s: 任何 $cm 范围的值
        //      return: SC 和 s 的 RC 相同  
        return Fun1(s: ref s);    // SC: $ro
        Fun1(s: ref ls3);  // SC: $local

        // Fun2 分析: `scoped ref s`,`out s2`
        //      s: 任何 $cm 范围的值, 不贡献 RC
        //      s2: 不贡献 RC 和 SC, SC 是 SC(s) 范围内的任何值 
        //      return: SC 是所有提供 SC 参数的 SC 中最小的, 因此 SC 和 s 相同
        Fun2(s: ref ls3, s2: out ls3);    // s:$local, 因此 s2 只能是 $local, return:$local
        return Fun2(s: ref os, s2: out os /* ls2,ls3 */);   // s:$ro, SC(s2) <= $ro, return:$ro
        return Fun2(s: ref ls2, s2: out os /* ls2,ls3 */);  // s:$ro,  SC(s2) <= $ro, return:ro 

        // Fun3 分析: `scoped ref s`,`unscoped out s2`
        //      s: 任何 $cm 范围的值, 不贡献 RC
        //      s2: 不贡献 SC, SC 是 SC(s) 范围内的任何值 
        //      return: SC 是 RC(s2) 
        Fun3(s: ref ls3, s2: out ls3);  // SC(ls3):$local, 因此 s2 只能是 $local, return: $local
        Fun3(s: ref os, s2: out ls2);   // SC(os):$ro, SC(s2) <= $ro, return:RC(s2) $local

        // Fun4 分析: `ref s`,`out s2`
        //      s: 任何 $cm 范围的值
        //      s2: 不贡献 RC 和 SC
        //      return: SC 是 RC(s), SC(s2) 是 RC(s) 范围内的任何值
        Fun4(s: ref ls1, s2: out ls3);   // return:RC(ls1) = $local
        return Fun4(s: ref s, s2: out os /* ls2,ls3 */);   // return:RC(s) = $ro, SC(s2) <= $ro

        // Fun5 分析: `s`,`out s2`
        //      s: 任何 $cm 范围的值, 不贡献 RC
        //      s2: 不贡献 RC 和 SC
        //      return: SC 是 SC(s), s2 是 SC(s) 范围的任何值
        Fun5(s: ls3, s2: out ls3);       // return:$local
        return Fun5(s: ls2, s2: out os); // SC(s2) <= SC(s) , return:$ro

        // Fun6 分析: `s`,`ref s2`
        //      s: 任何 $cm 范围的值, 不贡献 RC
        //      s2: SC <= SC(s) 
        //      return: SC 与 RC(s2) 相同
        Fun6(s: ls3, s2: ref ls3);      // return:$local
        Fun6(s: s, s2: ref os);         // return:$local
        return Fun6(s: s, s2: ref s);   // return:$ro

        // Fun7 分析: `ref s`,`unscoped out s2`
        //      s: 任何 $cm 范围的值
        //      s2: 不贡献 SC, SC(s2) <= RC(s) 
        //      return: SC 是 RC(s2)
        Fun7(s: ref ls3, s2: out ls3);  // return:$local
        Fun7(s: ref s, s2: out os);     // return:$local
    }
}
```

---
### 变量的安全上下文由让它的声明方式决定

#### 方法参数

使用方法参数的 *Lvalue* 表达式表示的 *ref-safe-context*：
- 如果是 `ref` 或 `in` 参数，它的 *ref-safe-context* 是：
  - 默认的 *return-only*。
  - `scoped` 注释的 *function-member*。
  - `[UnscopedRef]` 注释的 *caller-context*。
- 如果是一个 `out` 参数，它的 *ref-safe-context* 是：
  - 隐式 `scoped` 的 *function-member*。
  - 显式 `[UnscopedRef]` 的 *return-only*。
- 结构类型实例方法中的 `this` 被视为 `scoped ref` 参数传递：
  - `this` 的 *ref-safe-context* 是 *function-member*。
  - 结构类型中 `[UnscopedRef]` 标记的实例方法中，`this` 的 *ref-safe-context* 是 *return-only*。
- 类类型实例方法中的 `this` 被视为 `scoped ref` 参数传递，它的 *ref-safe-context* 是 *function-member*。
- 如果是一个值形参，则它的 *ref-safe-context* 是 *function-member*。

使用方法参数的 *Rvalue* 表达式的 *safe-context* 是：
- `ref struct` 类型的 `out` 参数具有 *return-only* 的 *safe-context*。
- 否则，它的 *safe-context* 是 *caller-context*。

>---
#### 局部变量

使用局部变量的 *Lvalue* 表达式的 *ref-safe-context*：
- 如果变量是非 `scoped` 注释的 `ref` 引用变量，它的 *ref-safe-context* 与其初始化项的 *ref-safe-context* 相同。
- `scoped` 注释的 `ref` 变量或 `ref scoped` 类型的变量，它的 *ref-safe-context* 为 *function-context*，并忽略其初始化项的 *ref-safe-context*（如果有）。 
- 否则它的 *ref-safe-context* 是 *declaration-block*。

使用局部变量的 *Rvalue* 表达式的 *safe-context*：
- 如果不是 `ref struct` 类型，它的 *safe-context* 为 *caller-context*。
- 如果变量是 `foreach` 循环的迭代变量，则该变量的 *safe-context* 与 `foreach` 循环体的 *safe-context* 相同。
- 未被 `scoped` 注释的 `ref struct` 类型的局部变量具有：
  - 如果变量声明时未初始化，那么它的 *safe-Context* 为 *caller-context*。
  - 如果变量声明有初始化项，那么它的 *safe-Context* 与该初始化项的 *safe-Context* 相同。
  - 当变量被 `scoped` 注释时，它的 *safe-context* 为 *function-member*。

>---
#### 成员字段

使用字段 `e.F` 的 *Lvalue* 表达式 `= ref e.F` 的 *ref-safe-context*：
- 如果 `e` 是 `ref struct` 类型且 `F` 是一个 `ref` 字段，它的 *ref-safe-context* 是 `e` 的 *safe-context*。
  
  ```csharp
  /**
   * SC = safe-context, RC = ref-safe-context 
   * $cm = caller-context
   * $local = function-member
   * $ro = return-only
   */
  ref struct RS
  {
      public ref int RefField; // SC: $cm, RC: SC(this)
  }
  class Sample
  {
      void GetRef(
          ref RS rs,    // SC: $cm, RC: $ro
          out RS rs2)   // SC: $ro, RC: $local
      {
          rs2 = default(RS);
          RS lrs1 = default(RS);        // SC: $cm, RC: $local
          scoped RS lrs2 = default(RS); // SC: $local, RC: $local
  
          rs.RefField = ref lrs2.RefField;  // err; RC(LHS:$cm) > RC(RHS:$local)
          lrs2.RefField = ref rs.RefField;  // okay
  
          rs2.RefField = ref lrs2.RefField;   // err; RC(LHS:$ro) > RC(RHS:$local)
          lrs2.RefField = ref rs2.RefField;   // okay
  
          lrs1.RefField = ref lrs2.RefField;  // err; RC(LHS:$cm) > RC(RHS:$local)
          lrs2.RefField = ref lrs1.RefField;  // okay
  
          lrs1.RefField = ref rs2.RefField;  // err; RC(LHS:$cm) > RC(RHS:$ro)
          rs2.RefField = ref lrs1.RefField;  // okay
      }
  }
  ```

- 如果 `e` 是引用类型，则 `F` 的 *ref-safe-context* 是 *caller-context*。

  ```csharp
  ref struct RSample
  {
      ref int RefValue;
      class Sample { public int Value; }
  
      void GetRef(ref Sample s1, Sample s2, scoped ref Sample s3)
      {
          Sample ls = new Sample();
  
          // RC both are $cm
          RefValue = ref s1.Value;
          RefValue = ref s2.Value;
          RefValue = ref s3.Value;
          RefValue = ref ls.Value;
      }
  }
  ```

- 如果 `e` 是值类型，则 `F` 的 *ref-safe-context* 与 `e` 的 *ref-safe-context* 相同。`[UnscopedRef]` 标记后的结构实例方法中，`this` 及其字段的 *ref-safe-context* 提升为 *return-only*。     

  ```csharp
  /**
   * SC = safe-context, RC = ref-safe-context 
   * $cm = caller-context
   * $local = function-member
   * $ro = return-only
   */
  using System.Diagnostics.CodeAnalysis;
  using Span = System.Span<int>;
  struct Sample
  {
      int Value;  // SC: $cm, RC: RC(this)
  
      ref struct RS
      {
          // ==== Ref non-ref-struct Field ====
          public ref int RefValue;  // SC: $cm, RC: SC(this)
          ref int GetIntRef(
              // scoped ref this     // SC: $cm, RC: $local
              ref int rValue,        // SC: $cm, RC: $ro
              ref Sample s1,         // SC: $cm, RC: $ro
              Sample s2,             // SC: $cm, RC: $local
              scoped ref Sample s3,  // SC: $cm, RC: $local
              out Sample s4)         // SC: $cm, RC: $local
          {
              s4 = default(Sample);
              Sample ls = new Sample();  // SC: $cm, RC: $local
  
              // SC both $cm
              RefValue = ref s1.Value;  // err; RC(LHS:$cm) > RC(RHS:$ro)
              RefValue = ref s2.Value;  // err; RC(LHS:$cm) > RC(RHS:$local)
              RefValue = ref s3.Value;  // err; RC(LHS:$cm) > RC(RHS:$local)
              RefValue = ref s4.Value;  // err; RC(LHS:$cm) > RC(RHS:$local)
              RefValue = ref ls.Value;  // err; RC(LHS:$cm) > RC(RHS:$local)
  
              rValue = ref s1.Value;  // okay; RC(LHS:$ro) == RC(RHS:$ro)
              rValue = ref s2.Value;  // err;  RC(LHS:$ro) > RC(RHS:$local)
              rValue = ref ls.Value;  // err;  RC(LHS:$ro) > RC(RHS:$local)
  
              int lv = 0;
              ref int lrValue = ref lv;  // SC: $cm, RC: $local
              lrValue = ref ls.Value;    // okay; RC both local
  
              ref int lrValue2 = ref s1.Value;  // SC: $cm, RC = RC(s1.Value) = $ro
              lrValue2 = ref rValue;   // okay;
              lrValue2 = ref lrValue;  // err; RC(LHS:$ro) > RC(RHS:$local)
  
              // $ro return okay
              return ref rValue;
              return ref s1.Value;
              return ref lrValue2;
              return ref this.RefValue;  // RC: $cm
  
              // err return;
              return ref s2.Value;  // RC: $local
              return ref s3.Value;  // RC: $local
              return ref lrValue;   // RC: $local
          }
  
          // ==== Ref ref-struct Field ====
          Span<int> span;  // SC: $cm, RC: SC(this)
                           // using Span = System.Span<int> at file start
          ref Span<int> RefSpan(
               // scoped ref this     // SC: $cm, RC: $local
               ref Span<int> rValue,  // SC: $cm, RC: $ro
               ref RS s1,             // SC: $cm, RC: $ro
               RS s2,                 // SC: $cm, RC: $local
               scoped ref RS s3,      // SC: $cm, RC: $local
               out RS s4,             // SC: $ro, RC: $local
               out Span<int> sp,      // SC: $ro, RC: $local
               [UnscopedRef] out Span<int> sp2,  // SC: $ro, RC: $ro
               [UnscopedRef] out RS s5)          // SC: $ro, RC: $ro
          {
              sp = default(Span);
              sp2 = default(Span);
              s4 = default(RS);
              s5 = default(RS);
              Span ls1 = default(Span);     // SC: $cm, RC: $local
              Span ls2 = stackalloc int[1]; // SC: $local, $RC: local
  
              // SC: $cm, RC: $local
              ref Span rs = ref span;  // SC: SC(this) = $cm, RC = RC(this) = $local
              rs = ref rValue;   // okay; same SC AND RC(LHS) < RC(RHS)
              rs = ref s1.span;  // okay; same SC AND RC(LHS:local) < RC(RHS:$ro)  
              rs = ref s2.span;  // okay; same SC AND RC both $local
              rs = ref sp;       // err; SC(LHS:$cm) != SC(RHS:$ro)
              rs = ref ls1;      // okay; same SC AND RC(LHS:local) == RC(RHS:$local)  
              rs = ref ls2;      // err; SC(LHS:$cm) != SC(RHS:$local)
  
              // SC: $cm, RC: $ro
              ref Span rs2 = ref rValue;  // SC: $cm, RC: $ro
              rs2 = ref s1.span;  // RC == RC(RHS:$ro)  
              rs2 = ref sp2;      // same RC, but different SC
              rs2 = ref s2.span;  // RC > RHS:$local
  
              // SC: $ro, RC: $local
              ref Span rs3 = ref sp;
              rs3 = ref ls2;  // SC(ls2) = $local
              rs3 = ref sp2;  // okay; SC both $ro, RC(LHS:$local) < RC(RHS:$ro)
              rs3 = ref s5.span;  // okay
  
              // SC: $local, RC: $local
              ref Span rs4 = ref ls2;
              // .... 任意 span 无法转换为 rs4
  
              // okay return 
              return ref s1.span;  // RC: $ro
              return ref sp2;      // RC: $ro
              return ref s5.span;  // RC: $ro
              return ref rValue;
  
              // err return
              return ref span;  // RC(Field) = $RC(this) = $local, 若是 [UnscopedRef] 则 $RC(this) = $ro
              return ref s2.span;  
              return ref ls1;
              return ref sp;
              return ref s4.span;  // RC: $local
          }
      }
      // ====  Ref This ====
      ref int NonRefThisField() => ref Value;  // err; RC(Field) = RC(this) = $local
      [UnscopedRef] ref int RefThisField() => ref this.Value;  // okay; RC(this) = $ro
      [UnscopedRef] ref Sample RefThis() => ref this;
  }
  ```

使用字段 `e.F` 的 *Rvalue* 表达式 `= e.F`：
- 字段的类型是 `ref struct` 的 *safe-context* 与 `e` 的 *safe-context* 相同。
- 否则，它的 *safe-context* 是 *caller-context*。
 
```csharp
/**
 * SC = safe-context, RC = ref-safe-context 
 * $cm = caller-context
 * $local = function-member
 * $ro = return-only
 */
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using Span = System.Span<int>;

ref struct RS
{
    // ==== ref-struct Field ====
    Span<int> span;  // SC: SC(this), RC: SC(this)
                     // using Span = System.Span<int> at file start
    Span<int> RefSpan(
         // scoped ref this     // SC: $cm
         ref Span<int> rValue,  // SC: $cm
         ref RS s1,             // SC: $cm
         RS s2,                 // SC: $cm
         out RS s3,             // SC: $ro
         out Span<int> sp,      // SC: $ro
         scoped Span<int> span1)  // SC: $local
    {
        sp = default(Span);
        s3 = default(RS);
        Span ls1 = default(Span);     // SC: $cm
        Span ls2 = stackalloc int[1]; // SC: $local

        // SC: $cm, SC(span) = $cm
        span = rValue;   // okay; both $cm
        span = s1.span;  // okay;
        span = s2.span;  // okay; 
        span = s3.span;  // err; SC(LHS:$cm) > SC(RHS:$ro)
        span = sp;       // err; SC(LHS:$cm) > SC(RHS:$ro)
        span = ls1;      // okay; 
        span = ls2;      // err; SC(LHS:$cm) > SC(RHS:$local)
        span = span1;    // err; SC(RHS:$local)

        // SC: $ro, SC(s3.span) = $ro
        s3.span = span;  // okay
        s3.span = sp;    // okay; both $ro
        s3.span = ls2;   // err; SC(ls2) = $local

        // SC: $local
        scoped Span lspan = span;  // SC: $local
        lspan = ls2;  // okay; SC: $local
        sp = lspan;   // err;  SC(sp) = $ro
        lspan = span1;  // okay;
        sp = span1;   // err;  SC(RHS) = $local

        // okay return 
        return span;     // $cm
        return s1.span;  // $cm
        return rValue;   // $cm
        return s3.span;  // $ro
        return sp;       // $ro

        // err return
        return ls2;    // $local
        return lspan;  // $local
        return span1;  // $local
    }
}
```

>---
#### 推断声明表达式的安全上下文

具有输出参数的方法 `M(x, out var y)` 或解构函数 `(var x, var y) = M()` 的推断声明表达式 `var 'Rvalue'` 的 *safe-context* 是：
- *caller-context*。
- 如果 `out` 参数的类型是 `ref struct`：
  - 如果 `out` 变量的实参标记为 `out scoped var x`，它的安全上下文是 *function-member* 或更窄的 *declaration-block*。
  - 否则需要考虑方法中包含调用的其他所有参数，且包含接收方，它的安全上下文是以下最窄的：
    - 任何非 `out` 参数的 *safe-context*。 
  - 任何参数的 *ref-safe-context*。

由 `scoped` 修饰符产生的局部上下文是可能用于变量的最窄的上下文，任何更窄的上下文都意味着表达式引用的变量只能在比表达式更窄的上下文中声明。

```csharp
ref struct RSample
{
    public RSample(ref int x) { } // assumed to be able to capture 'x'
    static void Fun(RSample input, out RSample output) => output = input;
    static RSample FunLocal(ref int v)
    {
        var i = 0;
        var lrs = new RSample(ref i);  // safe-context of 'lrs' is function-member
        Fun(lrs, out var rs_out); // safe-context of 'rs_out' is function-member
        return rs_out;  // err;  

        var lrs2 = new RSample(ref v);  // safe-context of 'lrs2' is return-only
        Fun(lrs2, out var rs_out2);  // safe-context of 'rs_out2' is return-only
        return rs_out2;  // okay
    }
    static RSample FunCm(RSample rs)
    {
        Fun(rs, out var rs_out); // safe-context of 'rs' is caller-context
        return rs_out;  // okay
    }
    static RSample FunScoped(RSample rs)
    {
        // 'scoped' modifier forces safe-context of 'rs2' to the current local context (function-member or narrower).
        Fun(rs, out scoped var rs_scoped);  // scoped out var is function-context
        return rs_scoped; // err;
    }
}
```

>---
#### 函数成员调用

属性调用（`get` 或 `set`）被视为对底层方法的方法调用。调用构造函数的 `new` 表达式被视为对正在构造类型的方法调用，如果存在初始化项，则它的 *safe-context* 不能大于对象初始化项的所有参数和操作数中最窄的 *safe-context*。用户定义的运算符操作被视为方法调用。实例方法中包含隐式参数 `ref this`，构造函数包含隐式参数 `out this`。

对于方法调用 `var rt = e.M(e1,e2,...)` 产生的值 `rt`，当 `M()` 方法不返回 `return ref ref-struct` 时，方法返回值的 *safe-context* 与以下上下文中最窄的相同：
- *caller-context*。
- 当返回类型是 `ref struct` 时，由所有参数表达式提供的 *safe-context*。
- 当返回类型是 `ref struct` 时，由所有非 `scoped` 注释的 `ref` 参数、`[UnscopedRef] this` 隐式参数、`in` 参数、`[UnscopedRef] out` 参数提供提供的 *ref-safe-context*。
- 一般而言参数的 *safe-context* 大于等于它的 *ref-safe-context*，因此引用传递的参数只考虑它的 *ref-safe-context*。

```csharp
using System.Diagnostics.CodeAnalysis;
ref struct RSample
{
    Span<int> Span;  // SC: caller-context;
    Span<int> Fun1(int v, ref int v2) => default(Span<int>);
    Span<int> Fun2(int v, ref int v2, scoped ref int v3) => default(Span<int>);
    [UnscopedRef] Span<int> Fun3(int v, ref int v2) => default(Span<int>);
    Span<int> Fun4(int v, ref int v2, out int v3) => throw new Exception();
    Span<int> Fun5(int v, ref int v2, [UnscopedRef] out int v3) => throw new Exception();
    Span<int> Fun6(Span<int> s, ref int v2, [UnscopedRef] out int v3) => throw new Exception();

    Span<int> Create(ref int v,             // SC: $cm,  RC: $ro
        [UnscopedRef] ref int v_unscoped,   // SC: $cm,  RC: $cm
        scoped ref int v_scoped)            // SC: $cm,  RC: $local
    {
        // Fun1 分析: 参数列表为 `scoped ref this`,`v`,`ref v2`
        // return 的 SC 是 SC(this),SC(v:$cm),RC(v2) 中最窄的
        var Fun1_rt1 = Fun1(v, ref v);  // $ro
        var Fun1_rt2 = Fun1(v, ref v_scoped);  // $local
        var Fun1_rt3 = Fun1(v, ref v_unscoped); // $cm
        return Fun1_rt1;  // okay
        return Fun1_rt3;  // okay
        Fun1_rt1 = Fun1_rt2; // err; SC(LHS) > SC(RHS) : $ro > $local
        Fun1_rt3 = Fun1_rt1; // err; SC(LHS) > SC(RHS) : $cm > $ro

        // Fun2 分析: `scoped ref this`,`v`,`ref v2`,`scoped ref v3`
        // return 的 SC 是 SC(this),SC(v:$cm),RC(v2),SC(v3) 中最窄的
        return Fun2(v, ref v_unscoped, ref v_scoped); // $cm
        return Fun2(v_scoped, ref v, ref v_scoped); // $ro
        return Fun2(v_scoped, ref v_scoped, ref v_scoped); // $local

        // Fun3 分析: `unscoped ref this`,`v`,`ref v2`
        // return 的 SC 是 RC(this),SC(v:$cm),RC(v2) 中最窄的
        Fun3(v_scoped, ref v);  // $local; RC(this) = $local in this context, but in Fun3 RC(Fun3.this) is $ro

        // Fun4 分析: `scoped ref this`,`v`,`ref v2`,`out v3`
        // return 的 SC 是 SC(this),SC(v),RC(v2) 中最窄的
        return Fun4(v_scoped, ref v, out v_scoped);  // $ro
        return Fun4(v_scoped, ref v_unscoped, out v_scoped);  // $cm
        return Fun4(v_scoped, ref v_scoped, out v_scoped);  // $local

        // Fun5 分析: `scoped ref this`,`v`,`ref v2`,`unscoped out v3`
        // return 的 SC 是 SC(this),SC(v),RC(v2),RC(v3) 中最窄的
        return Fun5(v_scoped, ref v_unscoped, out v_scoped);  // $local
        return Fun5(v_scoped, ref v_unscoped, out v);  // $ro
        return Fun5(v_scoped, ref v_unscoped, out v_unscoped);  // $cm
        return Fun5(v_scoped, ref v_scoped, out v_unscoped);  // $local
        return Fun5(v_scoped, ref v, out v_unscoped);  // $ro

        // Fun6 分析: `scoped ref this`,`s`,`ref v2`,`unscoped out v3`
        // return 的 SC 是 SC(this),SC(s),RC(v2),RC(v3) 中最窄的
        return Fun6(new Span<int>(ref v), ref v_unscoped, out v_unscoped); // $ro
        return Fun6(new Span<int>(ref v_scoped), ref v_unscoped, out v_unscoped); // $local
        return Fun6(new Span<int>(ref v_scoped), ref v_unscoped, out v_unscoped); // $local
        return Fun6(new Span<int>(ref v_unscoped), ref v_unscoped, out v_unscoped); // $cm
        return Fun6(new Span<int>(ref v_unscoped), ref v_unscoped, out _); // $local
        // 弃元被视为局部变量，它的 RC 是 $local
    }
}
```

对于方法调用 `var rt = e.M(e1,e2,...)` 产生的值 `rt`，当 `M()` 方法返回 `return ref ref-struct` 时，方法返回值的 *safe-context* 与所有类型 是 `ref struct` 的 `ref` 参数、`in` 参数、（如果是）`ref struct` 结构的实例方法中的 `this` 的 *safe-context* 相同。

```csharp
using System.Diagnostics.CodeAnalysis;
struct Sample
{
    ref Span<int> Fun1(Span<int> v, ref Span<int> v2) => throw new Exception();
    ref Span<int> Fun2(Span<int> v, ref Span<int> v2, scoped ref Span<int> v3) => throw new Exception();
    ref Span<int> Fun3(Span<int> v, ref Span<int> v2, out Span<int> v3) => throw new Exception();
    ref Span<int> Fun4(Span<int> v, ref Span<int> v2, [UnscopedRef] out Span<int> v3) => throw new Exception();

    Span<int> Create(ref Span<int> r,             // SC: $cm,  RC: $ro
        [UnscopedRef] ref Span<int> r_unscoped,   // SC: $cm,  RC: $cm
        scoped ref Span<int> r_scoped,            // SC: $cm,  RC: $local
        out Span<int> o_scoped,                   // SC: $ro,  RC: $local
        [UnscopedRef] out Span<int> o_unscoped,   // SC: $ro,  RC: $ro
        scoped Span<int> v_scoped)                // SC: $local, RC: $local
    {
        // 上下文范围降序 r_unscoped > r > r_scoped > o_unscoped > o_scoped > v_scoped
        o_scoped = default;
        o_unscoped = default;
        // Fun1 分析: 类型为 ref struct 的 ref-likes 参数为 `ref v2`
        // return 的 SC 与 SC(v2) 相同, v 的 SC >= SC(v2)
        return Fun1(v: r, v2: ref r_scoped);  // $cm
        return Fun1(v: r_scoped, v2: ref o_scoped);   // $ro
        return Fun1(v: o_unscoped, v2: ref o_unscoped); // $ro
        Fun1(v: r_unscoped, v2: ref v_scoped); // $local
        Fun1(v: v_scoped, v2: ref v_scoped);   // $local

        // Fun2 分析: `ref v2`,`scoped ref v3`
        // return 的 SC 与 SC(v2), SC(v3) 相同, SC(v) must >= SC(return) 
        return Fun2(v: r, ref r_scoped, ref r_scoped); // $cm
        return Fun2(v: o_scoped, ref o_unscoped, ref o_scoped);  // $ro
        Fun2(v: r_unscoped, v2: ref v_scoped, v3: ref v_scoped); // $local
        Fun2(v: v_scoped, v2: ref v_scoped, v3: ref v_scoped); // $local

        // Fun3 分析: `ref v2`,`out v3`
        // return 的 SC 与 SC(v2) 相同, MUST: SC(v) >= SC(return) >= SC(out), RC(ref) >= RC(out)
        return Fun3(r_unscoped, ref r_unscoped, out r_unscoped);  // $cm
        return Fun3(o_scoped, ref o_scoped, out v_scoped);  // $ro
        Fun3(v_scoped, ref v_scoped, out v_scoped);  // $local

        // Fun4 分析: `ref v2`,`unscoped out v3`
        // return 的 SC 与 SC(v2) 相同, MUST: SC(v) >= SC(return) >= SC(out), RC(ref) >= RC(out)
        return Fun4(r_unscoped, ref r_unscoped, out r_unscoped);  // $cm
        return Fun4(r_unscoped, ref o_scoped, out v_scoped);  // $ro
        Fun4(v_scoped, ref v_scoped, out v_scoped);  // $local
    }
}
```

对于方法调用 `= ref e.M(e1,e2,...)` 产生的 *Lvalue*，当 `M()` 方法不返回 `return ref ref-struct` 时，方法返回值的 *ref-safe-context* 是以下上下文中最窄的：
- *caller-context*。
- 所有参数的 *safe-context*。
- 所有非 `scoped` 注释的 `ref`、`in`、`[UnscopedRef] out`、参数的 *ref-safe-cotext*，如果是 `[UnscopedRef]` 方法，则包含 `ref this` 的 *ref -safe-context*。

```csharp
using System.Diagnostics.CodeAnalysis;
struct Sample
{
    ref int Fun1(int v, ref int v2) => throw new Exception();
    ref int Fun2(int v, ref int v2, scoped ref int v3) => throw new Exception();
    [UnscopedRef] ref int Fun3(int v, ref int v2) => throw new Exception();
    ref int Fun4(Span<int> v, int v2) => throw new Exception();
    ref int Fun5(Span<int> v, ref int v2, [UnscopedRef] out int v3) => throw new Exception();

    int Value; // SC: $cm, RC: RC(this)
    ref int Create(
         // scoped ref this.Value               // SC: $cm,  RC: local
         // unscoped ref this.Value             // SC: $cm,  RC: $ro
         ref int rv,                            // SC: $cm,  RC: $ro
         scoped ref int rv_scoped,              // SC: $cm,  RC: $local
         [UnscopedRef] ref int rv_unscoped)     // SC: $cm,  RC: $cm
    {
        // Fun1 分析: 参数列表为 `scoped ref this`,`v`,`ref v2`
        // return 的 RC 是 SC(this),SC(v:$cm),RC(v2) 中最窄的
        return ref Fun1(Value, ref rv); // $ro
        _ = ref Fun1(Value, ref rv_scoped); // $local
        return ref Fun1(Value, ref rv_unscoped); // $cm

        // Fun2 分析: `scoped ref this`,`v`,`ref v2`,`scoped ref v3`
        // return 的 RC 是 SC(this),SC(v:$cm),RC(v2),SC(v3) 中最窄的
        return ref Fun2(Value, ref rv_unscoped, ref rv); // $cm
        return ref Fun2(Value, ref rv, ref rv_scoped); // $ro
        _ = ref Fun2(Value, ref rv_scoped, ref rv_unscoped); // $local

        // Fun3 分析: `unscoped ref this`,`v`,`ref v2`
        // return 的 RC 是 RC(this), RC(this) = $local
        _ = ref Fun3(Value, ref rv);  // $local
        _ = ref Fun3(Value, ref rv_scoped); // $local; 

        // Fun4 分析: `scoped ref this`,`v`
        // return 的 RC 是 SC(this),SC(v) 中最窄的
        return ref Fun4(new Span<int>(ref rv), Value);  // $ro
        _ = ref Fun4(new Span<int>(ref rv_scoped), Value);  // $local
        return ref Fun4(new Span<int>(ref rv_unscoped), Value);  // $cm

        // Fun5 分析: `scoped ref this`,`v`,`ref v2`,`unscoped out v3`
        // return 的 RC 是 SC(this),SC(v),RC(v2),RC(v3) 中最窄的
        _ = ref Fun5(new Span<int>(ref rv_unscoped), ref rv_unscoped, out rv_scoped);  // $local
        return ref Fun5(new Span<int>(ref rv_unscoped), ref rv_unscoped, out rv);  // $ro
        return ref Fun5(new Span<int>(ref rv_unscoped), ref rv_unscoped, out rv_unscoped);  // $cm
        _ =  ref Fun5(new Span<int>(ref rv_unscoped), ref rv_unscoped, out _); // $local
    }
}
```

对于方法调用 `= ref e.M(e1,e2,...)` 产生的 *Lvalue*，当 `M()` 方法返回 `return ref ref-struct` 时，方法返回值的 *ref-safe-context* 与所有类型是 `ref struct` 的 `ref` 参数、`in` 参数、`[UnscopedRef] out`、（方法如果是）`ref struct` 结构的实例方法中的 `this` 的 *ref-safe-context* 中最窄的。

```csharp
using System.Diagnostics.CodeAnalysis;
struct Sample
{
    ref Span<int> Fun1(Span<int> v, ref Span<int> v2) => throw new Exception();
    ref Span<int> Fun2(Span<int> v, ref Span<int> v2, scoped ref Span<int> v3) => throw new Exception();
    ref Span<int> Fun3(Span<int> v, ref Span<int> v2, out Span<int> v3) => throw new Exception();
    ref Span<int> Fun4(Span<int> v, ref Span<int> v2, [UnscopedRef] out Span<int> v3) => throw new Exception();

    ref Span<int> Create(ref Span<int> r,             // SC: $cm,  RC: $ro
         [UnscopedRef] ref Span<int> r_unscoped,      // SC: $cm,  RC: $cm
         scoped ref Span<int> r_scoped,               // SC: $cm,  RC: $local
         out Span<int> o_scoped,                      // SC: $ro,  RC: $local
         [UnscopedRef] out Span<int> o_unscoped,      // SC: $ro,  RC: $ro
         scoped Span<int> v_scoped)                   // SC: $local, RC: $local
    {
        // 上下文范围降序 r_unscoped > r > r_scoped > o_unscoped > o_scoped > v_scoped
        o_scoped = default;
        o_unscoped = default;
        // Fun1 分析: 类型为 ref struct 的 ref-likes 参数为 `ref v2`
        // return ref 的 RC 是 RC(v2) 
        return ref Fun1(v: r, v2: ref r_unscoped);  // $cm
        return ref Fun1(v: r_scoped, v2: ref r);    // $ro
        return ref Fun1(v: o_unscoped, v2: ref o_unscoped); // $ro
        return ref Fun1(v: r_unscoped, v2: ref r_scoped); // $local
        return ref Fun1(v: v_scoped, v2: ref v_scoped);   // $local

        // Fun2 分析: `ref v2`,`scoped ref v3`
        // return ref 的 RC 与 RC(v2) 相同, SC(v) must >= SC(return) 
        return ref Fun2(v: r, ref r_scoped, ref r_scoped); // $local
        return ref Fun2(v: r_scoped, ref r_unscoped, ref r_unscoped);  // $cm
        return ref Fun2(v: o_scoped, ref o_unscoped, ref o_scoped);  // $ro
        return ref Fun2(v: r_unscoped, v2: ref v_scoped, v3: ref v_scoped); // $local
        return ref Fun2(v: v_scoped, v2: ref v_scoped, v3: ref v_scoped); // $local

        // Fun3 分析: `ref v2`,`out v3`
        // return ref 的 RC 与 RC(v2) 相同, MUST: SC(v) >= SC(return) >= RC(out), RC(ref) >= RC(out)
        return ref Fun3(r_unscoped, ref r_unscoped, out r_unscoped);  // $cm
        return ref Fun3(o_scoped, ref o_unscoped, out v_scoped);  // $ro
        return ref Fun3(v_scoped, ref v_scoped, out v_scoped);  // $local

        // Fun4 分析: `ref v2`,`unscoped out v3`
        // return ref 的 RC 是 RC(v2),RC(v3) 中最窄的, MUST: SC(v) >= SC(return) >= RC(out), RC(ref) >= RC(out)
        return ref Fun4(r_unscoped, ref r_unscoped, out r_unscoped);  // $cm
        return ref Fun4(r_unscoped, ref r, out o_unscoped);  // $ro
        return ref Fun4(r_unscoped, ref o_unscoped, out v_scoped);  // $local
        return ref Fun4(r_unscoped, ref o_unscoped, out o_unscoped);  // $ro
        return ref Fun4(v_scoped, ref v_scoped, out v_scoped);  // $local
    }
}
```

>---
#### 运算符和表达式

对于产生右值的运算符结果（例如 `e1 + e2` 或 `c ? e1 : e2`），结果的 *safe-context* 范围与运算符所有操作数中最窄的 *safe-context*。因此一元运算符的结果和运算符操作数的 *safe-context*。

使用运算符结果的 *Lvalue* 表达式（例如 `c? ref e1 : ref e2`），结果的 *ref-safe-context* 范围是所有操作数中最窄的 *ref-safe-context*。对于运算符的操作数 `e1` 和 `e2`，要求它们的 *safe-context* 必须一致。

`stackalloc` 表达式的值是一个 *Rvalue*，它的 *safe-context* 是 *function-member*，可以安全地转义到方法堆栈的上层调用，而无法从该方法转义到调用方。

`default` 表达式的 *safe-context* 是 *caller-context*。


```csharp
static Span<int> CreateSpanExample1(ref int i)
{
    var result = new Span<int>(ref i);
    return result;
}
static Span<int> CreateSpanExample2(ref int i)
{
    Span<int> result;
    result = new Span<int>(ref i); // Fails to compile on this line
    return result;
}
static Span<int> CreateSpanExample3(ref int i)
{
    Span<int> result = stackalloc int[0];
    result = new Span<int>(ref i);
    return result; // Fails to compile on this line
}
```

---
### Annex

预定义：
- `rs` 为 `ref struct` 类型的变量。
- `v` 为非 `ref struct` 的变量。
- `unscopd` 为 `[UnscopedRef]`。
- `EInit` 为初始化设定项。 

> 参数

| Parameter            | safe-context       | ref-safe-context  |
| -------------------- | ------------------ | ----------------- |
| `rs`                 | *caller-context*   | *function-member* |
| `scoped rs`          | *function-context* | *function-member* |
| `ref/in rs`          | *caller-context*   | *return-only*     |
| `scoped ref/in rs`   | *caller-context*   | *function-member* |
| `unscoped ref/in rs` | *caller-context*   | *caller-context*  |
| `out rs`             | *return-only*      | *function-member* |
| `unscoped out rs`    | *return-only*      | *return-only*     |
| `v`                  | *caller-context*   | *function-member* |
| `ref/in v`           | *caller-context*   | *return-only*     |
| `scoped ref/in v`    | *caller-context*   | *function-member* |
| `unscoped ref/in v`  | *caller-context*   | *caller-context*  |
| `out v`              | *caller-context*   | *function-member* |
| `unscoped out v`     | *caller-context*   | *return-only*     |

> 局部变量

| Local                | safe-context      | ref-safe-context  |
| -------------------- | ----------------- | ----------------- |
| `rs = EInit`         | *SC of EInit*     | *function-member* |
| `ref rs = ref EInit` | *SC of EInit*     | *RC of EInit*     |
| `scoped rs`          | *function-member* | *function-member* |
| `scoped ref rs`      | *function-member* | *function-member* |
| `v`                  | *caller-context*  | *function-member* |
| `ref v = ref EInit`  | *caller-context*  | *RC of EInit*     |
| `scoped ref v`       | *caller-context*  | *function-member* |

> 字段

| Field                 | safe-context     | ref-safe-context |
| --------------------- | ---------------- | ---------------- |
| `struct.Field`        | *caller-context* | *RC of struct*   |
| `class.Field`         | *caller-context* | *caller-context* |
| `rs.ref-struct_Field` | *SC of rs*       | *RC of struct*   |
| `rs.Ref_Field`        | *caller-context* | *RC of rs*       |

---